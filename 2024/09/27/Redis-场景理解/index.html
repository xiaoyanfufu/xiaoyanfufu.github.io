<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
    <link rel="icon" href="/images/earthstars.png">
  
  
  <title>Redis-场景理解 | XIAOYAN</title>
  <link rel="canonical" href="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/">
  <meta name="author" content="xiaoyan" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="Redis 和 MySQL为什么使用RedisRedis 具备高性能和高并发两大特性。 1. 高性能 Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。 2. 高并发 Redis 采用单线程模型，避免了多线程竞争带来的锁和上下文切换开销。这种设计使得 Redis 在处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis-场景理解">
<meta property="og:url" content="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/index.html">
<meta property="og:site_name" content="XIAOYAN">
<meta property="og:description" content="Redis 和 MySQL为什么使用RedisRedis 具备高性能和高并发两大特性。 1. 高性能 Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。 2. 高并发 Redis 采用单线程模型，避免了多线程竞争带来的锁和上下文切换开销。这种设计使得 Redis 在处理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.xiaolincoding.com//picgo/1720223533280-96461154-bd99-418c-bc90-52a90bc70cac.webp">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292053764.png">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292117062.png">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292152465.png">
<meta property="article:published_time" content="2024-09-27T00:54:37.000Z">
<meta property="article:modified_time" content="2024-11-02T11:05:28.124Z">
<meta property="article:author" content="xiaoyan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.xiaolincoding.com//picgo/1720223533280-96461154-bd99-418c-bc90-52a90bc70cac.webp">
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kr-core.min.css" media="all"></link>
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/highlight.js/night-eighties.min.css" media="all"></link>
  
  <link rel="stylesheet" id="theme-light-css" href="/css/kr-theme/light.min.css" media="all"></link>
  <link rel="stylesheet" id="theme-dark-css" href="/css/kr-theme/dark.min.css" media="(prefers-color-scheme: dark)"></link>
  <script src="/js/kr-theme.min.js"></script>
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></link>
  
    <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></link>
  
  
    <link rel="stylesheet" href="/vendors/viewerjs@1.11.6/dist/viewer.min.css"></link>
  
  <!-- 不得不预先加载的一些JS文件 -->
  
    <script src="/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js"></script>
  
  <!-- 自定义站点横幅和背景 -->
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/wallpaper_light.png');
      }
      html[data-theme="dark"] .kratos-cover.kratos-cover-2 {
        background-image: url('/images/wallpaper_dark.png');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
        html[data-theme="dark"] body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
    
      .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
      html[data-theme="dark"] .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
    
  </style>

  <!-- 额外的追加注入项 -->
  
    <link rel="stylesheet" href="/css/custom.css">

  
<meta name="generator" content="Hexo 7.3.0"></head>

    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    <li>
                                        
                                            <a href="/">
                                        
                                            
                                                <i class="fa fa-home"></i>
                                            
                                            首页
                                        </a>
                                        
                                    </li>
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">XIAOYAN</a></div>
                    <div id="kratos-nav-toggle-wrapper" class="nav-toggle">
                        <a id="kratos-nav-toggle" class="kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>XIAOYAN</h2> <br />
                        <span>山重水复疑无路，柳暗花明又一村。</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">


        

            

            <section class="kr-main-col col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/">
    <div class="kratos-hentry kratos-page-inner clearfix">
        <header class="kratos-page-header">
            
                <h1 class="kratos-page-title text-center" itemprop="name headline">Redis-场景理解</h1>
            
            <ul class="kratos-page-meta text-center">
                <li><time datetime="2024-09-27T00:54:37.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-09-27</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">xiaoyan</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~20.80K
                        
                        字
                    </li>
                
                
                
            </ul>
        </header>
        <div class="kratos-page-content kr-post">
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL"><span class="toc-number">1.</span> <span class="toc-text">Redis 和 MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E7%AD%89%E4%B8%8B%EF%BC%8CRedis-MySQL%E5%8D%95%E7%82%B9%E8%83%BD%E6%9C%89%E5%A4%9A%E5%A4%A7%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">高并发情况等下，Redis+MySQL单点能有多大并发量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">如何保证Redis和MySQL数据缓存一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">消息队列方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85MySQL-binlog%EF%BC%8C%E5%86%8D%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">订阅MySQL binlog，再操作缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%8E-Redis-%E7%BC%93%E5%AD%98%EF%BC%9A%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.</span> <span class="toc-text">本地缓存与 Redis 缓存：性能与应用场景的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">本地缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%88Redis%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">分布式缓存（Redis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">应用场景对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">Redis 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">Redis 实现消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pub-Sub%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用Pub&#x2F;Sub模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%EF%BC%88Publisher%EF%BC%89"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">发布者（Publisher）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%88Subscriber%EF%BC%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">订阅者（Subscriber）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List"><span class="toc-number">3.1.2.</span> <span class="toc-text">使用List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Stream%EF%BC%88Redis-5-0-%E5%90%8E%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用 Stream（Redis 5.0 后）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89-1"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89-1"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">Redis 实现分布式锁详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">Redis 分布式锁实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-SET-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%89%E6%8A%A2%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">基于 SET 命令的争抢锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedLock-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">RedLock 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-Key"><span class="toc-number">4.</span> <span class="toc-text">Redis Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">Redis 大 Key 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7-Key-%E9%97%AE%E9%A2%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">大 Key 问题的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">如何解决大 Key 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%83%ADKey"><span class="toc-number">5.</span> <span class="toc-text">热Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADkey"><span class="toc-number">5.1.</span> <span class="toc-text">什么是热key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey"><span class="toc-number">5.2.</span> <span class="toc-text">如何解决热key</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">三大缓存问题详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">布隆过滤器原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">Redis 应用设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">如何设计秒杀场景处理高并发以及超卖现象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据库层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.1.2.</span> <span class="toc-text">利用分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">7.1.3.</span> <span class="toc-text">利用分布式锁 + 分段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-Redis-%E7%9A%84-INCR%E3%80%81DECR-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">7.1.4.</span> <span class="toc-text">利用 Redis 的 INCR、DECR 的原子性 + 异步队列</span></a></li></ol></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><h1 id="Redis-和-MySQL"><a href="#Redis-和-MySQL" class="headerlink" title="Redis 和 MySQL"></a>Redis 和 MySQL</h1><h2 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h2><p>Redis 具备<strong>高性能</strong>和<strong>高并发</strong>两大特性。</p>
<p><strong>1. 高性能</strong></p>
<p>Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。</p>
<p><strong>2. 高并发</strong></p>
<p>Redis 采用单线程模型，避免了多线程竞争带来的锁和上下文切换开销。这种设计使得 Redis 在处理高并发请求时表现出色，其 QPS（每秒查询次数）轻松突破 10 万。此外，Redis 还可以通过部署 Redis 切片集群进一步增加整个系统的吞吐量。</p>
<h2 id="高并发情况等下，Redis-MySQL单点能有多大并发量？"><a href="#高并发情况等下，Redis-MySQL单点能有多大并发量？" class="headerlink" title="高并发情况等下，Redis+MySQL单点能有多大并发量？"></a>高并发情况等下，Redis+MySQL单点能有多大并发量？</h2><ul>
<li>若命中Redis缓存，4C8G内存配置 ，单点Redis能够达到10wQPS。</li>
<li>若未命中Redis缓存，4C8G内存配置，单点MySQL仅能达到5k左右QPS。</li>
</ul>
<h2 id="如何保证Redis和MySQL数据缓存一致性问题"><a href="#如何保证Redis和MySQL数据缓存一致性问题" class="headerlink" title="如何保证Redis和MySQL数据缓存一致性问题"></a>如何保证Redis和MySQL数据缓存一致性问题</h2><p>在分布式系统中，缓存和数据库之间的数据一致性是一个常见的问题。为了保证数据的一致性，通常采用旁路缓存策略，即先更新数据库，再删除缓存。</p>
<p>缓存通过牺牲强一致性来实现高性能，也就是<strong>CAP理论</strong>中的<strong>AP</strong>模式。所以，要保持数据的强一致性，就不适合使用缓存。但是，我们可以通过一些缓存方案优化来保证<strong>最终一致性</strong>。</p>
<h3 id="消息队列方案"><a href="#消息队列方案" class="headerlink" title="消息队列方案"></a>消息队列方案</h3><p>为了保证缓存删除操作的可靠性，可以引入消息队列，由消费者来完成缓存删除操作。</p>
<img src="https://cdn.xiaolincoding.com//picgo/1720223533280-96461154-bd99-418c-bc90-52a90bc70cac.webp" alt="旁路缓存机制(图片来源小林coding)" style="zoom:80%;">

<ol>
<li><strong>生产者：</strong>在写数据时，将删除缓存的操作发送到消息队列中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    mysql.update(key, value);</span><br><span class="line">    messageQueue.send(<span class="string">&quot;delete_cache&quot;</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>消费者：</strong>消费者从消息队列中获取消息，执行缓存删除操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.receive(<span class="string">&quot;delete_cache&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey();</span><br><span class="line">        redis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果应用删除缓存失败，可以从消息队列中重新获取消息，再次尝试删除缓存。这就是<strong>消息重试机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.receive(<span class="string">&quot;delete_cache&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redis.del(key);</span><br><span class="line">            messageQueue.ack(message); <span class="comment">// 删除缓存成功，确认消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            messageQueue.nack(message); <span class="comment">// 删除缓存失败，重新入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重试删除缓存机制总体可用，但可能造成<strong>业务代码入侵（</strong>业务代码入侵（Business Code Invasion）是指在业务逻辑代码中嵌入了与业务逻辑无关的代码，导致业务代码变得复杂、难以维护，并且增加了系统的耦合度。）。</p>
<h3 id="订阅MySQL-binlog，再操作缓存"><a href="#订阅MySQL-binlog，再操作缓存" class="headerlink" title="订阅MySQL binlog，再操作缓存"></a>订阅MySQL binlog，再操作缓存</h3><p>该策略的第一步是更新数据库，当数据库更新成功，会将旧的值存入 binlog 中。于是我们可以通过订阅 binlog 日志，拿到具体要删除的记录，再执行缓存删除。</p>
<p>可以使用开源工具如 Canal 来订阅 MySQL binlog。订阅 MySQL binlog，获取更新操作的记录，以下是示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinlogSubscriber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="string">&quot;localhost&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        connector.connect();</span><br><span class="line">        connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(<span class="number">100</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">            <span class="keyword">if</span> (batchId == -<span class="number">1</span> || message.getEntries().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry entry : message.getEntries()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getEntryType() == EntryType.ROWDATA) &#123;</span><br><span class="line">                    <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                    <span class="keyword">for</span> (RowData rowData : rowChange.getRowDatasList()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rowChange.getEventType() == EventType.UPDATE) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> rowData.getAfterColumns(<span class="number">0</span>).getValue();</span><br><span class="line">                            redis.del(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connector.ack(batchId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="本地缓存与-Redis-缓存：性能与应用场景的对比"><a href="#本地缓存与-Redis-缓存：性能与应用场景的对比" class="headerlink" title="本地缓存与 Redis 缓存：性能与应用场景的对比"></a>本地缓存与 Redis 缓存：性能与应用场景的对比</h1><p>在现代应用开发中，缓存是提升系统性能和响应速度的重要手段。本地缓存和分布式缓存（如 Redis）是两种常见的缓存策略，各自具有独特的优势和适用场景。本文将深入探讨本地缓存和 Redis 缓存的性能特点，并通过对比帮助读者理解它们在不同场景下的应用。</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>本地缓存是指将数据存储在本地程序或服务器上，通常使用内存作为存储介质。本地缓存通过利用内存的高速读写特性，显著提升数据访问速度。</p>
<ol>
<li>优势</li>
</ol>
<ul>
<li><strong>访问速度快</strong>：由于数据存储在本地内存中，访问速度极快，适合需要高频访问的数据。</li>
<li><strong>减轻网络压力</strong>：本地缓存减少了对外部数据源的依赖，从而减轻了网络带宽的压力。</li>
</ul>
<ol start="2">
<li>不足</li>
</ol>
<ul>
<li><strong>可扩展性有限</strong>：本地缓存通常局限于单个服务器或进程，难以应对大规模分布式系统的需求。</li>
</ul>
<h2 id="分布式缓存（Redis）"><a href="#分布式缓存（Redis）" class="headerlink" title="分布式缓存（Redis）"></a>分布式缓存（Redis）</h2><p>分布式缓存是指将数据存储在多个分布式节点上，通过协同工作提升高性能的数据访问服务。Redis 是一种常见的分布式缓存解决方案，通常采用集群的方式进行部署，通过多台服务器分担数据压力。</p>
<ol>
<li>优势</li>
</ol>
<ul>
<li><strong>可扩展性强</strong>：可以根据业务需求动态增加或减少集群节点，灵活应对数据量的变化。</li>
<li><strong>数据高一致性</strong>：Redis 采用主从同步复制机制，确保数据在多个节点之间保持一致性。</li>
<li><strong>易于维护</strong>：分布式缓存通常采用自动化管理方式，降低维护成本，提高运维效率。</li>
</ul>
<ol start="2">
<li>不足</li>
</ol>
<ul>
<li><strong>访问相对较慢</strong>：相比于本地缓存，分布式缓存需要通过网络访问数据，访问速度相对较慢。</li>
<li><strong>网络开销大</strong>：分布式缓存依赖网络通信，网络延迟和带宽限制可能影响性能。</li>
</ul>
<h2 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h2><p><strong>本地缓存适用场景</strong></p>
<ul>
<li><strong>高频访问数据</strong>：适合存储频繁访问的热数据，如用户会话、配置信息等。</li>
<li><strong>单机应用</strong>：适用于单机或单进程的应用场景，数据量较小且不需要分布式扩展。</li>
</ul>
<p><strong>Redis 缓存适用场景</strong></p>
<ul>
<li><strong>大规模分布式系统</strong>：适合需要处理海量数据和高并发请求的分布式系统。</li>
<li><strong>数据一致性要求高</strong>：适用于需要确保数据一致性的场景，如电商平台的商品库存管理。</li>
<li><strong>动态扩展需求</strong>：适用于需要根据业务需求动态调整缓存规模的场景。</li>
</ul>
<h1 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h1><p>Redis 是一种基于内存的高性能数据库，凭借其快速的读写速度和丰富的数据结构，广泛应用于各种场景中。本文将详细介绍 Redis 在不同应用场景中的具体用途，并通过实例帮助读者更好地理解其优势。</p>
<ul>
<li><strong>缓存：</strong>缓存是 Redis 最常见的应用场景之一。通过将热门数据存储在内存中，Redis 可以显著提高系统的访问速度，减轻后端数据库的压力。</li>
<li><strong>计数器：</strong>Redis 的单线程模式和操作的原子性使其非常适合用于实现计数器和统计功能。常见的应用包括页面访问量统计、用户行为统计等。（常用数据结构String、HyperLogLog）</li>
<li><strong>排行榜：</strong>Redis 中的有序集合（Sorted Set，Zset）能够实现对数据的自动排序，非常适合用于排行榜、热门文章等需要排序的应用场景。</li>
<li><strong>分布式锁：</strong>在分布式系统中，为了避免多个进程同时操作同一资源，可以使用 Redis 实现分布式锁。常见的应用包括资源访问控制、任务调度等。</li>
<li><strong>消息队列：</strong>Redis 的发布和订阅功能（Pub&#x2F;Sub）使其可以作为一个轻量级的消息队列系统。常见的应用包括异步任务处理、事件通知等。（常用数据结构List、Stream）</li>
</ul>
<h2 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h2><h3 id="使用Pub-Sub模式"><a href="#使用Pub-Sub模式" class="headerlink" title="使用Pub&#x2F;Sub模式"></a>使用Pub&#x2F;Sub模式</h3><p>Redis 的 Pub&#x2F;Sub 模式是一种基于发布者&#x2F;订阅者的模式。任何客户端都可以订阅一个或多个频道，发布者可以向特定频道发布消息，所有订阅了该频道的订阅者都会收到消息。发布者和订阅者完全解耦，并且支持模式匹配。但是这种方式并不支持持久化，也就是说当发布者将消息发布后，若此时无订阅者，消息就会丢失。</p>
<p>示例：</p>
<h4 id="发布者（Publisher）"><a href="#发布者（Publisher）" class="headerlink" title="发布者（Publisher）"></a>发布者（Publisher）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息到频道 &quot;news&quot;</span></span><br><span class="line">        jedis.publish(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;Breaking News: Redis Pub/Sub Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="订阅者（Subscriber）"><a href="#订阅者（Subscriber）" class="headerlink" title="订阅者（Subscriber）"></a>订阅者（Subscriber）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubscriber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅频道 &quot;news&quot;</span></span><br><span class="line">        jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Received: &quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;news&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h3><p>使用 List 实现消息队列是一种简单且高效的方式。生产者使用 <code>LPUSH</code> 命令将消息添加到 List 的队尾，消费者使用 <code>BLPOP</code> 或 <code>BRPOP</code> 命令阻塞地从队首取出消息进行消费（先进先出，FIFO）。这种方式可以结合Redis的过期时间特性实现消息的TTL，通过Redis事务可以保证操作的原子性，但需要客户端自己实现消息确认、消息重试机制。</p>
<h4 id="生产者（Producer）"><a href="#生产者（Producer）" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息添加到 List &quot;messageQueue&quot;</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;messageQueue&quot;</span>, <span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;messageQueue&quot;</span>, <span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者（Consumer）"><a href="#消费者（Consumer）" class="headerlink" title="消费者（Consumer）"></a>消费者（Consumer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞地从 List &quot;messageQueue&quot; 中取出消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> jedis.brpop(<span class="number">0</span>, <span class="string">&quot;messageQueue&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="comment">// jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Stream（Redis-5-0-后）"><a href="#使用-Stream（Redis-5-0-后）" class="headerlink" title="使用 Stream（Redis 5.0 后）"></a>使用 Stream（Redis 5.0 后）</h3><p>Redis Stream 是 Redis 5.0 引入的一种新的数据结构，专门用于实现消息队列。Stream 提供了更强大的功能，如消息持久化、消费者组、消息确认等。</p>
<h4 id="生产者（Producer）-1"><a href="#生产者（Producer）-1" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStreamProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消息</span></span><br><span class="line">        Map&lt;String, String&gt; message = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        message.put(<span class="string">&quot;event&quot;</span>, <span class="string">&quot;New Order&quot;</span>);</span><br><span class="line">        message.put(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息添加到 Stream &quot;orderStream&quot;</span></span><br><span class="line">        jedis.xadd(<span class="string">&quot;orderStream&quot;</span>, StreamEntryID.NEW_ENTRY, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者（Consumer）-1"><a href="#消费者（Consumer）-1" class="headerlink" title="消费者（Consumer）"></a>消费者（Consumer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamGroup;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamInfo;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamPendingEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStreamConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者组</span></span><br><span class="line">        jedis.xgroupCreate(<span class="string">&quot;orderStream&quot;</span>, <span class="string">&quot;orderGroup&quot;</span>, <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            List&lt;StreamEntry&gt; messages = jedis.xreadGroup(<span class="string">&quot;orderGroup&quot;</span>, <span class="string">&quot;consumer1&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">&quot;orderStream&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (StreamEntry message : messages) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + message.getFields());</span><br><span class="line">                <span class="comment">// 确认消息</span></span><br><span class="line">                jedis.xack(<span class="string">&quot;orderStream&quot;</span>, <span class="string">&quot;orderGroup&quot;</span>, message.getID());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="comment">// jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis-实现分布式锁详解"><a href="#Redis-实现分布式锁详解" class="headerlink" title="Redis 实现分布式锁详解"></a>Redis 实现分布式锁详解</h2><p>在分布式系统中，为了避免多个进程同时操作同一资源，分布式锁是一种常用的解决方案。Redis 提供了多种实现分布式锁的方式，本文将详细介绍基于 <code>SET</code> 命令的争抢锁机制和 RedLock 算法，并通过代码示例帮助读者更好地理解其应用。</p>
<h3 id="Redis-分布式锁实现原理"><a href="#Redis-分布式锁实现原理" class="headerlink" title="Redis 分布式锁实现原理"></a>Redis 分布式锁实现原理</h3><p>分布式锁是分布式并发状态下的一种机制，用于控制一个资源在一个时间内，只有一个应用能对其进行使用。</p>
<p>Redis本身可以被多个客户端进行访问，就像一个共享存储，可以用来保存分布式锁。Redis 的 <code>SET</code> 命令参数 <code>NX</code> 表示只有在键不存在时才设置，具有互斥性，非常适合用来构建分布式锁：</p>
<ul>
<li><strong>若key存在</strong>，证明被加过锁了，所以此时可以认为加锁失败。</li>
<li><strong>若key不存在</strong>，证明未被加锁，可以认为加锁成功。</li>
</ul>
<p>基于Redis节点实现分布式锁，对于加锁条件，我们需要满足三个条件：</p>
<ul>
<li><strong>原子性</strong>：加锁操作涉及多个操作（读取锁变量、检查锁变量、设置锁变量），需要保证这些操作的原子性。</li>
<li><strong>过期时间</strong>：锁变量需要设置过期时间，避免客户端获得锁后挂掉，锁一直不释放造成死锁。</li>
<li><strong>唯一性</strong>：锁变量的值需要能区分是哪个客户端设置的锁，避免在释放锁时造成误释放操作。</li>
</ul>
<h3 id="基于-SET-命令的争抢锁机制"><a href="#基于-SET-命令的争抢锁机制" class="headerlink" title="基于 SET 命令的争抢锁机制"></a>基于 <code>SET</code> 命令的争抢锁机制</h3><p>Redis 提供了 <code>SET</code> 命令的扩展参数，可以用于实现分布式锁。通过 <code>SET resource_name lock_value NX PX milliseconds</code> 命令，客户端可以尝试获取锁。其中：</p>
<ul>
<li><code>NX</code>：表示只有当键值不存在时才设置。</li>
<li><code>PX milliseconds</code>：指定锁的过期时间（毫秒）。</li>
</ul>
<p>如果设置成功，则认为当前客户端获得了锁。当客户端完成操作后，需要删除锁，这里涉及两个以上的操作（判断锁是否属于自己、删除锁），因此可以使用 Lua 脚本来保证 Redis 命令的原子性。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;my_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_VALUE</span> <span class="operator">=</span> <span class="string">&quot;lock_value&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 锁的过期时间，单位：毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, LOCK_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, LOCK_EXPIRE_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired successfully.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行需要加锁的操作</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            releaseLock(jedis);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        jedis.eval(script, <span class="number">1</span>, LOCK_KEY, LOCK_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>锁的过期时间</strong>：设置合理的锁过期时间，避免锁长时间占用资源。</li>
<li><strong>锁的唯一性</strong>：确保锁的值是唯一的，通常使用 UUID 或其他唯一标识符。</li>
<li><strong>Lua 脚本</strong>：使用 Lua 脚本保证释放锁操作的原子性。</li>
</ul>
<h3 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h3><p>RedLock 算法是 Redis 官方推荐的分布式锁实现方式，适用于需要高可用性和容错性的场景。RedLock 算法通过在多个独立的 Redis 实例上获取锁，并确保大多数实例（超过半数）成功获取锁，来实现分布式锁。</p>
<p>算法步骤</p>
<ol>
<li><strong>获取当前时间</strong>：记录当前时间戳。</li>
<li><strong>尝试获取锁</strong>：在每个 Redis 实例上尝试获取锁，使用相同的键和随机值。</li>
<li><strong>计算获取锁的时间</strong>：计算从开始获取锁到所有实例返回结果的时间。</li>
<li><strong>判断锁是否获取成功</strong>：如果大多数实例（超过半数）成功获取锁，并且获取锁的时间小于锁的有效期，则认为锁获取成功。</li>
<li><strong>释放锁</strong>：在所有实例上释放锁。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;my_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_VALUE</span> <span class="operator">=</span> <span class="string">&quot;lock_value&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 锁的过期时间，单位：毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUORUM</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 大多数实例的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JedisPool&gt; jedisPools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedLock</span><span class="params">(List&lt;String&gt; redisServers)</span> &#123;</span><br><span class="line">        jedisPools = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String server : redisServers) &#123;</span><br><span class="line">            String[] parts = server.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">            <span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, parts[<span class="number">0</span>], Integer.parseInt(parts[<span class="number">1</span>]));</span><br><span class="line">            jedisPools.add(pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (JedisPool pool : jedisPools) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, LOCK_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, LOCK_EXPIRE_TIME);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">                    successCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">return</span> successCount &gt;= QUORUM &amp;&amp; elapsedTime &lt; LOCK_EXPIRE_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (JedisPool pool : jedisPools) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">                jedis.eval(script, <span class="number">1</span>, LOCK_KEY, LOCK_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; redisServers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6379&quot;</span>);</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6380&quot;</span>);</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6381&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedLock</span>(redisServers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redLock.acquireLock()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired successfully.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行需要加锁的操作</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redLock.releaseLock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li><strong>多数原则</strong>：确保大多数实例（超过半数）成功获取锁。</li>
<li><strong>时间同步</strong>：各个 Redis 实例的时间需要同步，避免时间差异导致锁失效。</li>
<li><strong>故障处理</strong>：处理 Redis 实例故障的情况，确保锁的可靠性。</li>
</ul>
<h1 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis Key"></a>Redis Key</h1><h2 id="Redis-大-Key-问题"><a href="#Redis-大-Key-问题" class="headerlink" title="Redis 大 Key 问题"></a>Redis 大 Key 问题</h2><p>在 Redis 中，大 Key 问题指的是一个键（Key）对应的值（Value）过大，导致 Redis 处理起来缓慢、内存不足、影响主从同步延迟等问题。</p>
<p>大地多大算大Key？这是没有标准的，通常认为字符串类型的key对应的value值空间占用超过了1M，或者集合中key对应的元素个数超过了1w，我们就认为该key是大key。</p>
<h2 id="大-Key-问题的缺点"><a href="#大-Key-问题的缺点" class="headerlink" title="大 Key 问题的缺点"></a>大 Key 问题的缺点</h2><ol>
<li><p><strong>内存占用较高</strong>：大 Key 会占用大量的内存，导致 Redis 可用内存减少。Redis 是一个内存数据库，内存是其主要资源。如果内存被大 Key 占用过多，可能会导致内存不足，触发内存淘汰策略，影响其他键的访问。</p>
</li>
<li><p><strong>降低性能</strong>：当对大 Key 进行处理时，会花费更多的 CPU 时间，导致整体性能下降，甚至会阻塞其他客户端的请求。大 Key 的读取、写入、删除等操作都会消耗更多的 CPU 资源，影响 Redis 的响应速度。</p>
</li>
<li><p><strong>网络拥塞</strong>：大 Key 在网络传输时会占用大量带宽，可能导致网络拥塞。特别是在高并发场景下，大量请求传输大 Key 会导致网络资源被耗尽，影响其他请求的传输。假设有一个大 Key <code>image:12345</code>，对应的值是一个 1MB 的图片数据。如果有 1000 个请求同时传输这个大 Key，会占用 1000MB 的网络带宽，导致网络拥塞。</p>
</li>
<li><p><strong>主从复制延迟</strong>：大 Key 在主从复制时需要传输大量数据，可能导致主从复制延迟，影响数据一致性。特别是在主从节点之间网络带宽有限的情况下，大 Key 的传输会占用大量带宽，导致复制延迟。</p>
</li>
<li><p><strong>数据倾斜</strong>：一个大 Key 会造成单个切片节点使用了很大一部分内存，导致内存使用率远超其他切片节点。这种数据倾斜会导致集群中某些节点负载过重，影响整体性能。</p>
</li>
</ol>
<h2 id="如何解决大-Key-问题"><a href="#如何解决大-Key-问题" class="headerlink" title="如何解决大 Key 问题"></a>如何解决大 Key 问题</h2><ul>
<li><strong>大Key拆分：</strong>将数万成员的大 Key 拆分为更小的分散的 Key，可以有效减少单个键的内存占用，提高 Redis 的处理效率。。</li>
<li><strong>内存清理：</strong>将大 Key 转移到其他存储介质（如文件系统、数据库等），然后释放 Redis 中的 Key，避免占用内存空间。（要使用异步删除）</li>
<li><strong>内存阈值监控：</strong>持续监控 Redis 的内存使用率，当发现内存用量到达阈值时或内存使用率突然大幅提升时，对内存进行相应的处理，比如删除不需要的 Key。。</li>
<li><strong>定期删除：</strong>定时对过期的 Key 进行删除，避免持续堆积而产生大 Key。</li>
</ul>
<h1 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h1><h2 id="什么是热key"><a href="#什么是热key" class="headerlink" title="什么是热key"></a>什么是热key</h2><p>热 Key 是指那些被频繁访问的键（Key），其请求频率远高于其他键。热 Key 问题会导致 Redis 的性能瓶颈，影响整体系统的响应速度。</p>
<ul>
<li><strong>QPS 请求集中在特定 Key</strong>：假设 Redis 有 10,000 的 QPS（每秒查询次数），而某个 Key 被请求的频率达到 7,000 QPS。</li>
<li><strong>带宽使用率集中在特定的 Key</strong>：某个 Key 的传输数据量占用了大量网络带宽。</li>
<li><strong>CPU 使用时间集中在特定的 Key</strong>：某个 Key 的处理占用了大量 CPU 时间。</li>
</ul>
<p><strong>热 Key 的影响</strong></p>
<ul>
<li><strong>性能瓶颈</strong>：热 Key 会导致 Redis 的性能瓶颈，影响整体系统的响应速度。</li>
<li><strong>资源浪费</strong>：热 Key 会占用大量 CPU、内存和网络资源，导致其他请求的资源不足。</li>
</ul>
<h2 id="如何解决热key"><a href="#如何解决热key" class="headerlink" title="如何解决热key"></a>如何解决热key</h2><ul>
<li><strong>负载均衡</strong>：由于 Redis 切片集群中，Key 的迁移粒度问题，无法将热 Key 迁移到其他节点分散单点压力。此时可以将热 Key 复制多几份，重新命名后装配到其他节点，并将热 Key 的请求分散到这些分散的节点中，以此降低单点压力。</li>
<li><strong>缓存预热</strong>：在系统启动时，提前加载热 Key 的数据到缓存中，避免系统启动后瞬间的高并发请求导致热 Key 问题。</li>
</ul>
<h1 id="三大缓存问题详解"><a href="#三大缓存问题详解" class="headerlink" title="三大缓存问题详解"></a>三大缓存问题详解</h1><p>在分布式系统中，缓存是提升系统性能的重要手段。然而，缓存也会带来一些问题，如<strong>缓存雪崩</strong>、<strong>缓存击穿</strong>和<strong>缓存穿透</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指，在高并发场景下，同一时间内大量 Key 过期，或者 Redis 节点故障，导致大量的数据请求冲向数据库服务器，数据库可能会因无法承受大量数据请求而宕机。</p>
<img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png" alt="缓存雪崩" style="zoom:80%;">

<p>对于大量key同时过期造成的缓存雪崩，我们可以设置以下方案解决：</p>
<ol>
<li><strong>均匀key过期时间</strong>：对于同一时间大量 Key 过期而产生的缓存雪崩，可以设置随机的过期时间，避免大量 Key 在同一时间失效。通过在基础过期时间上增加一个随机值，可以有效分散 Key 的过期时间，避免集中失效。</li>
<li><strong>不设置 Key 过期时间</strong>：若业务场景可能长期需要该 Key，那么可以不设置过期时间，待业务活动过期后手动将 Key 删除。这种方式适用于那些长期有效的数据，避免频繁的缓存重建。</li>
<li><strong>互斥锁</strong>：当业务线程发现该 Key 不在缓存中，就设置一个互斥锁，保证同一时间只有一个线程在处理缓存，避免在失效期间大量线程同一时间读数据库写缓存。通过互斥锁，可以有效控制缓存重建的并发度，减少数据库压力。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，在高并发场景下，某个热点 Key 在缓存中过期，导致大量请求直接访问数据库，导致数据库压力骤增，甚至宕机。</p>
<img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292053764.png" alt="缓存击穿" style="zoom:80%;">

<p>对于缓存击穿，我们也可以使用应对缓存雪崩中采取的两个方案：</p>
<ul>
<li><strong>互斥锁：</strong>使用互斥锁，保证同一时间只有一个线程访问数据库，其他线程等待缓存更新。通过互斥锁，可以有效控制缓存重建的并发度，减少数据库压力。</li>
<li><strong>热点数据永不过期：</strong>对于热点数据，可以设置永不过期，或者设置较长的过期时间。这种方式适用于那些长期有效的数据，避免频繁的缓存重建。</li>
<li><strong>后台异步更新</strong>：保持热点 Key 持续在线，由后台异步更新缓存。或者在 Key 即将过期时通知后台线程，重新设置过期时间。这种方式可以避免缓存过期瞬间的大量请求冲击数据库。</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指，在高并发场景下，请求的数据在缓存和数据库中都不存在，导致每次请求都直接访问数据库，导致数据库压力骤增，甚至宕机。</p>
<img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292117062.png" alt="缓存穿透" style="zoom:80%;">

<p>对于缓存穿透，我们可以采取以下方案：</p>
<ol>
<li><strong>限制非法请求</strong>：当有恶意的请求故意查询一条不存在的数据，大量的恶意请求也会导致缓存穿透问题。由此我们需要判断请求参数是否合理，过滤掉非法的数据请求。通过参数校验和请求过滤，可以有效减少非法请求对数据库的冲击。</li>
<li><strong>缓存空值或默认值</strong>：当我们发现环境中存在缓存穿透现象时，可以为不存在的数据设置为空值或默认值，当缓存中存在有值就不需要向数据库发起大量的请求了。通过缓存空值或默认值，可以避免大量请求直接访问数据库。</li>
<li><strong>布隆过滤器</strong>：我们可以在写入数据库时，使用布隆过滤器做标记，然后再请求到来时先判断缓存中是否存在该数据，若不存在则通过布隆过滤器快速判断要请求的数据是否存在。<strong>若判断存在，则数据可能存在</strong>，可以进一步向数据库查询；<strong>若判断不存在，则一定不存在</strong>，直接返回。通过布隆过滤器，可以快速过滤掉不存在的数据请求，减少数据库压力，Redis本身也实现了布隆过滤器。</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>布隆过滤器是一种空间效率很高的概率型数据结构，用于判断一个元素是否在一个集合中。它由“初始值都为0的位图数组”和“n个哈希函数”两部分组成。布隆过滤器通过哈希计算来判断数据是否存在，具有高效的查询速度和较低的空间占用，但存在一定的误判率。当我们在写入数据库的时候，会在布隆过滤器中设置标记，证明该数据在数据库中存在，这样下次查询的时候直接先通过布隆过滤器就能判断出该数据在数据库中是否存在而不需要进一步查询数据库。</p>
<p>布隆过滤器会通过3个操作完成标记：</p>
<ol>
<li><strong>哈希计算</strong>：使用n个哈希函数对数据进行哈希计算，得到n个哈希值。</li>
<li><strong>取模操作</strong>：将n个哈希值分别对位图数组的长度取模，得到每个哈希值在位图数组中相对应的位置。</li>
<li><strong>设置标记</strong>：将每个哈希值在位图数组中相应的位置设置为1。</li>
</ol>
<p>举个例子，假设有一个长度为5的位图数组、哈希函数有2个的布隆过滤器。</p>
<img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292152465.png" alt="布隆过滤器" style="zoom:80%;">

<p>将数据x写入数据库后，会对数据x进行哈希计算，得到n个哈希值；再将得到的哈希值取模，也就得到了一堆数字结果，对应布隆过滤器中位图数组的位置；将这些位置设为1.下次要判断x是否存在于数据库中时，只需要对x进行哈希计算，查看对应位图数组上相应的位置是不是全都为1，如果全都是1，则认为数据可能存在于数据库中，可以继续下一步查询；否则，认为数据一定不存在。</p>
<p>布隆过滤器通过哈希计算来判断数据是否存在，必然存在哈希冲突，可能会有两个不同的数据计算出同样的哈希值，造成误判。具体来说：</p>
<ul>
<li><strong>误判情况</strong>：布隆过滤器<strong>认为数据存在</strong>，但实际上<strong>数据可能不存在</strong>。这种情况称为“假阳性”（False Positive）。</li>
<li><strong>正确情况</strong>：布隆过滤器<strong>认为数据不存在</strong>，则数据<strong>一定不存在</strong>。这种情况称为“真阴性”（True Negative）。</li>
</ul>
<p>所以，布隆过滤器认为该数据存在，则其可能存在；若认为数据不存在，则一定不存在。</p>
<h1 id="Redis-应用设计"><a href="#Redis-应用设计" class="headerlink" title="Redis 应用设计"></a>Redis 应用设计</h1><h2 id="如何设计秒杀场景处理高并发以及超卖现象？"><a href="#如何设计秒杀场景处理高并发以及超卖现象？" class="headerlink" title="如何设计秒杀场景处理高并发以及超卖现象？"></a>如何设计秒杀场景处理高并发以及超卖现象？</h2><p>秒杀场景是一种典型的高并发场景，通常涉及大量用户在短时间内对有限数量的商品进行抢购。为了应对高并发和避免超卖现象，需要从数据库层面、分布式锁、分段锁以及 Redis 和异步队列等多个方面进行设计和优化。</p>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ol>
<li>查询商品库存时加排他锁</li>
</ol>
<p>在查询商品库存时，可以使用数据库的排他锁（<code>FOR UPDATE</code>）来保证数据的一致性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在事务中，线程 A 通过该语句给 id 为 ? 的数据行上了一个行级的排他锁。此时在事务期间，其他线程对该行的 <code>UPDATE</code> 和 <code>DELETE</code> 操作都将被阻塞，直到事务提交或发生回滚释放锁。</p>
<ol start="2">
<li>更新数据库减库存时进行库存限制</li>
</ol>
<p>在更新数据库减库存时，可以通过条件判断来避免超卖现象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> goods <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这种通过数据库加锁来解决的方案，性能不是很好，在高并发的情况下可能会因为获取不到数据库的连接或超时等待报错。</p>
<h3 id="利用分布式锁"><a href="#利用分布式锁" class="headerlink" title="利用分布式锁"></a>利用分布式锁</h3><p>分布式锁可以保证在同一时间内只有一个客户端能获取到锁，获得锁的线程才能进行接下来的业务逻辑，而其他客户端获取不到锁只能无限循环尝试获取锁。</p>
<p>可以使用 Redis 的 <code>SETNX</code> 命令来实现分布式锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(String lockKey, String lockValue, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, lockValue, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String lockValue)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    jedis.eval(script, <span class="number">1</span>, lockKey, lockValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高并发状态下，分布式锁只能进行串行化处理，效率很低。比如大量用户对同一个热门商品下单，此时只能一个个处理下单操作，效率很慢。</p>
<h3 id="利用分布式锁-分段锁"><a href="#利用分布式锁-分段锁" class="headerlink" title="利用分布式锁 + 分段锁"></a>利用分布式锁 + 分段锁</h3><p>把数据分成很多段，每一段加上一个单独的锁，细粒度化，使得线程在对一段数据进行修改时，其他线程可以继续对剩下部分进行加锁操作。</p>
<p>假设商品库存分为多个段，每个段使用独立的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireSegmentLock</span><span class="params">(String segmentKey, String lockValue, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(segmentKey, lockValue, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseSegmentLock</span><span class="params">(String segmentKey, String lockValue)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    jedis.eval(script, <span class="number">1</span>, segmentKey, lockValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分段锁，可以提高并发处理能力，减少锁的竞争，提升系统的吞吐量。</p>
<h3 id="利用-Redis-的-INCR、DECR-的原子性-异步队列"><a href="#利用-Redis-的-INCR、DECR-的原子性-异步队列" class="headerlink" title="利用 Redis 的 INCR、DECR 的原子性 + 异步队列"></a>利用 Redis 的 <code>INCR</code>、<code>DECR</code> 的原子性 + 异步队列</h3><ol>
<li>系统初始化时加载库存到 Redis</li>
</ol>
<p>在系统初始化时，将商品的库存数量加载到 Redis 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadStockToRedis</span><span class="params">(String key, <span class="type">int</span> stock)</span> &#123;</span><br><span class="line">    jedis.set(key, String.valueOf(stock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接收到秒杀请求时预减库存</li>
</ol>
<p>接收到秒杀请求时，在 Redis 中进行预减库存（利用 Redis <code>DECR</code> 的原子性），当 Redis 的库存不足时直接返回秒杀失败，否则继续进行第三步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preDecreaseStock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stock</span> <span class="operator">=</span> jedis.decr(key);</span><br><span class="line">    <span class="keyword">return</span> stock &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3, 将请求放入异步队列</p>
<p>将请求放入异步队列中，返回正在排队中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueueRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">    jedis.lpush(<span class="string">&quot;seckill_queue&quot;</span>, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>服务端异步队列请求出队</li>
</ol>
<p>服务端异步队列请求出队（可以出队的情况根据业务来判定，比如判断是否已秒杀过，防重复秒杀），出队的请求可以生成秒杀订单，减少数据库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;seckill_queue&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理秒杀请求，生成订单，减少库存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>客户端轮询查看秒杀结果</li>
</ol>
<p>用户在客户端申请完秒杀后，进行轮询，查看是否秒杀成功，秒杀成功则进入秒杀订单详情，否则秒杀失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSeckillResult</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;seckill_result:&quot;</span> + requestId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用了异步队列写入数据库，可能存在数据不一致问题，其次引用多个组件，复杂度比较高。</p>
</div>
        </div>
        
        <footer class="kratos-entry-footer clearfix">
            
            
            
                <div class="post-actions text-center clearfix" id="post-actions">
                
                    <a class="donate" href="javascript:;" onclick="krOpenDonateModal()"><i class="fa fa-bitcoin"></i> 打赏</a>
                
                
                    <a class="share" href="javascript:;" onclick="krOpenShareModal()"><i class="fa fa-share-alt"></i> 分享</a>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                    <time datetime="2024-11-02T11:05:28.124Z" itemprop="dateModified">最后编辑：2024-11-02</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Redis-集群" href="/2024/09/27/Redis-集群/"><i class="fa fa-angle-left"></i> 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" Spring-基础（上）" href="/2024/09/30/Spring-基础（上）/">下一篇 <i class="fa fa-angle-right"></i></a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

            
                

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/user.jpg" alt="xiaoyan" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">是一只时时翻垃圾吃的宅子。</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                44
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                17
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                65
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL"><span class="toc-number">1.</span> <span class="toc-text">Redis 和 MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E7%AD%89%E4%B8%8B%EF%BC%8CRedis-MySQL%E5%8D%95%E7%82%B9%E8%83%BD%E6%9C%89%E5%A4%9A%E5%A4%A7%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">高并发情况等下，Redis+MySQL单点能有多大并发量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">如何保证Redis和MySQL数据缓存一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">消息队列方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85MySQL-binlog%EF%BC%8C%E5%86%8D%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">订阅MySQL binlog，再操作缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%8E-Redis-%E7%BC%93%E5%AD%98%EF%BC%9A%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.</span> <span class="toc-text">本地缓存与 Redis 缓存：性能与应用场景的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">本地缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%88Redis%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">分布式缓存（Redis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">应用场景对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">Redis 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">Redis 实现消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pub-Sub%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用Pub&#x2F;Sub模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%EF%BC%88Publisher%EF%BC%89"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">发布者（Publisher）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%88Subscriber%EF%BC%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">订阅者（Subscriber）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List"><span class="toc-number">3.1.2.</span> <span class="toc-text">使用List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Stream%EF%BC%88Redis-5-0-%E5%90%8E%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用 Stream（Redis 5.0 后）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89-1"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89-1"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">Redis 实现分布式锁详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">Redis 分布式锁实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-SET-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%89%E6%8A%A2%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">基于 SET 命令的争抢锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedLock-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">RedLock 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-Key"><span class="toc-number">4.</span> <span class="toc-text">Redis Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">Redis 大 Key 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7-Key-%E9%97%AE%E9%A2%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">大 Key 问题的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">如何解决大 Key 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%83%ADKey"><span class="toc-number">5.</span> <span class="toc-text">热Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADkey"><span class="toc-number">5.1.</span> <span class="toc-text">什么是热key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey"><span class="toc-number">5.2.</span> <span class="toc-text">如何解决热key</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">三大缓存问题详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">布隆过滤器原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">Redis 应用设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">如何设计秒杀场景处理高并发以及超卖现象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据库层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.1.2.</span> <span class="toc-text">利用分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">7.1.3.</span> <span class="toc-text">利用分布式锁 + 分段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-Redis-%E7%9A%84-INCR%E3%80%81DECR-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">7.1.4.</span> <span class="toc-text">利用 Redis 的 INCR、DECR 的原子性 + 异步队列</span></a></li></ol></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类列表</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/">数据库&缓存</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/MySQL/">MySQL</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/">Redis</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/">数据库优化</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span class="category-list-count">21</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a><span class="category-list-count">20</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/JVM/">JVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E9%9B%86%E5%90%88/">集合</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">5</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/AOP/" style="font-size: 0.6em;">AOP</a> <a href="/tags/BASE/" style="font-size: 0.6em;">BASE</a> <a href="/tags/Bean/" style="font-size: 0.6em;">Bean</a> <a href="/tags/CAP/" style="font-size: 0.6em;">CAP</a> <a href="/tags/Cookie/" style="font-size: 0.6em;">Cookie</a> <a href="/tags/DDD/" style="font-size: 0.6em;">DDD</a> <a href="/tags/DNS/" style="font-size: 0.6em;">DNS</a> <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/I-O/" style="font-size: 0.6em;">I/O</a> <a href="/tags/IoC/" style="font-size: 0.6em;">IoC</a> <a href="/tags/JWT/" style="font-size: 0.6em;">JWT</a> <a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.6em;">Java8新特性</a> <a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.6em;">Java基本概念</a> <a href="/tags/List/" style="font-size: 0.6em;">List</a> <a href="/tags/Map/" style="font-size: 0.8em;">Map</a> <a href="/tags/MyBatis/" style="font-size: 0.6em;">MyBatis</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.6em;">MySQL基础</a> <a href="/tags/Nginx/" style="font-size: 0.6em;">Nginx</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"><i class="fa fa-book"></i> 数据库优化-分库分表</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/"><i class="fa fa-book"></i> 数据库优化-读写分离与冷热分离</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><i class="fa fa-book"></i> 操作系统-进程管理</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 分布式-分布式事务</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/"><i class="fa fa-book"></i> 分布式-服务治理（下）</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
            

        

                </div>
    </div>
</div>

<footer>
    <div id="footer">
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 XIAOYAN 版权所有.</li>
                            <li>本站已运行<span id="kr-since">Loading...</span></li>
                        </div>
                        <div>
                            <li>自豪地使用 <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a> 主题</li>
                            <li>站点由 xiaoyan 用 <i class="fa fa-heart" style="color:#d43f57"></i> 搭建</li>
                        </div>
                        <!-- 额外的追加注入项 -->
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                <div class="box theme-box" id="theme-toggle">
                    <span class="fa fa-adjust"></span>
                </div>
            </div>
            <div id="gotop-box" class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>


    <div id="kr-donate-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseDonateModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-bitcoin"></i>
            </div>
            <div class="kr-modal-title">打赏</div>
            <button class="kr-modal-close" onclick="krCloseDonateModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-donate-message">请我喝一杯冰阔咯~</div>
            <div class="kr-donate-qr" id="kr-donate-qr">
                
            </div>
            <div class="kr-donate-platforms">
                
                    
                        <button class="kr-donate-platform-button" style="color: #1677ff;" title="支付宝" onclick="krDonateModalShowPlatformQR('https://qr.alipay.com/fkx15009k7u0fqrj8auepdf', '#1677ff')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-alipay">
  <path stroke="none" d="M0 0h24v24H0z" fill="none" />
  <path d="M19 3h-14a2 2 0 0 0 -2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2 -2v-14a2 2 0 0 0 -2 -2z" />
  <path d="M7 7h10" />
  <path d="M12 3v7" />
  <path d="M21 17.314c-2.971 -1.923 -15 -8.779 -15 -1.864c0 1.716 1.52 2.55 2.985 2.55c3.512 0 6.814 -5.425 6.814 -8h-6.604" />
</svg>

                        </button>
                    
                
                    
                        <button class="kr-donate-platform-button" style="color: #38ad5a;" title="微信支付" onclick="krDonateModalShowPlatformQR('wxp://f2f0hR4eF9Ypa3tpzjWme9fQDyWW3PIGe3WG5oiIakWLmDs', '#38ad5a')">
                            <i class="fa fa-wechat"></i>
                        </button>
                    
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/donate.min.js"></script>




    <div id="kr-share-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseShareModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-share-alt"></i>
            </div>
            <div class="kr-modal-title">分享</div>
            <button class="kr-modal-close" onclick="krCloseShareModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-share-message">让兄弟萌也来瞅一瞅！</div>
            <div class="kr-share-qr" id="kr-share-qr"></div>
            <div class="kr-share-platforms">
                
                    <button class="kr-share-platform-button" style="color: #e6162d;" title="QQ" onclick="krShareModalOpenPlatform('')">
                        <i class="fa fa-qq"></i>
                    </button>
                
                    <button class="kr-share-platform-button" style="color: #25d366;" title="微信" onclick="krShareModalOpenPlatform('')">
                        <i class="fa fa-weixin"></i>
                    </button>
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/share.min.js"></script>



<!-- 额外的追加注入项 -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<meting-js
  server="netease"
  type="playlist"
  fixed="true"
  order="random"
  id="12613265870">
</meting-js>



        <script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


  <script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>



  <script defer src="/vendors/viewerjs@1.11.6/dist/viewer.min.js"></script>


<script defer src="/js/kr-core.min.js"></script>


  <script defer src="/js/kr-pjax.min.js"></script>


<!-- 额外的追加注入项 -->

  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>



    </body>
</html>