<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Redis-场景理解 | XIAOYAN</title><meta name="author" content="xiaoyan"><meta name="copyright" content="xiaoyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis-场景理解"><meta name="application-name" content="Redis-场景理解"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Redis-场景理解"><meta property="og:url" content="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/index.html"><meta property="og:site_name" content="XIAOYAN"><meta property="og:description" content="Redis 和 MySQL为什么使用RedisRedis 具备高性能和高并发两大特性。 1. 高性能 Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。 2. 高并发 R"><meta property="og:locale" content="zn-CN"><meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png"><meta property="article:author" content="xiaoyan"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png"><meta name="description" content="Redis 和 MySQL为什么使用RedisRedis 具备高性能和高并发两大特性。 1. 高性能 Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。 2. 高并发 R"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: xiaoyan","link":"链接: ","source":"来源: XIAOYAN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XIAOYAN',
  title: 'Redis-场景理解',
  postAI: '',
  pageFillDescription: 'Redis 和 MySQL, 为什么使用Redis, 高并发情况等下Redis+MySQL单点能有多大并发量？, 如何保证Redis和MySQL数据缓存一致性问题, 消息队列方案, 订阅MySQL binlog再操作缓存, 本地缓存与 Redis 缓存：性能与应用场景的对比, 本地缓存, 分布式缓存（Redis）, 应用场景对比, Redis 应用场景, Redis 实现消息队列, 使用Pubx2FSub模式, 发布者（Publisher）, 订阅者（Subscriber）, 使用List, 生产者（Producer）, 消费者（Consumer）, 使用 Stream（Redis 5.0 后）, 生产者（Producer）, 消费者（Consumer）, Redis 实现分布式锁详解, Redis 分布式锁实现原理, 基于 SET 命令的争抢锁机制, RedLock 算法, Redis Key, Redis 大 Key 问题, 大 Key 问题的缺点, 如何解决大 Key 问题, 热Key, 什么是热key, 如何解决热key, 三大缓存问题详解, 缓存雪崩, 缓存击穿, 缓存穿透, 布隆过滤器原理, Redis 应用设计, 如何设计秒杀场景处理高并发以及超卖现象？, 数据库层面, 利用分布式锁, 利用分布式锁 + 分段锁, 利用 Redis 的 INCR、DECR 的原子性 + 异步队列和为什么使用具备高性能和高并发两大特性高性能以其卓越的性能著称主要得益于将数据存储在内存中而则主要依赖磁盘存储内存的读写速度远高于磁盘因此能够显著提升数据访问速度高并发采用单线程模型避免了多线程竞争带来的锁和上下文切换开销这种设计使得在处理高并发请求时表现出色其每秒查询次数轻松突破万此外还可以通过部署切片集群进一步增加整个系统的吞吐量高并发情况等下单点能有多大并发量若命中缓存内存配置单点能够达到若未命中缓存内存配置单点仅能达到左右如何保证和数据缓存一致性问题在分布式系统中缓存和数据库之间的数据一致性是一个常见的问题为了保证数据的一致性通常采用旁路缓存策略即先更新数据库再删除缓存缓存通过牺牲强一致性来实现高性能也就是理论中的模式所以要保持数据的强一致性就不适合使用缓存但是我们可以通过一些缓存方案优化来保证最终一致性消息队列方案为了保证缓存删除操作的可靠性可以引入消息队列由消费者来完成缓存删除操作生产者在写数据时将删除缓存的操作发送到消息队列中消费者消费者从消息队列中获取消息执行缓存删除操作如果应用删除缓存失败可以从消息队列中重新获取消息再次尝试删除缓存这就是消息重试机制删除缓存成功确认消息删除缓存失败重新入队重试删除缓存机制总体可用但可能造成业务代码入侵业务代码入侵是指在业务逻辑代码中嵌入了与业务逻辑无关的代码导致业务代码变得复杂难以维护并且增加了系统的耦合度订阅再操作缓存该策略的第一步是更新数据库当数据库更新成功会将旧的值存入中于是我们可以通过订阅日志拿到具体要删除的记录再执行缓存删除可以使用开源工具如来订阅订阅获取更新操作的记录以下是示例代码本地缓存与缓存性能与应用场景的对比在现代应用开发中缓存是提升系统性能和响应速度的重要手段本地缓存和分布式缓存如是两种常见的缓存策略各自具有独特的优势和适用场景本文将深入探讨本地缓存和缓存的性能特点并通过对比帮助读者理解它们在不同场景下的应用本地缓存本地缓存是指将数据存储在本地程序或服务器上通常使用内存作为存储介质本地缓存通过利用内存的高速读写特性显著提升数据访问速度优势访问速度快由于数据存储在本地内存中访问速度极快适合需要高频访问的数据减轻网络压力本地缓存减少了对外部数据源的依赖从而减轻了网络带宽的压力不足可扩展性有限本地缓存通常局限于单个服务器或进程难以应对大规模分布式系统的需求分布式缓存分布式缓存是指将数据存储在多个分布式节点上通过协同工作提升高性能的数据访问服务是一种常见的分布式缓存解决方案通常采用集群的方式进行部署通过多台服务器分担数据压力优势可扩展性强可以根据业务需求动态增加或减少集群节点灵活应对数据量的变化数据高一致性采用主从同步复制机制确保数据在多个节点之间保持一致性易于维护分布式缓存通常采用自动化管理方式降低维护成本提高运维效率不足访问相对较慢相比于本地缓存分布式缓存需要通过网络访问数据访问速度相对较慢网络开销大分布式缓存依赖网络通信网络延迟和带宽限制可能影响性能应用场景对比本地缓存适用场景高频访问数据适合存储频繁访问的热数据如用户会话配置信息等单机应用适用于单机或单进程的应用场景数据量较小且不需要分布式扩展缓存适用场景大规模分布式系统适合需要处理海量数据和高并发请求的分布式系统数据一致性要求高适用于需要确保数据一致性的场景如电商平台的商品库存管理动态扩展需求适用于需要根据业务需求动态调整缓存规模的场景应用场景是一种基于内存的高性能数据库凭借其快速的读写速度和丰富的数据结构广泛应用于各种场景中本文将详细介绍在不同应用场景中的具体用途并通过实例帮助读者更好地理解其优势缓存缓存是最常见的应用场景之一通过将热门数据存储在内存中可以显著提高系统的访问速度减轻后端数据库的压力计数器的单线程模式和操作的原子性使其非常适合用于实现计数器和统计功能常见的应用包括页面访问量统计用户行为统计等常用数据结构排行榜中的有序集合能够实现对数据的自动排序非常适合用于排行榜热门文章等需要排序的应用场景分布式锁在分布式系统中为了避免多个进程同时操作同一资源可以使用实现分布式锁常见的应用包括资源访问控制任务调度等消息队列的发布和订阅功能使其可以作为一个轻量级的消息队列系统常见的应用包括异步任务处理事件通知等常用数据结构实现消息队列使用模式的模式是一种基于发布者订阅者的模式任何客户端都可以订阅一个或多个频道发布者可以向特定频道发布消息所有订阅了该频道的订阅者都会收到消息发布者和订阅者完全解耦并且支持模式匹配但是这种方式并不支持持久化也就是说当发布者将消息发布后若此时无订阅者消息就会丢失示例发布者连接到服务器发布消息到频道关闭连接订阅者连接到服务器订阅频道关闭连接使用使用实现消息队列是一种简单且高效的方式生产者使用命令将消息添加到的队尾消费者使用或命令阻塞地从队首取出消息进行消费先进先出这种方式可以结合的过期时间特性实现消息的通过事务可以保证操作的原子性但需要客户端自己实现消息确认消息重试机制生产者连接到服务器将消息添加到关闭连接消费者连接到服务器阻塞地从中取出消息关闭连接使用后是引入的一种新的数据结构专门用于实现消息队列提供了更强大的功能如消息持久化消费者组消息确认等生产者连接到服务器创建消息将消息添加到关闭连接消费者连接到服务器创建消费者组消费消息确认消息关闭连接实现分布式锁详解在分布式系统中为了避免多个进程同时操作同一资源分布式锁是一种常用的解决方案提供了多种实现分布式锁的方式本文将详细介绍基于命令的争抢锁机制和算法并通过代码示例帮助读者更好地理解其应用分布式锁实现原理分布式锁是分布式并发状态下的一种机制用于控制一个资源在一个时间内只有一个应用能对其进行使用本身可以被多个客户端进行访问就像一个共享存储可以用来保存分布式锁的命令参数表示只有在键不存在时才设置具有互斥性非常适合用来构建分布式锁若存在证明被加过锁了所以此时可以认为加锁失败若不存在证明未被加锁可以认为加锁成功基于节点实现分布式锁对于加锁条件我们需要满足三个条件原子性加锁操作涉及多个操作读取锁变量检查锁变量设置锁变量需要保证这些操作的原子性过期时间锁变量需要设置过期时间避免客户端获得锁后挂掉锁一直不释放造成死锁唯一性锁变量的值需要能区分是哪个客户端设置的锁避免在释放锁时造成误释放操作基于命令的争抢锁机制提供了命令的扩展参数可以用于实现分布式锁通过命令客户端可以尝试获取锁其中表示只有当键值不存在时才设置指定锁的过期时间毫秒如果设置成功则认为当前客户端获得了锁当客户端完成操作后需要删除锁这里涉及两个以上的操作判断锁是否属于自己删除锁因此可以使用脚本来保证命令的原子性示例代码锁的过期时间单位毫秒连接到服务器尝试获取锁执行需要加锁的操作释放锁关闭连接注意事项锁的过期时间设置合理的锁过期时间避免锁长时间占用资源锁的唯一性确保锁的值是唯一的通常使用或其他唯一标识符脚本使用脚本保证释放锁操作的原子性算法算法是官方推荐的分布式锁实现方式适用于需要高可用性和容错性的场景算法通过在多个独立的实例上获取锁并确保大多数实例超过半数成功获取锁来实现分布式锁算法步骤获取当前时间记录当前时间戳尝试获取锁在每个实例上尝试获取锁使用相同的键和随机值计算获取锁的时间计算从开始获取锁到所有实例返回结果的时间判断锁是否获取成功如果大多数实例超过半数成功获取锁并且获取锁的时间小于锁的有效期则认为锁获取成功释放锁在所有实例上释放锁代码示例锁的过期时间单位毫秒大多数实例的数量执行需要加锁的操作释放锁注意事项多数原则确保大多数实例超过半数成功获取锁时间同步各个实例的时间需要同步避免时间差异导致锁失效故障处理处理实例故障的情况确保锁的可靠性大问题在中大问题指的是一个键对应的值过大导致处理起来缓慢内存不足影响主从同步延迟等问题大地多大算大这是没有标准的通常认为字符串类型的对应的值空间占用超过了或者集合中对应的元素个数超过了我们就认为该是大大问题的缺点内存占用较高大会占用大量的内存导致可用内存减少是一个内存数据库内存是其主要资源如果内存被大占用过多可能会导致内存不足触发内存淘汰策略影响其他键的访问降低性能当对大进行处理时会花费更多的时间导致整体性能下降甚至会阻塞其他客户端的请求大的读取写入删除等操作都会消耗更多的资源影响的响应速度网络拥塞大在网络传输时会占用大量带宽可能导致网络拥塞特别是在高并发场景下大量请求传输大会导致网络资源被耗尽影响其他请求的传输假设有一个大对应的值是一个的图片数据如果有个请求同时传输这个大会占用的网络带宽导致网络拥塞主从复制延迟大在主从复制时需要传输大量数据可能导致主从复制延迟影响数据一致性特别是在主从节点之间网络带宽有限的情况下大的传输会占用大量带宽导致复制延迟数据倾斜一个大会造成单个切片节点使用了很大一部分内存导致内存使用率远超其他切片节点这种数据倾斜会导致集群中某些节点负载过重影响整体性能如何解决大问题大拆分将数万成员的大拆分为更小的分散的可以有效减少单个键的内存占用提高的处理效率内存清理将大转移到其他存储介质如文件系统数据库等然后释放中的避免占用内存空间要使用异步删除内存阈值监控持续监控的内存使用率当发现内存用量到达阈值时或内存使用率突然大幅提升时对内存进行相应的处理比如删除不需要的定期删除定时对过期的进行删除避免持续堆积而产生大热什么是热热是指那些被频繁访问的键其请求频率远高于其他键热问题会导致的性能瓶颈影响整体系统的响应速度请求集中在特定假设有的每秒查询次数而某个被请求的频率达到带宽使用率集中在特定的某个的传输数据量占用了大量网络带宽使用时间集中在特定的某个的处理占用了大量时间热的影响性能瓶颈热会导致的性能瓶颈影响整体系统的响应速度资源浪费热会占用大量内存和网络资源导致其他请求的资源不足如何解决热负载均衡由于切片集群中的迁移粒度问题无法将热迁移到其他节点分散单点压力此时可以将热复制多几份重新命名后装配到其他节点并将热的请求分散到这些分散的节点中以此降低单点压力缓存预热在系统启动时提前加载热的数据到缓存中避免系统启动后瞬间的高并发请求导致热问题三大缓存问题详解在分布式系统中缓存是提升系统性能的重要手段然而缓存也会带来一些问题如缓存雪崩缓存击穿和缓存穿透缓存雪崩缓存雪崩是指在高并发场景下同一时间内大量过期或者节点故障导致大量的数据请求冲向数据库服务器数据库可能会因无法承受大量数据请求而宕机对于大量同时过期造成的缓存雪崩我们可以设置以下方案解决均匀过期时间对于同一时间大量过期而产生的缓存雪崩可以设置随机的过期时间避免大量在同一时间失效通过在基础过期时间上增加一个随机值可以有效分散的过期时间避免集中失效不设置过期时间若业务场景可能长期需要该那么可以不设置过期时间待业务活动过期后手动将删除这种方式适用于那些长期有效的数据避免频繁的缓存重建互斥锁当业务线程发现该不在缓存中就设置一个互斥锁保证同一时间只有一个线程在处理缓存避免在失效期间大量线程同一时间读数据库写缓存通过互斥锁可以有效控制缓存重建的并发度减少数据库压力缓存击穿缓存击穿是指在高并发场景下某个热点在缓存中过期导致大量请求直接访问数据库导致数据库压力骤增甚至宕机对于缓存击穿我们也可以使用应对缓存雪崩中采取的两个方案互斥锁使用互斥锁保证同一时间只有一个线程访问数据库其他线程等待缓存更新通过互斥锁可以有效控制缓存重建的并发度减少数据库压力热点数据永不过期对于热点数据可以设置永不过期或者设置较长的过期时间这种方式适用于那些长期有效的数据避免频繁的缓存重建后台异步更新保持热点持续在线由后台异步更新缓存或者在即将过期时通知后台线程重新设置过期时间这种方式可以避免缓存过期瞬间的大量请求冲击数据库缓存穿透缓存穿透是指在高并发场景下请求的数据在缓存和数据库中都不存在导致每次请求都直接访问数据库导致数据库压力骤增甚至宕机对于缓存穿透我们可以采取以下方案限制非法请求当有恶意的请求故意查询一条不存在的数据大量的恶意请求也会导致缓存穿透问题由此我们需要判断请求参数是否合理过滤掉非法的数据请求通过参数校验和请求过滤可以有效减少非法请求对数据库的冲击缓存空值或默认值当我们发现环境中存在缓存穿透现象时可以为不存在的数据设置为空值或默认值当缓存中存在有值就不需要向数据库发起大量的请求了通过缓存空值或默认值可以避免大量请求直接访问数据库布隆过滤器我们可以在写入数据库时使用布隆过滤器做标记然后再请求到来时先判断缓存中是否存在该数据若不存在则通过布隆过滤器快速判断要请求的数据是否存在若判断存在则数据可能存在可以进一步向数据库查询若判断不存在则一定不存在直接返回通过布隆过滤器可以快速过滤掉不存在的数据请求减少数据库压力本身也实现了布隆过滤器布隆过滤器原理布隆过滤器是一种空间效率很高的概率型数据结构用于判断一个元素是否在一个集合中它由初始值都为的位图数组和个哈希函数两部分组成布隆过滤器通过哈希计算来判断数据是否存在具有高效的查询速度和较低的空间占用但存在一定的误判率当我们在写入数据库的时候会在布隆过滤器中设置标记证明该数据在数据库中存在这样下次查询的时候直接先通过布隆过滤器就能判断出该数据在数据库中是否存在而不需要进一步查询数据库布隆过滤器会通过个操作完成标记哈希计算使用个哈希函数对数据进行哈希计算得到个哈希值取模操作将个哈希值分别对位图数组的长度取模得到每个哈希值在位图数组中相对应的位置设置标记将每个哈希值在位图数组中相应的位置设置为举个例子假设有一个长度为的位图数组哈希函数有个的布隆过滤器将数据写入数据库后会对数据进行哈希计算得到个哈希值再将得到的哈希值取模也就得到了一堆数字结果对应布隆过滤器中位图数组的位置将这些位置设为下次要判断是否存在于数据库中时只需要对进行哈希计算查看对应位图数组上相应的位置是不是全都为如果全都是则认为数据可能存在于数据库中可以继续下一步查询否则认为数据一定不存在布隆过滤器通过哈希计算来判断数据是否存在必然存在哈希冲突可能会有两个不同的数据计算出同样的哈希值造成误判具体来说误判情况布隆过滤器认为数据存在但实际上数据可能不存在这种情况称为假阳性正确情况布隆过滤器认为数据不存在则数据一定不存在这种情况称为真阴性所以布隆过滤器认为该数据存在则其可能存在若认为数据不存在则一定不存在应用设计如何设计秒杀场景处理高并发以及超卖现象秒杀场景是一种典型的高并发场景通常涉及大量用户在短时间内对有限数量的商品进行抢购为了应对高并发和避免超卖现象需要从数据库层面分布式锁分段锁以及和异步队列等多个方面进行设计和优化数据库层面查询商品库存时加排他锁在查询商品库存时可以使用数据库的排他锁来保证数据的一致性在事务中线程通过该语句给为的数据行上了一个行级的排他锁此时在事务期间其他线程对该行的和操作都将被阻塞直到事务提交或发生回滚释放锁更新数据库减库存时进行库存限制在更新数据库减库存时可以通过条件判断来避免超卖现象这种通过数据库加锁来解决的方案性能不是很好在高并发的情况下可能会因为获取不到数据库的连接或超时等待报错利用分布式锁分布式锁可以保证在同一时间内只有一个客户端能获取到锁获得锁的线程才能进行接下来的业务逻辑而其他客户端获取不到锁只能无限循环尝试获取锁可以使用的命令来实现分布式锁在高并发状态下分布式锁只能进行串行化处理效率很低比如大量用户对同一个热门商品下单此时只能一个个处理下单操作效率很慢利用分布式锁分段锁把数据分成很多段每一段加上一个单独的锁细粒度化使得线程在对一段数据进行修改时其他线程可以继续对剩下部分进行加锁操作假设商品库存分为多个段每个段使用独立的锁通过分段锁可以提高并发处理能力减少锁的竞争提升系统的吞吐量利用的的原子性异步队列系统初始化时加载库存到在系统初始化时将商品的库存数量加载到中接收到秒杀请求时预减库存接收到秒杀请求时在中进行预减库存利用的原子性当的库存不足时直接返回秒杀失败否则继续进行第三步将请求放入异步队列将请求放入异步队列中返回正在排队中服务端异步队列请求出队服务端异步队列请求出队可以出队的情况根据业务来判定比如判断是否已秒杀过防重复秒杀出队的请求可以生成秒杀订单减少数据库存处理秒杀请求生成订单减少库存客户端轮询查看秒杀结果用户在客户端申请完秒杀后进行轮询查看是否秒杀成功秒杀成功则进入秒杀订单详情否则秒杀失败由于使用了异步队列写入数据库可能存在数据不一致问题其次引用多个组件复杂度比较高',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 11:40:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/images/star.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XIAOYAN</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 1.05rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 1.05rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 1.05rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 1.05rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 1.05rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.05rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 1.05rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 1.05rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 1.05rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 1.05rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 1.05rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/" itemprop="url">数据库&amp;缓存</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/" itemprop="url">Redis</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Redis-场景理解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-27T00:54:37.000Z" title="发表于 2024-09-27 08:54:37">2024-09-27</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.433Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为桂林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>桂林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/"><header><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/" itemprop="url">数据库&amp;缓存</a><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/" itemprop="url">Redis</a><h1 id="CrawlerTitle" itemprop="name headline">Redis-场景理解</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">xiaoyan</span><time itemprop="dateCreated datePublished" datetime="2024-09-27T00:54:37.000Z" title="发表于 2024-09-27 08:54:37">2024-09-27</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.433Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></header><h1 id="Redis-和-MySQL"><a href="#Redis-和-MySQL" class="headerlink" title="Redis 和 MySQL"></a>Redis 和 MySQL</h1><h2 id="为什么使用Redis"><a href="#为什么使用Redis" class="headerlink" title="为什么使用Redis"></a>为什么使用Redis</h2><p>Redis 具备<strong>高性能</strong>和<strong>高并发</strong>两大特性。</p>
<p><strong>1. 高性能</strong></p>
<p>Redis 以其卓越的性能著称，主要得益于Redis 将数据存储在内存中，而 MySQL 则主要依赖磁盘存储。内存的读写速度远高于磁盘，因此 Redis 能够显著提升数据访问速度。</p>
<p><strong>2. 高并发</strong></p>
<p>Redis 采用单线程模型，避免了多线程竞争带来的锁和上下文切换开销。这种设计使得 Redis 在处理高并发请求时表现出色，其 QPS（每秒查询次数）轻松突破 10 万。此外，Redis 还可以通过部署 Redis 切片集群进一步增加整个系统的吞吐量。</p>
<h2 id="高并发情况等下，Redis-MySQL单点能有多大并发量？"><a href="#高并发情况等下，Redis-MySQL单点能有多大并发量？" class="headerlink" title="高并发情况等下，Redis+MySQL单点能有多大并发量？"></a>高并发情况等下，Redis+MySQL单点能有多大并发量？</h2><ul>
<li>若命中Redis缓存，4C8G内存配置 ，单点Redis能够达到10wQPS。</li>
<li>若未命中Redis缓存，4C8G内存配置，单点MySQL仅能达到5k左右QPS。</li>
</ul>
<h2 id="如何保证Redis和MySQL数据缓存一致性问题"><a href="#如何保证Redis和MySQL数据缓存一致性问题" class="headerlink" title="如何保证Redis和MySQL数据缓存一致性问题"></a>如何保证Redis和MySQL数据缓存一致性问题</h2><p>在分布式系统中，缓存和数据库之间的数据一致性是一个常见的问题。为了保证数据的一致性，通常采用旁路缓存策略，即先更新数据库，再删除缓存。</p>
<p>缓存通过牺牲强一致性来实现高性能，也就是<strong>CAP理论</strong>中的<strong>AP</strong>模式。所以，要保持数据的强一致性，就不适合使用缓存。但是，我们可以通过一些缓存方案优化来保证<strong>最终一致性</strong>。</p>
<h3 id="消息队列方案"><a href="#消息队列方案" class="headerlink" title="消息队列方案"></a>消息队列方案</h3><p>为了保证缓存删除操作的可靠性，可以引入消息队列，由消费者来完成缓存删除操作。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1720223533280-96461154-bd99-418c-bc90-52a90bc70cac.webp" alt="旁路缓存机制(图片来源小林coding)" style="zoom:80%;">

<ol>
<li><strong>生产者：</strong>在写数据时，将删除缓存的操作发送到消息队列中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeData</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    mysql.update(key, value);</span><br><span class="line">    messageQueue.send(<span class="string">&quot;delete_cache&quot;</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>消费者：</strong>消费者从消息队列中获取消息，执行缓存删除操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.receive(<span class="string">&quot;delete_cache&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey();</span><br><span class="line">        redis.del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果应用删除缓存失败，可以从消息队列中重新获取消息，再次尝试删除缓存。这就是<strong>消息重试机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumeMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.receive(<span class="string">&quot;delete_cache&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> message.getKey();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redis.del(key);</span><br><span class="line">            messageQueue.ack(message); <span class="comment">// 删除缓存成功，确认消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            messageQueue.nack(message); <span class="comment">// 删除缓存失败，重新入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重试删除缓存机制总体可用，但可能造成<strong>业务代码入侵（</strong>业务代码入侵（Business Code Invasion）是指在业务逻辑代码中嵌入了与业务逻辑无关的代码，导致业务代码变得复杂、难以维护，并且增加了系统的耦合度。）。</p>
<h3 id="订阅MySQL-binlog，再操作缓存"><a href="#订阅MySQL-binlog，再操作缓存" class="headerlink" title="订阅MySQL binlog，再操作缓存"></a>订阅MySQL binlog，再操作缓存</h3><p>该策略的第一步是更新数据库，当数据库更新成功，会将旧的值存入 binlog 中。于是我们可以通过订阅 binlog 日志，拿到具体要删除的记录，再执行缓存删除。</p>
<p>可以使用开源工具如 Canal 来订阅 MySQL binlog。订阅 MySQL binlog，获取更新操作的记录，以下是示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinlogSubscriber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CanalConnector</span> <span class="variable">connector</span> <span class="operator">=</span> CanalConnectors.newSingleConnector(<span class="string">&quot;localhost&quot;</span>, <span class="number">11111</span>, <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        connector.connect();</span><br><span class="line">        connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> connector.getWithoutAck(<span class="number">100</span>);</span><br><span class="line">            <span class="type">long</span> <span class="variable">batchId</span> <span class="operator">=</span> message.getId();</span><br><span class="line">            <span class="keyword">if</span> (batchId == -<span class="number">1</span> || message.getEntries().isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry entry : message.getEntries()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getEntryType() == EntryType.ROWDATA) &#123;</span><br><span class="line">                    <span class="type">RowChange</span> <span class="variable">rowChange</span> <span class="operator">=</span> RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">                    <span class="keyword">for</span> (RowData rowData : rowChange.getRowDatasList()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rowChange.getEventType() == EventType.UPDATE) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> rowData.getAfterColumns(<span class="number">0</span>).getValue();</span><br><span class="line">                            redis.del(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            connector.ack(batchId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="本地缓存与-Redis-缓存：性能与应用场景的对比"><a href="#本地缓存与-Redis-缓存：性能与应用场景的对比" class="headerlink" title="本地缓存与 Redis 缓存：性能与应用场景的对比"></a>本地缓存与 Redis 缓存：性能与应用场景的对比</h1><p>在现代应用开发中，缓存是提升系统性能和响应速度的重要手段。本地缓存和分布式缓存（如 Redis）是两种常见的缓存策略，各自具有独特的优势和适用场景。本文将深入探讨本地缓存和 Redis 缓存的性能特点，并通过对比帮助读者理解它们在不同场景下的应用。</p>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><p>本地缓存是指将数据存储在本地程序或服务器上，通常使用内存作为存储介质。本地缓存通过利用内存的高速读写特性，显著提升数据访问速度。</p>
<ol>
<li>优势</li>
</ol>
<ul>
<li><strong>访问速度快</strong>：由于数据存储在本地内存中，访问速度极快，适合需要高频访问的数据。</li>
<li><strong>减轻网络压力</strong>：本地缓存减少了对外部数据源的依赖，从而减轻了网络带宽的压力。</li>
</ul>
<ol start="2">
<li>不足</li>
</ol>
<ul>
<li><strong>可扩展性有限</strong>：本地缓存通常局限于单个服务器或进程，难以应对大规模分布式系统的需求。</li>
</ul>
<h2 id="分布式缓存（Redis）"><a href="#分布式缓存（Redis）" class="headerlink" title="分布式缓存（Redis）"></a>分布式缓存（Redis）</h2><p>分布式缓存是指将数据存储在多个分布式节点上，通过协同工作提升高性能的数据访问服务。Redis 是一种常见的分布式缓存解决方案，通常采用集群的方式进行部署，通过多台服务器分担数据压力。</p>
<ol>
<li>优势</li>
</ol>
<ul>
<li><strong>可扩展性强</strong>：可以根据业务需求动态增加或减少集群节点，灵活应对数据量的变化。</li>
<li><strong>数据高一致性</strong>：Redis 采用主从同步复制机制，确保数据在多个节点之间保持一致性。</li>
<li><strong>易于维护</strong>：分布式缓存通常采用自动化管理方式，降低维护成本，提高运维效率。</li>
</ul>
<ol start="2">
<li>不足</li>
</ol>
<ul>
<li><strong>访问相对较慢</strong>：相比于本地缓存，分布式缓存需要通过网络访问数据，访问速度相对较慢。</li>
<li><strong>网络开销大</strong>：分布式缓存依赖网络通信，网络延迟和带宽限制可能影响性能。</li>
</ul>
<h2 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h2><p><strong>本地缓存适用场景</strong></p>
<ul>
<li><strong>高频访问数据</strong>：适合存储频繁访问的热数据，如用户会话、配置信息等。</li>
<li><strong>单机应用</strong>：适用于单机或单进程的应用场景，数据量较小且不需要分布式扩展。</li>
</ul>
<p><strong>Redis 缓存适用场景</strong></p>
<ul>
<li><strong>大规模分布式系统</strong>：适合需要处理海量数据和高并发请求的分布式系统。</li>
<li><strong>数据一致性要求高</strong>：适用于需要确保数据一致性的场景，如电商平台的商品库存管理。</li>
<li><strong>动态扩展需求</strong>：适用于需要根据业务需求动态调整缓存规模的场景。</li>
</ul>
<h1 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h1><p>Redis 是一种基于内存的高性能数据库，凭借其快速的读写速度和丰富的数据结构，广泛应用于各种场景中。本文将详细介绍 Redis 在不同应用场景中的具体用途，并通过实例帮助读者更好地理解其优势。</p>
<ul>
<li><strong>缓存：</strong>缓存是 Redis 最常见的应用场景之一。通过将热门数据存储在内存中，Redis 可以显著提高系统的访问速度，减轻后端数据库的压力。</li>
<li><strong>计数器：</strong>Redis 的单线程模式和操作的原子性使其非常适合用于实现计数器和统计功能。常见的应用包括页面访问量统计、用户行为统计等。（常用数据结构String、HyperLogLog）</li>
<li><strong>排行榜：</strong>Redis 中的有序集合（Sorted Set，Zset）能够实现对数据的自动排序，非常适合用于排行榜、热门文章等需要排序的应用场景。</li>
<li><strong>分布式锁：</strong>在分布式系统中，为了避免多个进程同时操作同一资源，可以使用 Redis 实现分布式锁。常见的应用包括资源访问控制、任务调度等。</li>
<li><strong>消息队列：</strong>Redis 的发布和订阅功能（Pub&#x2F;Sub）使其可以作为一个轻量级的消息队列系统。常见的应用包括异步任务处理、事件通知等。（常用数据结构List、Stream）</li>
</ul>
<h2 id="Redis-实现消息队列"><a href="#Redis-实现消息队列" class="headerlink" title="Redis 实现消息队列"></a>Redis 实现消息队列</h2><h3 id="使用Pub-Sub模式"><a href="#使用Pub-Sub模式" class="headerlink" title="使用Pub&#x2F;Sub模式"></a>使用Pub&#x2F;Sub模式</h3><p>Redis 的 Pub&#x2F;Sub 模式是一种基于发布者&#x2F;订阅者的模式。任何客户端都可以订阅一个或多个频道，发布者可以向特定频道发布消息，所有订阅了该频道的订阅者都会收到消息。发布者和订阅者完全解耦，并且支持模式匹配。但是这种方式并不支持持久化，也就是说当发布者将消息发布后，若此时无订阅者，消息就会丢失。</p>
<p>示例：</p>
<h4 id="发布者（Publisher）"><a href="#发布者（Publisher）" class="headerlink" title="发布者（Publisher）"></a>发布者（Publisher）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息到频道 &quot;news&quot;</span></span><br><span class="line">        jedis.publish(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;Breaking News: Redis Pub/Sub Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="订阅者（Subscriber）"><a href="#订阅者（Subscriber）" class="headerlink" title="订阅者（Subscriber）"></a>订阅者（Subscriber）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPubSub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSubscriber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅频道 &quot;news&quot;</span></span><br><span class="line">        jedis.subscribe(<span class="keyword">new</span> <span class="title class_">JedisPubSub</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String channel, String message)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Received: &quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;news&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用List"><a href="#使用List" class="headerlink" title="使用List"></a>使用List</h3><p>使用 List 实现消息队列是一种简单且高效的方式。生产者使用 <code>LPUSH</code> 命令将消息添加到 List 的队尾，消费者使用 <code>BLPOP</code> 或 <code>BRPOP</code> 命令阻塞地从队首取出消息进行消费（先进先出，FIFO）。这种方式可以结合Redis的过期时间特性实现消息的TTL，通过Redis事务可以保证操作的原子性，但需要客户端自己实现消息确认、消息重试机制。</p>
<h4 id="生产者（Producer）"><a href="#生产者（Producer）" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息添加到 List &quot;messageQueue&quot;</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;messageQueue&quot;</span>, <span class="string">&quot;Message 1&quot;</span>);</span><br><span class="line">        jedis.lpush(<span class="string">&quot;messageQueue&quot;</span>, <span class="string">&quot;Message 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者（Consumer）"><a href="#消费者（Consumer）" class="headerlink" title="消费者（Consumer）"></a>消费者（Consumer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞地从 List &quot;messageQueue&quot; 中取出消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> jedis.brpop(<span class="number">0</span>, <span class="string">&quot;messageQueue&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="comment">// jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Stream（Redis-5-0-后）"><a href="#使用-Stream（Redis-5-0-后）" class="headerlink" title="使用 Stream（Redis 5.0 后）"></a>使用 Stream（Redis 5.0 后）</h3><p>Redis Stream 是 Redis 5.0 引入的一种新的数据结构，专门用于实现消息队列。Stream 提供了更强大的功能，如消息持久化、消费者组、消息确认等。</p>
<h4 id="生产者（Producer）-1"><a href="#生产者（Producer）-1" class="headerlink" title="生产者（Producer）"></a>生产者（Producer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStreamProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消息</span></span><br><span class="line">        Map&lt;String, String&gt; message = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        message.put(<span class="string">&quot;event&quot;</span>, <span class="string">&quot;New Order&quot;</span>);</span><br><span class="line">        message.put(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息添加到 Stream &quot;orderStream&quot;</span></span><br><span class="line">        jedis.xadd(<span class="string">&quot;orderStream&quot;</span>, StreamEntryID.NEW_ENTRY, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费者（Consumer）-1"><a href="#消费者（Consumer）-1" class="headerlink" title="消费者（Consumer）"></a>消费者（Consumer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntry;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamEntryID;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamGroup;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamInfo;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.StreamPendingEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStreamConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者组</span></span><br><span class="line">        jedis.xgroupCreate(<span class="string">&quot;orderStream&quot;</span>, <span class="string">&quot;orderGroup&quot;</span>, <span class="keyword">new</span> <span class="title class_">StreamEntryID</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            List&lt;StreamEntry&gt; messages = jedis.xreadGroup(<span class="string">&quot;orderGroup&quot;</span>, <span class="string">&quot;consumer1&quot;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="string">&quot;orderStream&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (StreamEntry message : messages) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumed: &quot;</span> + message.getFields());</span><br><span class="line">                <span class="comment">// 确认消息</span></span><br><span class="line">                jedis.xack(<span class="string">&quot;orderStream&quot;</span>, <span class="string">&quot;orderGroup&quot;</span>, message.getID());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        <span class="comment">// jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis-实现分布式锁详解"><a href="#Redis-实现分布式锁详解" class="headerlink" title="Redis 实现分布式锁详解"></a>Redis 实现分布式锁详解</h2><p>在分布式系统中，为了避免多个进程同时操作同一资源，分布式锁是一种常用的解决方案。Redis 提供了多种实现分布式锁的方式，本文将详细介绍基于 <code>SET</code> 命令的争抢锁机制和 RedLock 算法，并通过代码示例帮助读者更好地理解其应用。</p>
<h3 id="Redis-分布式锁实现原理"><a href="#Redis-分布式锁实现原理" class="headerlink" title="Redis 分布式锁实现原理"></a>Redis 分布式锁实现原理</h3><p>分布式锁是分布式并发状态下的一种机制，用于控制一个资源在一个时间内，只有一个应用能对其进行使用。</p>
<p>Redis本身可以被多个客户端进行访问，就像一个共享存储，可以用来保存分布式锁。Redis 的 <code>SET</code> 命令参数 <code>NX</code> 表示只有在键不存在时才设置，具有互斥性，非常适合用来构建分布式锁：</p>
<ul>
<li><strong>若key存在</strong>，证明被加过锁了，所以此时可以认为加锁失败。</li>
<li><strong>若key不存在</strong>，证明未被加锁，可以认为加锁成功。</li>
</ul>
<p>基于Redis节点实现分布式锁，对于加锁条件，我们需要满足三个条件：</p>
<ul>
<li><strong>原子性</strong>：加锁操作涉及多个操作（读取锁变量、检查锁变量、设置锁变量），需要保证这些操作的原子性。</li>
<li><strong>过期时间</strong>：锁变量需要设置过期时间，避免客户端获得锁后挂掉，锁一直不释放造成死锁。</li>
<li><strong>唯一性</strong>：锁变量的值需要能区分是哪个客户端设置的锁，避免在释放锁时造成误释放操作。</li>
</ul>
<h3 id="基于-SET-命令的争抢锁机制"><a href="#基于-SET-命令的争抢锁机制" class="headerlink" title="基于 SET 命令的争抢锁机制"></a>基于 <code>SET</code> 命令的争抢锁机制</h3><p>Redis 提供了 <code>SET</code> 命令的扩展参数，可以用于实现分布式锁。通过 <code>SET resource_name lock_value NX PX milliseconds</code> 命令，客户端可以尝试获取锁。其中：</p>
<ul>
<li><code>NX</code>：表示只有当键值不存在时才设置。</li>
<li><code>PX milliseconds</code>：指定锁的过期时间（毫秒）。</li>
</ul>
<p>如果设置成功，则认为当前客户端获得了锁。当客户端完成操作后，需要删除锁，这里涉及两个以上的操作（判断锁是否属于自己、删除锁），因此可以使用 Lua 脚本来保证 Redis 命令的原子性。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;my_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_VALUE</span> <span class="operator">=</span> <span class="string">&quot;lock_value&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 锁的过期时间，单位：毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到 Redis 服务器</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, LOCK_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, LOCK_EXPIRE_TIME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired successfully.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行需要加锁的操作</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            releaseLock(jedis);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        jedis.eval(script, <span class="number">1</span>, LOCK_KEY, LOCK_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>锁的过期时间</strong>：设置合理的锁过期时间，避免锁长时间占用资源。</li>
<li><strong>锁的唯一性</strong>：确保锁的值是唯一的，通常使用 UUID 或其他唯一标识符。</li>
<li><strong>Lua 脚本</strong>：使用 Lua 脚本保证释放锁操作的原子性。</li>
</ul>
<h3 id="RedLock-算法"><a href="#RedLock-算法" class="headerlink" title="RedLock 算法"></a>RedLock 算法</h3><p>RedLock 算法是 Redis 官方推荐的分布式锁实现方式，适用于需要高可用性和容错性的场景。RedLock 算法通过在多个独立的 Redis 实例上获取锁，并确保大多数实例（超过半数）成功获取锁，来实现分布式锁。</p>
<p>算法步骤</p>
<ol>
<li><strong>获取当前时间</strong>：记录当前时间戳。</li>
<li><strong>尝试获取锁</strong>：在每个 Redis 实例上尝试获取锁，使用相同的键和随机值。</li>
<li><strong>计算获取锁的时间</strong>：计算从开始获取锁到所有实例返回结果的时间。</li>
<li><strong>判断锁是否获取成功</strong>：如果大多数实例（超过半数）成功获取锁，并且获取锁的时间小于锁的有效期，则认为锁获取成功。</li>
<li><strong>释放锁</strong>：在所有实例上释放锁。</li>
</ol>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY</span> <span class="operator">=</span> <span class="string">&quot;my_lock&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_VALUE</span> <span class="operator">=</span> <span class="string">&quot;lock_value&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOCK_EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">// 锁的过期时间，单位：毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUORUM</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 大多数实例的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JedisPool&gt; jedisPools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedLock</span><span class="params">(List&lt;String&gt; redisServers)</span> &#123;</span><br><span class="line">        jedisPools = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String server : redisServers) &#123;</span><br><span class="line">            String[] parts = server.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">            <span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config, parts[<span class="number">0</span>], Integer.parseInt(parts[<span class="number">1</span>]));</span><br><span class="line">            jedisPools.add(pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">successCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (JedisPool pool : jedisPools) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(LOCK_KEY, LOCK_VALUE, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, LOCK_EXPIRE_TIME);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">                    successCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">return</span> successCount &gt;= QUORUM &amp;&amp; elapsedTime &lt; LOCK_EXPIRE_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (JedisPool pool : jedisPools) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource()) &#123;</span><br><span class="line">                jedis.eval(script, <span class="number">1</span>, LOCK_KEY, LOCK_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; redisServers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6379&quot;</span>);</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6380&quot;</span>);</span><br><span class="line">        redisServers.add(<span class="string">&quot;localhost:6381&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedLock</span>(redisServers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (redLock.acquireLock()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lock acquired successfully.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行需要加锁的操作</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            redLock.releaseLock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed to acquire lock.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li><strong>多数原则</strong>：确保大多数实例（超过半数）成功获取锁。</li>
<li><strong>时间同步</strong>：各个 Redis 实例的时间需要同步，避免时间差异导致锁失效。</li>
<li><strong>故障处理</strong>：处理 Redis 实例故障的情况，确保锁的可靠性。</li>
</ul>
<h1 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis Key"></a>Redis Key</h1><h2 id="Redis-大-Key-问题"><a href="#Redis-大-Key-问题" class="headerlink" title="Redis 大 Key 问题"></a>Redis 大 Key 问题</h2><p>在 Redis 中，大 Key 问题指的是一个键（Key）对应的值（Value）过大，导致 Redis 处理起来缓慢、内存不足、影响主从同步延迟等问题。</p>
<p>大地多大算大Key？这是没有标准的，通常认为字符串类型的key对应的value值空间占用超过了1M，或者集合中key对应的元素个数超过了1w，我们就认为该key是大key。</p>
<h2 id="大-Key-问题的缺点"><a href="#大-Key-问题的缺点" class="headerlink" title="大 Key 问题的缺点"></a>大 Key 问题的缺点</h2><ol>
<li><p><strong>内存占用较高</strong>：大 Key 会占用大量的内存，导致 Redis 可用内存减少。Redis 是一个内存数据库，内存是其主要资源。如果内存被大 Key 占用过多，可能会导致内存不足，触发内存淘汰策略，影响其他键的访问。</p>
</li>
<li><p><strong>降低性能</strong>：当对大 Key 进行处理时，会花费更多的 CPU 时间，导致整体性能下降，甚至会阻塞其他客户端的请求。大 Key 的读取、写入、删除等操作都会消耗更多的 CPU 资源，影响 Redis 的响应速度。</p>
</li>
<li><p><strong>网络拥塞</strong>：大 Key 在网络传输时会占用大量带宽，可能导致网络拥塞。特别是在高并发场景下，大量请求传输大 Key 会导致网络资源被耗尽，影响其他请求的传输。假设有一个大 Key <code>image:12345</code>，对应的值是一个 1MB 的图片数据。如果有 1000 个请求同时传输这个大 Key，会占用 1000MB 的网络带宽，导致网络拥塞。</p>
</li>
<li><p><strong>主从复制延迟</strong>：大 Key 在主从复制时需要传输大量数据，可能导致主从复制延迟，影响数据一致性。特别是在主从节点之间网络带宽有限的情况下，大 Key 的传输会占用大量带宽，导致复制延迟。</p>
</li>
<li><p><strong>数据倾斜</strong>：一个大 Key 会造成单个切片节点使用了很大一部分内存，导致内存使用率远超其他切片节点。这种数据倾斜会导致集群中某些节点负载过重，影响整体性能。</p>
</li>
</ol>
<h2 id="如何解决大-Key-问题"><a href="#如何解决大-Key-问题" class="headerlink" title="如何解决大 Key 问题"></a>如何解决大 Key 问题</h2><ul>
<li><strong>大Key拆分：</strong>将数万成员的大 Key 拆分为更小的分散的 Key，可以有效减少单个键的内存占用，提高 Redis 的处理效率。。</li>
<li><strong>内存清理：</strong>将大 Key 转移到其他存储介质（如文件系统、数据库等），然后释放 Redis 中的 Key，避免占用内存空间。（要使用异步删除）</li>
<li><strong>内存阈值监控：</strong>持续监控 Redis 的内存使用率，当发现内存用量到达阈值时或内存使用率突然大幅提升时，对内存进行相应的处理，比如删除不需要的 Key。。</li>
<li><strong>定期删除：</strong>定时对过期的 Key 进行删除，避免持续堆积而产生大 Key。</li>
</ul>
<h1 id="热Key"><a href="#热Key" class="headerlink" title="热Key"></a>热Key</h1><h2 id="什么是热key"><a href="#什么是热key" class="headerlink" title="什么是热key"></a>什么是热key</h2><p>热 Key 是指那些被频繁访问的键（Key），其请求频率远高于其他键。热 Key 问题会导致 Redis 的性能瓶颈，影响整体系统的响应速度。</p>
<ul>
<li><strong>QPS 请求集中在特定 Key</strong>：假设 Redis 有 10,000 的 QPS（每秒查询次数），而某个 Key 被请求的频率达到 7,000 QPS。</li>
<li><strong>带宽使用率集中在特定的 Key</strong>：某个 Key 的传输数据量占用了大量网络带宽。</li>
<li><strong>CPU 使用时间集中在特定的 Key</strong>：某个 Key 的处理占用了大量 CPU 时间。</li>
</ul>
<p><strong>热 Key 的影响</strong></p>
<ul>
<li><strong>性能瓶颈</strong>：热 Key 会导致 Redis 的性能瓶颈，影响整体系统的响应速度。</li>
<li><strong>资源浪费</strong>：热 Key 会占用大量 CPU、内存和网络资源，导致其他请求的资源不足。</li>
</ul>
<h2 id="如何解决热key"><a href="#如何解决热key" class="headerlink" title="如何解决热key"></a>如何解决热key</h2><ul>
<li><strong>负载均衡</strong>：由于 Redis 切片集群中，Key 的迁移粒度问题，无法将热 Key 迁移到其他节点分散单点压力。此时可以将热 Key 复制多几份，重新命名后装配到其他节点，并将热 Key 的请求分散到这些分散的节点中，以此降低单点压力。</li>
<li><strong>缓存预热</strong>：在系统启动时，提前加载热 Key 的数据到缓存中，避免系统启动后瞬间的高并发请求导致热 Key 问题。</li>
</ul>
<h1 id="三大缓存问题详解"><a href="#三大缓存问题详解" class="headerlink" title="三大缓存问题详解"></a>三大缓存问题详解</h1><p>在分布式系统中，缓存是提升系统性能的重要手段。然而，缓存也会带来一些问题，如<strong>缓存雪崩</strong>、<strong>缓存击穿</strong>和<strong>缓存穿透</strong>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指，在高并发场景下，同一时间内大量 Key 过期，或者 Redis 节点故障，导致大量的数据请求冲向数据库服务器，数据库可能会因无法承受大量数据请求而宕机。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png" alt="缓存雪崩" style="zoom:80%;">

<p>对于大量key同时过期造成的缓存雪崩，我们可以设置以下方案解决：</p>
<ol>
<li><strong>均匀key过期时间</strong>：对于同一时间大量 Key 过期而产生的缓存雪崩，可以设置随机的过期时间，避免大量 Key 在同一时间失效。通过在基础过期时间上增加一个随机值，可以有效分散 Key 的过期时间，避免集中失效。</li>
<li><strong>不设置 Key 过期时间</strong>：若业务场景可能长期需要该 Key，那么可以不设置过期时间，待业务活动过期后手动将 Key 删除。这种方式适用于那些长期有效的数据，避免频繁的缓存重建。</li>
<li><strong>互斥锁</strong>：当业务线程发现该 Key 不在缓存中，就设置一个互斥锁，保证同一时间只有一个线程在处理缓存，避免在失效期间大量线程同一时间读数据库写缓存。通过互斥锁，可以有效控制缓存重建的并发度，减少数据库压力。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，在高并发场景下，某个热点 Key 在缓存中过期，导致大量请求直接访问数据库，导致数据库压力骤增，甚至宕机。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292053764.png" alt="缓存击穿" style="zoom:80%;">

<p>对于缓存击穿，我们也可以使用应对缓存雪崩中采取的两个方案：</p>
<ul>
<li><strong>互斥锁：</strong>使用互斥锁，保证同一时间只有一个线程访问数据库，其他线程等待缓存更新。通过互斥锁，可以有效控制缓存重建的并发度，减少数据库压力。</li>
<li><strong>热点数据永不过期：</strong>对于热点数据，可以设置永不过期，或者设置较长的过期时间。这种方式适用于那些长期有效的数据，避免频繁的缓存重建。</li>
<li><strong>后台异步更新</strong>：保持热点 Key 持续在线，由后台异步更新缓存。或者在 Key 即将过期时通知后台线程，重新设置过期时间。这种方式可以避免缓存过期瞬间的大量请求冲击数据库。</li>
</ul>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指，在高并发场景下，请求的数据在缓存和数据库中都不存在，导致每次请求都直接访问数据库，导致数据库压力骤增，甚至宕机。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292117062.png" alt="缓存穿透" style="zoom:80%;">

<p>对于缓存穿透，我们可以采取以下方案：</p>
<ol>
<li><strong>限制非法请求</strong>：当有恶意的请求故意查询一条不存在的数据，大量的恶意请求也会导致缓存穿透问题。由此我们需要判断请求参数是否合理，过滤掉非法的数据请求。通过参数校验和请求过滤，可以有效减少非法请求对数据库的冲击。</li>
<li><strong>缓存空值或默认值</strong>：当我们发现环境中存在缓存穿透现象时，可以为不存在的数据设置为空值或默认值，当缓存中存在有值就不需要向数据库发起大量的请求了。通过缓存空值或默认值，可以避免大量请求直接访问数据库。</li>
<li><strong>布隆过滤器</strong>：我们可以在写入数据库时，使用布隆过滤器做标记，然后再请求到来时先判断缓存中是否存在该数据，若不存在则通过布隆过滤器快速判断要请求的数据是否存在。<strong>若判断存在，则数据可能存在</strong>，可以进一步向数据库查询；<strong>若判断不存在，则一定不存在</strong>，直接返回。通过布隆过滤器，可以快速过滤掉不存在的数据请求，减少数据库压力，Redis本身也实现了布隆过滤器。</li>
</ol>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>布隆过滤器是一种空间效率很高的概率型数据结构，用于判断一个元素是否在一个集合中。它由“初始值都为0的位图数组”和“n个哈希函数”两部分组成。布隆过滤器通过哈希计算来判断数据是否存在，具有高效的查询速度和较低的空间占用，但存在一定的误判率。当我们在写入数据库的时候，会在布隆过滤器中设置标记，证明该数据在数据库中存在，这样下次查询的时候直接先通过布隆过滤器就能判断出该数据在数据库中是否存在而不需要进一步查询数据库。</p>
<p>布隆过滤器会通过3个操作完成标记：</p>
<ol>
<li><strong>哈希计算</strong>：使用n个哈希函数对数据进行哈希计算，得到n个哈希值。</li>
<li><strong>取模操作</strong>：将n个哈希值分别对位图数组的长度取模，得到每个哈希值在位图数组中相对应的位置。</li>
<li><strong>设置标记</strong>：将每个哈希值在位图数组中相应的位置设置为1。</li>
</ol>
<p>举个例子，假设有一个长度为5的位图数组、哈希函数有2个的布隆过滤器。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292152465.png" alt="布隆过滤器" style="zoom:80%;">

<p>将数据x写入数据库后，会对数据x进行哈希计算，得到n个哈希值；再将得到的哈希值取模，也就得到了一堆数字结果，对应布隆过滤器中位图数组的位置；将这些位置设为1.下次要判断x是否存在于数据库中时，只需要对x进行哈希计算，查看对应位图数组上相应的位置是不是全都为1，如果全都是1，则认为数据可能存在于数据库中，可以继续下一步查询；否则，认为数据一定不存在。</p>
<p>布隆过滤器通过哈希计算来判断数据是否存在，必然存在哈希冲突，可能会有两个不同的数据计算出同样的哈希值，造成误判。具体来说：</p>
<ul>
<li><strong>误判情况</strong>：布隆过滤器<strong>认为数据存在</strong>，但实际上<strong>数据可能不存在</strong>。这种情况称为“假阳性”（False Positive）。</li>
<li><strong>正确情况</strong>：布隆过滤器<strong>认为数据不存在</strong>，则数据<strong>一定不存在</strong>。这种情况称为“真阴性”（True Negative）。</li>
</ul>
<p>所以，布隆过滤器认为该数据存在，则其可能存在；若认为数据不存在，则一定不存在。</p>
<h1 id="Redis-应用设计"><a href="#Redis-应用设计" class="headerlink" title="Redis 应用设计"></a>Redis 应用设计</h1><h2 id="如何设计秒杀场景处理高并发以及超卖现象？"><a href="#如何设计秒杀场景处理高并发以及超卖现象？" class="headerlink" title="如何设计秒杀场景处理高并发以及超卖现象？"></a>如何设计秒杀场景处理高并发以及超卖现象？</h2><p>秒杀场景是一种典型的高并发场景，通常涉及大量用户在短时间内对有限数量的商品进行抢购。为了应对高并发和避免超卖现象，需要从数据库层面、分布式锁、分段锁以及 Redis 和异步队列等多个方面进行设计和优化。</p>
<h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ol>
<li>查询商品库存时加排他锁</li>
</ol>
<p>在查询商品库存时，可以使用数据库的排他锁（<code>FOR UPDATE</code>）来保证数据的一致性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在事务中，线程 A 通过该语句给 id 为 ? 的数据行上了一个行级的排他锁。此时在事务期间，其他线程对该行的 <code>UPDATE</code> 和 <code>DELETE</code> 操作都将被阻塞，直到事务提交或发生回滚释放锁。</p>
<ol start="2">
<li>更新数据库减库存时进行库存限制</li>
</ol>
<p>在更新数据库减库存时，可以通过条件判断来避免超卖现象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> goods <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这种通过数据库加锁来解决的方案，性能不是很好，在高并发的情况下可能会因为获取不到数据库的连接或超时等待报错。</p>
<h3 id="利用分布式锁"><a href="#利用分布式锁" class="headerlink" title="利用分布式锁"></a>利用分布式锁</h3><p>分布式锁可以保证在同一时间内只有一个客户端能获取到锁，获得锁的线程才能进行接下来的业务逻辑，而其他客户端获取不到锁只能无限循环尝试获取锁。</p>
<p>可以使用 Redis 的 <code>SETNX</code> 命令来实现分布式锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireLock</span><span class="params">(String lockKey, String lockValue, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, lockValue, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String lockValue)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    jedis.eval(script, <span class="number">1</span>, lockKey, lockValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高并发状态下，分布式锁只能进行串行化处理，效率很低。比如大量用户对同一个热门商品下单，此时只能一个个处理下单操作，效率很慢。</p>
<h3 id="利用分布式锁-分段锁"><a href="#利用分布式锁-分段锁" class="headerlink" title="利用分布式锁 + 分段锁"></a>利用分布式锁 + 分段锁</h3><p>把数据分成很多段，每一段加上一个单独的锁，细粒度化，使得线程在对一段数据进行修改时，其他线程可以继续对剩下部分进行加锁操作。</p>
<p>假设商品库存分为多个段，每个段使用独立的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquireSegmentLock</span><span class="params">(String segmentKey, String lockValue, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(segmentKey, lockValue, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseSegmentLock</span><span class="params">(String segmentKey, String lockValue)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    jedis.eval(script, <span class="number">1</span>, segmentKey, lockValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分段锁，可以提高并发处理能力，减少锁的竞争，提升系统的吞吐量。</p>
<h3 id="利用-Redis-的-INCR、DECR-的原子性-异步队列"><a href="#利用-Redis-的-INCR、DECR-的原子性-异步队列" class="headerlink" title="利用 Redis 的 INCR、DECR 的原子性 + 异步队列"></a>利用 Redis 的 <code>INCR</code>、<code>DECR</code> 的原子性 + 异步队列</h3><ol>
<li>系统初始化时加载库存到 Redis</li>
</ol>
<p>在系统初始化时，将商品的库存数量加载到 Redis 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadStockToRedis</span><span class="params">(String key, <span class="type">int</span> stock)</span> &#123;</span><br><span class="line">    jedis.set(key, String.valueOf(stock));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接收到秒杀请求时预减库存</li>
</ol>
<p>接收到秒杀请求时，在 Redis 中进行预减库存（利用 Redis <code>DECR</code> 的原子性），当 Redis 的库存不足时直接返回秒杀失败，否则继续进行第三步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preDecreaseStock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">stock</span> <span class="operator">=</span> jedis.decr(key);</span><br><span class="line">    <span class="keyword">return</span> stock &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3, 将请求放入异步队列</p>
<p>将请求放入异步队列中，返回正在排队中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueueRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">    jedis.lpush(<span class="string">&quot;seckill_queue&quot;</span>, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>服务端异步队列请求出队</li>
</ol>
<p>服务端异步队列请求出队（可以出队的情况根据业务来判定，比如判断是否已秒杀过，防重复秒杀），出队的请求可以生成秒杀订单，减少数据库存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> jedis.rpop(<span class="string">&quot;seckill_queue&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理秒杀请求，生成订单，减少库存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>客户端轮询查看秒杀结果</li>
</ol>
<p>用户在客户端申请完秒杀后，进行轮询，查看是否秒杀成功，秒杀成功则进入秒杀订单详情，否则秒杀失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSeckillResult</span><span class="params">(String requestId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;seckill_result:&quot;</span> + requestId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用了异步队列写入数据库，可能存在数据不一致问题，其次引用多个组件，复杂度比较高。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">xiaoyan</div><div class="post-copyright__author_desc">无限进步。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/')">Redis-场景理解</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis-场景理解&amp;url=http://example.com/2024/09/27/Redis-%E5%9C%BA%E6%99%AF%E7%90%86%E8%A7%A3/&amp;pic=https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409292052862.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">XIAOYAN</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>数据库&amp;缓存<span class="categoryesPageCount">12</span></a><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Redis<span class="categoryesPageCount">5</span></a></div><div class="post-meta__box__tag-list"></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/27/Redis-%E9%9B%86%E7%BE%A4/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409282241271.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis-集群</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://spring.io/img/extra/why-spring.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring-基础（上）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">是一只时时翻垃圾吃的宅子。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">xiaoyan</h1><div class="author-info__desc">无限进步。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoyanfufu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/483597064" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%92%8C-MySQL"><span class="toc-number">1.</span> <span class="toc-text">Redis 和 MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">1.1.</span> <span class="toc-text">为什么使用Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E7%AD%89%E4%B8%8B%EF%BC%8CRedis-MySQL%E5%8D%95%E7%82%B9%E8%83%BD%E6%9C%89%E5%A4%9A%E5%A4%A7%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">高并发情况等下，Redis+MySQL单点能有多大并发量？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">如何保证Redis和MySQL数据缓存一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">消息队列方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85MySQL-binlog%EF%BC%8C%E5%86%8D%E6%93%8D%E4%BD%9C%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">订阅MySQL binlog，再操作缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%B8%8E-Redis-%E7%BC%93%E5%AD%98%EF%BC%9A%E6%80%A7%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.</span> <span class="toc-text">本地缓存与 Redis 缓存：性能与应用场景的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">本地缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%88Redis%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">分布式缓存（Redis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.</span> <span class="toc-text">应用场景对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">Redis 应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">Redis 实现消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pub-Sub%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用Pub&#x2F;Sub模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%EF%BC%88Publisher%EF%BC%89"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">发布者（Publisher）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%88Subscriber%EF%BC%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">订阅者（Subscriber）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List"><span class="toc-number">3.1.2.</span> <span class="toc-text">使用List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Stream%EF%BC%88Redis-5-0-%E5%90%8E%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用 Stream（Redis 5.0 后）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89-1"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">生产者（Producer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89-1"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">消费者（Consumer）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">Redis 实现分布式锁详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">Redis 分布式锁实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-SET-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BA%89%E6%8A%A2%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">基于 SET 命令的争抢锁机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedLock-%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">RedLock 算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-Key"><span class="toc-number">4.</span> <span class="toc-text">Redis Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">Redis 大 Key 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7-Key-%E9%97%AE%E9%A2%98%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">大 Key 问题的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%A7-Key-%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">如何解决大 Key 问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%83%ADKey"><span class="toc-number">5.</span> <span class="toc-text">热Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADkey"><span class="toc-number">5.1.</span> <span class="toc-text">什么是热key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey"><span class="toc-number">5.2.</span> <span class="toc-text">如何解决热key</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">三大缓存问题详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.1.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">布隆过滤器原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">Redis 应用设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E8%B6%85%E5%8D%96%E7%8E%B0%E8%B1%A1%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">如何设计秒杀场景处理高并发以及超卖现象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据库层面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">7.1.2.</span> <span class="toc-text">利用分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">7.1.3.</span> <span class="toc-text">利用分布式锁 + 分段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-Redis-%E7%9A%84-INCR%E3%80%81DECR-%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7-%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">7.1.4.</span> <span class="toc-text">利用 Redis 的 INCR、DECR 的原子性 + 异步队列</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-分库分表"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表">数据库优化-分库分表</a><time datetime="2024-11-03T08:20:54.000Z" title="发表于 2024-11-03 16:20:54">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202411041125092.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-读写分离与冷热分离"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离">数据库优化-读写分离与冷热分离</a><time datetime="2024-11-03T08:18:25.000Z" title="发表于 2024-11-03 16:18:25">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410282316960.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-进程管理"/></a><div class="content"><a class="title" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理">操作系统-进程管理</a><time datetime="2024-10-28T14:52:35.000Z" title="发表于 2024-10-28 22:52:35">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410281041645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式事务"/></a><div class="content"><a class="title" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务">分布式-分布式事务</a><time datetime="2024-10-27T13:08:20.000Z" title="发表于 2024-10-27 21:08:20">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410272103963.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-服务治理（下）"/></a><div class="content"><a class="title" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）">分布式-服务治理（下）</a><time datetime="2024-10-21T07:24:49.000Z" title="发表于 2024-10-21 15:24:49">2024-10-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="xiaoyan" target="_blank">xiaoyan</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">17</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 0.88rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 0.88rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 0.88rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 0.88rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 0.88rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 0.88rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 0.88rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 0.88rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 0.88rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 0.88rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 0.88rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 0.88rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 0.88rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 0.88rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>