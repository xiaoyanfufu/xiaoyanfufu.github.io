<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Redis-数据结构 | XIAOYAN</title><meta name="keywords" content="数据结构,线程模型"><meta name="author" content="xiaoyan"><meta name="copyright" content="xiaoyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Redis-数据结构"><meta name="application-name" content="Redis-数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Redis-数据结构"><meta property="og:url" content="http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/index.html"><meta property="og:site_name" content="XIAOYAN"><meta property="og:description" content="数据结构Redis底层数据结构Redis是一种高性能的非关系型数据库（NoSQL），提供了多种数据类型以满足不同的应用需求。常见的数据类型包括String、List、Hash、Set和Zset。每种数据类型在Redis内部都有特定的底层数据结构来支持其功能和性能特性。 数据类型与底层结构"><meta property="og:locale" content="zn-CN"><meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409271934547.png"><meta property="article:author" content="xiaoyan"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409271934547.png"><meta name="description" content="数据结构Redis底层数据结构Redis是一种高性能的非关系型数据库（NoSQL），提供了多种数据类型以满足不同的应用需求。常见的数据类型包括String、List、Hash、Set和Zset。每种数据类型在Redis内部都有特定的底层数据结构来支持其功能和性能特性。 数据类型与底层结构"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: xiaoyan","link":"链接: ","source":"来源: XIAOYAN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XIAOYAN',
  title: 'Redis-数据结构',
  postAI: '',
  pageFillDescription: '数据结构, Redis底层数据结构, 数据类型与底层结构, Zset实现, 基础了解, 如何使用Zset, 跳表实现, Redis 为啥使用跳表而不是B+树？, 压缩列表实现, 主要字段, 查找元素, 节点结构, 插入数据, 连锁更新问题, Listpack实现, Listpack的特点, Listpack的头部信息, Listpack节点的结构, Hash表扩容, 传统rehash的问题, 渐进式rehash, 渐进式rehash的步骤, 渐进式rehash的优势, 渐进式rehash期间的Hash表操作, String存储, SDS的结构, SDS的优势, 示例, 线程模型, Redis为什么快？, Redis对多线程的使用, Redis如何实现IO多路复用, Ix2FO多路复用的概念, Redis中的Ix2FO多路复用, Redis网络模型, 单Reactor单线程模型, Redis 6.0的多线程网络Ix2FO数据结构底层数据结构是一种高性能的非关系型数据库提供了多种数据类型以满足不同的应用需求常见的数据类型包括和每种数据类型在内部都有特定的底层数据结构来支持其功能和性能特性数据类型与底层结构数据类型底层结构存储的值读写能力简单动态字符串字符串整数或浮点数支持原子性的读写操作适用于计数器缓存等场景双向链表或压缩列表字符串元素的列表支持高效的插入和删除操作适用于消息队列任务队列等哈希表或压缩列表字段值对支持快速的查找插入和删除操作适用于存储对象属性哈希表或整数集合无序唯一的字符串集合支持高效的集合运算交集并集差集适用于标签系统好友关系等跳表或压缩列表有序唯一的字符串集合每个元素关联一个分数支持按分数排序的查找插入和删除操作适用于排行榜范围查询等而在后续的版本更新中又增加了新的四种数据结构支持数据结构常用的场景分别如下不仅存储字符串数据还维护了字符串的长度和可用空间适用于存储对象简单计数器分布式锁等例如可以使用命令实现一个简单的计数器用于统计网站的访问量使用双向链表来存储数据适用于消息队列任务队列等例如可以使用和命令实现一个简单的消息队列用于处理异步任务使用哈希表来存储数据适用于存储对象属性如购物车例如可以使用和命令存储用户的购物车信息高效地进行集合运算交集并集差集适用于标签系统好友关系等例如可以使用命令计算两个用户之间的共同好友使用跳表来存储数据这样可以高效地进行按分数排序适用于排行榜范围查询等例如可以使用和命令实现一个热度榜用于展示热门文章在后续的版本更新中增加了四种新的数据结构用于存放二值计算如用户签到等用于海量基数统计比如统计网站的独立访客数常用于存放地理位置信息比如高德地图滴滴打车常用于做详细队列与不同的是会自动生成全局唯一支持消费组形式消费数据实现基础了解有序集合是中一种非常重要的数据类型它能够存储有序的字符串集合并且每个元素都关联一个分数通过分数可以对元素进行排序的底层实现主要依赖于两种数据结构跳表和压缩列表在及之后的版本中压缩列表已被弃用取而代之的是在版本之前数据结构为若有序集合的元素小于且元素的数据大小小于字节时会采用压缩列表作为底层数据结构若有序集合不满足以上条件则采用跳表作为数据结构如何使用以某文章热度为例以下介绍在中如何使用使用添加文章命令用于向有序集合中添加一个或多个元素每个元素都关联一个分数用于排序在这个例子中我们向名为的有序集合中添加了三篇文章初始热度为使用增加文章热度命令用于增加有序集合中某个元素的分数热度在这个例子中我们分别增加了三篇文章的热度增加了增加了增加了使用和获取热度前三的文章命令用于获取有序集合中指定范围内的元素由于默认是按升序排列的因此我们需要获取热度最高的三篇文章时可以使用反转范围来获取选项用于同时返回元素的分数在这个例子中我们使用命令来获取热度前三的文章及其热度值使用找出热度大于的文章命令用于获取有序集合中分数在指定范围内的元素在这个例子中我们获取了热度大于的所有文章及其热度值跳表实现链表在查询数据时需要一个个元素遍历时间复杂度是的查询效率贼低所以就有了跳表跳表是在链表的基础上改进的实现了一种多层的有序链表结构以便于快速定位数据位置以上图中头节点有三个头指针分别指向不同层级的节点每个层级的节点都通过指针连接起来层有个节点层有个节点层有个节点跳表的核心思想是通过增加多级索引来加速查找过程跳表的每一层都是一个有序链表高层级的节点数量较少低层级的节点数量较多通过这种方式跳表可以在的时间复杂度内完成查找操作跳表是如何工作的呢举个例子假设我们在链表中需要查找这个数据节点一个个元素遍历到该节点需要查找次加了一层索引后优化到需要次转往下一层节点找以此类推查找流程示意图如下这个查找的过程在链表中跳跃最后定位到元素当数据量巨大时查询的时间复杂度就来到了那么跳表的节点如何实现多层级的跳表的节点结构包含以下几个关键部分元素值存储节点的值通常是一个字符串类型分数存储节点的分数用于排序通常是一个双精度浮点数类型后向指针指向前一个节点方便从跳表的尾节点开始访问倒序查找时方便层级数组包含多个层级的信息每个层级包含两个信息前向节点指针指向当前层级的下一个节点跨度表示当前节点到下一个节点之间的跨度用于计算节点的排名以下是跳表节点的语言数据结构示例元素值分数后向指针前向节点指针跨度层级数组跟我的刚开始想象不同的是在跳表中跨度并不是固定的步长而是表示当前节点到下一个节点之间的距离跨度可以是也可以是不必与上一个节点同层级的跨度一致跨度的主要作用是帮助计算节点的排名而不是用于遍历操作遍历操作只需要通过链表的前向指针来实现在这里继续引用小林哥的模拟图跳表在创建节点时随机生成每个节点的层数并没有严格维持相邻两层的节点数量比例为的情况具体的做法是跳表在创建节点时会生成一个范围是的随机数并根据这个随机数来决定节点的层数如果随机数小于选取基于概率和性能考虑则增加一层然后生成下一个随机数直到随机数大于结束最后层数越高概率越低最高不会超过层为啥使用跳表而不是树选择跳表而不是树作为有序集合的底层数据结构主要是基于以下几个方面的考虑内存占用对范围查找的支持实现难易程度内存占用更少树每个节点通常包含两个指针至少一个指向左子节点一个指向右子节点此外树的叶子节点还需要存储数据这会占用更多的内存跳表跳表的节点包含一个前向指针和一个跨度平均每个节点包含约个指针概率期望值由于跳表的层数是随机生成的高层级的节点数量较少因此总体内存占用较少范围查询更简单树树的范围查询需要从根节点开始遍历找到范围的起始节点然后沿着叶子节点链表遍历到范围的结束节点这个过程相对复杂尤其是在范围较大时跳表跳表的范围查询非常简单只需要从最高层级开始逐级向下查找直到找到范围的起始节点然后沿着链表遍历到范围的结束节点由于跳表的层级结构范围查询的效率非常高算法实现难度更简单树树的实现相对复杂需要维护平衡性插入和删除操作需要进行复杂的旋转和分裂操作以保持树的平衡跳表跳表的实现相对简单插入和删除操作只需要更新指针不需要进行复杂的平衡操作跳表的层数是随机生成的不需要严格维持平衡性因此实现难度较低压缩列表实现压缩列表是为优化内存使用而设计的一种紧凑的顺序存储结构类似于数组它通过一系列精心设计的字段来高效地存储和访问数据特别适用于存储少量数据主要字段压缩列表包含以下几个关键字段记录当前压缩列表总共占用的字节数这个字段帮助快速计算列表的总大小无需遍历整个列表记录最后一个节点相对于头节点的偏移量通过这个字段可以快速定位到最后一个节点而不需要从头遍历整个列表记录当前压缩列表中节点的数量这个字段帮助快速获取列表的长度表示压缩列表的结束位置通常值为即十进制的这个字段用于标识列表的结束类似于语言中的空字符查找元素在压缩列表中查找第一个和最后一个元素非常高效时间复杂度为具体来说查找第一个元素直接从列表头开始时间复杂度为查找最后一个元素通过字段可以直接计算出最后一个节点的位置时间复杂度也为然而查找其他元素则需要遍历列表时间复杂度为其中是列表中节点的数量因此压缩列表并不适合存储大量数据更适合用于存储少量频繁访问的数据节点结构压缩列表中的每个节点包含以下三个部分记录前一个节点的长度这个字段使得从后向前遍历列表成为可能因为可以通过快速定位到前一个节点记录当前节点实际数据的类型和长度支持两种主要的数据类型字符串和整数字段根据数据类型和大小动态调整以节省内存记录当前节点的实际数据根据字段的不同部分可以是字符串或整数插入数据当向压缩列表插入数据时会根据插入数据的类型和大小动态调整和字段的空间占用例如如果插入的是一个较小的整数字段可能会使用较少的字节来表示这个整数如果插入的是一个较长的字符串字段可能会使用更多的字节来表示字符串的长度这种根据数据类型和大小进行动态空间分配的设计思想正是为了节省内存而采用的核心策略连锁更新问题压缩列表的缺点是会发生连锁更新问题因为连锁更新一旦发生就会导致压缩列表多次重新分配分配从而影响直接压缩列表的访问性能为什么会发生连锁更新问题因为当插入或删除节点时如果前一个节点的长度发生变化可能会导致后续节点的字段需要更新从而引发连锁更新在压缩列表中字段的长度是动态的根据前一个节点的长度来决定例如如果前一个节点的长度小于字节字段占用字节如果大于等于字节字段占用字节实现尽管通过控制中元素的大小和数量来缓解压缩列表的性能问题但它并未完全解决压缩列表中存在的连锁更新问题为了进一步优化在版本中引入了一个新的数据结构的特点最大的特点是每个节点不再包含前一个节点的长度信息这一设计从根本上消除了连锁更新问题从而提高了数据结构的稳定性和性能的头部信息的头部包含两个关键数据总字节数记录整个结构占用的总字节数这个字段帮助快速计算的大小无需遍历整个结构元素数量记录中包含的元素数量这个字段帮助快速获取的长度节点的结构中的每个节点包含以下三个部分定义该元素的编码类型字段根据数据类型和大小动态调整以节省内存例如如果数据是一个小整数字段可能会使用较少的字节来表示这个整数实际存放的数据根据字段的不同部分可以是字符串或整数和的总长度这个字段记录了当前节点的总字节数帮助快速计算节点的长度假设我们有一个其中存储了三个节点第一个节点存储了一个整数第二个节点存储了一个字符串第三个节点存储了一个整数在这种情况下的头部会记录整个的总字节数和元素数量每个节点的字段会根据数据类型整数或字符串和数据大小动态调整而字段会记录当前节点的总字节数例如第一个节点的可能是表示一个小整数是可能是字节第二个节点的可能是表示一个字符串是可能是字节第三个节点的可能是表示一个小整数是可能是字节通过这种设计在存储数据时更加紧凑和高效同时避免了压缩列表中连锁更新的问题因为已经不会影响其他节点长度字段的变化从而提高了整体性能和稳定性表扩容在中表的扩容是一个关键操作用于处理表在数据量增加时可能出现的性能问题然而传统的过程可能会导致性能瓶颈特别是在表中数据量非常大的情况下为了解决这个问题采用了渐进式机制传统的问题在传统的过程中需要使用两个表表当前正在使用的表表新建的表空间大小通常是表的两倍传统的步骤如下分配空间为表分配空间数据迁移将表中的所有数据重新分配到表中释放空间数据迁移完成后释放表的空间并将表设置为当前使用的表这种一次性完成数据迁移的方式存在以下问题性能影响如果表中的数据量非常大数据迁移过程需要大量复制操作可能导致阻塞影响性能阻塞风险在数据迁移期间无法处理其他请求可能导致服务中断渐进式为了避免上述问题采用了渐进式机制渐进式的核心思想是将数据迁移过程分散到多次操作中而不是一次性完成渐进式的步骤分配空间为表分配空间逐步迁移在期间每次对表进行增删改查操作时除了执行这些操作还会顺序地将索引位置上的所有迁移到表中完成迁移随着处理客户端发起的表操作越来越多最终某个时间点会将表中的所有迁移到表中完成操作渐进式的优势避免阻塞通过将数据迁移分散到多次操作中避免了在过程中的阻塞提高了系统的可用性平滑过渡渐进式使得表的扩容过程更加平滑减少了性能波动渐进式期间的表操作在渐进式进行期间会同时维护两个表表和表因此表的删除查找更新等操作会在两个表中进行查找操作先在表中查找如果没找到再在表中查找新增操作新增的会被保存到表中而表不再进行任何添加操作删除和更新操作同样会在两个表中进行查找和操作随着渐进式的进行表的数量会逐渐减少最终变为空表当所有数据都迁移到表后表会被释放表成为当前使用的表假设我们有一个表其中包含万个对当表需要扩容时会执行以下步骤分配空间为表分配空间大小为表的两倍逐步迁移在每次对表进行操作时会逐步将表中的数据迁移到表中例如每次操作时迁移个对完成迁移随着操作的进行最终所有数据都会迁移到表中通过这种方式避免了在过程中可能出现的性能瓶颈和阻塞问题确保了系统的稳定性和性能存储在中类型的数据是通过数据结构来存储的是自己实现的一种字符串表示方式相较于语言中的字符数组提供了更多的功能和优势的结构的结构中包含以下几个成员变量记录了字符串的实际长度这个字段使得获取字符串长度的时间复杂度为因为可以直接从属性读取而不需要像语言中的函数那样遍历整个字符数组分配给字符串的空间数组长度这个字段记录了当前结构中为字符数组分配的总空间大小用于管理内存分配和释放用来表示不同类型的有多种类型字段用于区分这些类型以便在不同情况下进行不同的处理字符数组用来保存实际的字符串数据这个字段存储了字符串的内容的优势相较于语言的字符数组具备以下优势的获取长度时间复杂度在语言中获取字符串长度需要调用函数该函数需要遍历整个字符数组时间复杂度为在中字符串的长度直接存储在字段中获取长度的时间复杂度为极大地提高了性能二进制安全语言的字符串以空字符作为字符串的结束标志这使得语言字符串不能存储包含空字符的二进制数据使用字段来表示字符串的长度因此不需要以空字符作为结束标志可以安全地存储任意二进制数据避免缓冲区溢出在语言中如果字符串操作不当可能会导致缓冲区溢出即写入的数据超出了分配的内存空间导致程序崩溃或安全漏洞通过字段记录分配的内存空间大小并在字符串操作时检查是否超出分配的空间从而避免了缓冲区溢出的问题示例假设我们有一个字符串在语言中它通常表示为在中这个字符串的表示方式如下字符串长度值为分配的空间大小假设为类型标志假设为字符数组存储在这个例子中字段的值为表示字符串的长度字段的值为表示为字符数组分配了个字节的内存空间字段的值为表示这是一个基本的类型字段存储了字符串的实际内容通过这种方式不仅提供了高效的性能还解决了语言字符串的一些常见问题如缓冲区溢出和二进制不安全等线程模型为什么快以其极高的性能而闻名官方基准测试结果显示单线程的吞吐量可以达到每秒万次操作之所以能够实现如此高的性能主要有以下几个原因内存操作的大部分操作都是在内存中完成的内存的访问速度远远快于磁盘因此数据操作的性能瓶颈通常不在于而在于数据的操作基于内存操作将性能瓶颈从磁盘转移到了内存和网络传输上此外还采用了高性能的数据结构如哈希表跳表等进一步提升了操作效率单线程模型采用单线程模型来处理网络和请求数据单线程模型有以下几个优势避免线程竞争多线程程序中线程间的竞争和同步开销较大单线程模型避免了线程间的竞争问题减少了线程切换的开销简化设计单线程模型简化了程序设计避免了复杂的线程同步和锁机制降低了出错的概率多路复用机制采用多路复用机制来处理大量的客户端请求多路复用机制允许一个线程同时处理多个流具体来说内核监听在单线程的情况下多路复用机制允许内核同时监听多个上的连接请求和数据请求请求处理一旦有请求到达内核会将请求交给线程处理从而实现了一个线程处理多个流的效果高效的数据结构内部使用了多种高效的数据结构如哈希表跳表压缩列表等这些数据结构在内存中操作时能够提供高效的插入删除和查找操作进一步提升了的性能对多线程的使用的单线程模型指的是接收客户端请求解析客户端请求进行数据操作返回数据给客户端这个过程由一个主线程完成虽然在处理客户端请求时采用单线程模型但这并不意味着程序本身是单线程的实际上在启动时会启动多个后台线程来处理一些耗时的任务从而避免这些任务占用主线程的资源影响的性能在后台会启动线程分别完成关闭文件和刷盘任务在版本后新增了一个线程用于异步释放内存操作也就是例如执行等命令异步释放内存这样的好处是不占用主线程将这些关闭文件算盘释放空间任务交由创建的独立线程完成能够极大地提升的处理效率因为这些操作都是极为耗时的若由主线程完成可能会造成阻塞同时也没法处理其他请求了严重影响了的性能虽然的主要工作网络和执行命令一直是单线程模型但在版本也引入了多个线程来处理网络请求这是因为随着网络硬件性能的提升的性能瓶颈有时候会出现在处理网络上多线程网络的优势提升网络并行度通过引入多线程处理网络请求能够更高效地处理大量的并发连接和数据传输从而提升整体的性能不影响命令执行尽管引入了多线程处理网络但对于执行命令仍然采用单线程模型这种设计确保了命令执行的顺序性和一致性避免了多线程带来的复杂性和潜在的竞争问题如何实现多路复用采用单线程模型来执行命令这意味着所有的任务都按照顺序执行然而由于输入输出操作是阻塞的如果一个文件的操作阻塞整个进程将无法为其他客户端提供服务为了解决这个问题采用了多路复用技术多路复用的概念多路复用是一种允许单个线程同时监视多个文件描述符如的技术通过这种技术单个线程可以检查多个的就绪状态从而在单个线程中处理多个流中的多路复用在中多路复用主要用于处理多个客户端连接的网络操作使用了一种称为的机制来实现多路复用是系统中的一种高效的多路复用技术能够显著提高在高并发环境下的性能其模型参考一张网络来源图监听多个主线程会监听多个客户端连接的每个代表一个客户端连接事件通知当某个上有数据到达如客户端发送请求机制会通知主线程处理事件主线程接收到事件通知后会处理该上的请求执行相应的命令并将结果返回给客户端机制使用非阻塞操作当某个文件描述符上的操作无法立即完成时多路复用机制会立即返回并继续监听其他文件描述符上的事件继续监听处理完一个事件后主线程继续监听其他等待下一个事件的到来假设我们有一个服务器它需要处理多个客户端的请求在传统的阻塞模型中每个客户端连接都需要一个独立的线程来处理这会导致线程数量过多资源消耗大而在的多路复用模型中所有客户端连接的都由一个主线程监听和处理例如当客户端发送一个请求时机制会通知主线程处理该请求同时客户端的请求也会被监听到并交给主线程处理通过这种方式能够高效地处理大量的并发请求而不会因为线程切换和竞争导致性能下降通过采用多路复用技术实现了在单个线程中高效处理多个客户端连接的请求这种设计使得能够在高并发环境下提供极高的性能同时确保系统的稳定性和响应速度通过机制能够监听多个并在事件发生时及时处理避免了传统阻塞模型中的性能瓶颈网络模型在版本之前采用的是单单线程模型这种模型虽然简单但在高并发环境下存在一些性能瓶颈为了进一步提升性能在版本引入了多线程处理网络但命令的执行仍然保持单线程模式单单线程模型在之前采用的是单单线程模型缺点无法充分利用多核单线程模型无法充分利用多核的计算能力限制了在高并发环境下的性能业务处理延时在进行业务处理时无法执行其他连接的事件如果业务处理时间较长会造成较大的延时影响系统的响应速度的多线程网络为了解决单单线程模型的性能瓶颈在版本引入了多线程处理网络具体来说多线程处理网络将网络操作从主线程中分离出来使用多个线程来处理网络请求从而提高网络的并行度和处理效率单线程执行命令尽管网络采用了多线程处理但对于命令的执行仍然保持单线程模式这种设计确保了命令执行的顺序性和一致性避免了多线程带来的复杂性和潜在的竞争问题优点提升网络并行度通过多线程处理网络能够更高效地处理大量的并发连接和数据传输从而提升整体的性能不影响命令执行尽管引入了多线程处理网络但对于命令的执行仍然采用单线程模型这种设计确保了命令执行的顺序性和一致性避免了多线程带来的复杂性和潜在的竞争问题假设我们有一个服务器它需要处理大量的客户端请求在之前所有的网络和命令执行都在一个主线程中进行如果某个客户端的请求处理时间较长会导致主线程阻塞无法处理其他客户端的请求在中网络操作被分离出来由多个线程处理例如当客户端发送一个请求时网络线程会处理该请求的读取和写入操作同时客户端的请求也会被其他网络线程处理这样即使某个客户端的请求处理时间较长也不会影响其他客户端的请求处理在版本之前采用单单线程模型虽然简单但在高并发环境下存在性能瓶颈为了进一步提升性能在版本引入了多线程处理网络但命令的执行仍然保持单线程模式这种设计使得能够在高并发环境下提供极高的性能同时确保系统的稳定性和响应速度',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 11:40:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/images/star.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XIAOYAN</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 1.05rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 1.05rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 1.05rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 1.05rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 1.05rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.05rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 1.05rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 1.05rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 1.05rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 1.05rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 1.05rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/" itemprop="url">数据库&amp;缓存</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/" itemprop="url">Redis</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据结构</span></a><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>线程模型</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Redis-数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-27T00:53:09.000Z" title="发表于 2024-09-27 08:53:09">2024-09-27</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.435Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为桂林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>桂林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409271934547.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"><header><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/" itemprop="url">数据库&amp;缓存</a><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/" itemprop="url">Redis</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url">数据结构</a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url">线程模型</a><h1 id="CrawlerTitle" itemprop="name headline">Redis-数据结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">xiaoyan</span><time itemprop="dateCreated datePublished" datetime="2024-09-27T00:53:09.000Z" title="发表于 2024-09-27 08:53:09">2024-09-27</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.435Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></header><span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><p>Redis是一种高性能的非关系型数据库（NoSQL），提供了多种数据类型以满足不同的应用需求。常见的数据类型包括<strong>String</strong>、<strong>List</strong>、<strong>Hash</strong>、<strong>Set</strong>和<strong>Zset</strong>。每种数据类型在Redis内部都有特定的底层数据结构来支持其功能和性能特性。</p>
<h3 id="数据类型与底层结构"><a href="#数据类型与底层结构" class="headerlink" title="数据类型与底层结构"></a>数据类型与底层结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409271934547.png" alt="Redis底层数据结构图"></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>底层结构</th>
<th>存储的值</th>
<th>读写能力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String</strong></td>
<td>简单动态字符串（SDS）</td>
<td>字符串、整数或浮点数</td>
<td>支持原子性的读写操作，适用于计数器、缓存等场景。</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td>双向链表或压缩列表（ziplist）</td>
<td>字符串元素的列表</td>
<td>支持高效的插入和删除操作，适用于消息队列、任务队列等。</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td>哈希表或压缩列表（ziplist）</td>
<td>字段-值对</td>
<td>支持快速的查找、插入和删除操作，适用于存储对象属性。</td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>哈希表或整数集合（intset）</td>
<td>无序、唯一的字符串集合</td>
<td>支持高效的集合运算（交集、并集、差集），适用于标签系统、好友关系等。</td>
</tr>
<tr>
<td><strong>Zset</strong></td>
<td>跳表或压缩列表（ziplist）</td>
<td>有序、唯一的字符串集合，每个元素关联一个分数</td>
<td>支持按分数排序的查找、插入和删除操作，适用于排行榜、范围查询等。</td>
</tr>
</tbody></table>
<p>而在后续的版本更新中，又增加了新的四种数据结构支持：<strong>BitMap（2.2）</strong>、<strong>HyperLogLog（2.8）</strong>、<strong>GEO（3.2）</strong>、<strong>Stream（5.0）</strong></p>
<p>redis数据结构常用的场景分别如下：</p>
<ul>
<li><strong>String：</strong>不仅存储字符串数据，还维护了字符串的长度和可用空间。适用于存储对象、简单计数器、分布式锁、session等。例如，可以使用<code>INCR</code>命令实现一个简单的计数器，用于统计网站的访问量。</li>
<li><strong>List：</strong>使用双向链表来存储数据。适用于消息队列、任务队列等。例如，可以使用<code>LPUSH</code>和<code>RPOP</code>命令实现一个简单的消息队列，用于处理异步任务。</li>
<li><strong>Hash：</strong>使用哈希表来存储数据。适用于存储对象属性，如购物车。例如，可以使用<code>HSET</code>和<code>HGET</code>命令存储用户的购物车信息。</li>
<li><strong>Set：</strong>高效地进行集合运算（交集、并集、差集）。适用于标签系统、好友关系等。例如，可以使用<code>SINTER</code>命令计算两个用户之间的共同好友。</li>
<li><strong>Zset：</strong>使用跳表来存储数据，这样可以高效地进行按分数排序。适用于排行榜、范围查询等。例如，可以使用<code>ZADD</code>和<code>ZRANGE</code>命令实现一个热度榜，用于展示热门文章。</li>
</ul>
<p>在后续的版本更新中，Redis增加了四种新的数据结构：</p>
<ul>
<li><strong>BitMap（2.2）</strong>：用于存放二值计算，如用户签到等。</li>
<li><strong>HyperLogLog（2.8）</strong>：用于海量基数统计，比如统计网站的独立访客数。</li>
<li><strong>GEO（3.2）</strong>：常用于存放地理位置信息，比如高德地图、滴滴打车。</li>
<li><strong>Stream（5.0）</strong>：常用于做详细队列，与List不同的是，Stream会自动生成全局唯一ID，支持消费组形式消费数据。</li>
</ul>
<h2 id="Zset实现"><a href="#Zset实现" class="headerlink" title="Zset实现"></a>Zset实现</h2><h3 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h3><p>Zset（有序集合）是Redis中一种非常重要的数据类型，它能够存储有序的字符串集合，并且每个元素都关联一个分数（score），通过分数可以对元素进行排序。Zset的底层实现主要依赖于两种数据结构：<strong>跳表（Skip List）</strong>和<strong>压缩列表（ziplist）</strong>。<strong>在Redis 7.0及之后的版本中，压缩列表已被弃用，取而代之的是listpack</strong>。</p>
<p>在Redis7.0版本之前，Zset数据结构为：</p>
<ul>
<li>若有序集合的元素小于128，且元素的数据大小小于64字节时，Redis会采用压缩列表作为底层数据结构。</li>
<li>若有序集合不满足以上条件，则采用跳表作为数据结构。</li>
</ul>
<h3 id="如何使用Zset"><a href="#如何使用Zset" class="headerlink" title="如何使用Zset"></a>如何使用Zset</h3><p>以某文章热度为例，以下介绍在Redis中如何使用Zset。</p>
<ol>
<li><strong>使用<code>ZADD</code>添加文章</strong></li>
</ol>
<p><code>ZADD</code>命令用于向有序集合中添加一个或多个元素。每个元素都关联一个分数（score），用于排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD article_hotness 0 &quot;article_id_1&quot; 0 &quot;article_id_2&quot; 0 &quot;article_id_3&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们向名为<code>article_hotness</code>的有序集合中添加了三篇文章，初始热度为0。</p>
<ol start="2">
<li><strong>使用<code>ZINCRBY</code>增加文章热度</strong></li>
</ol>
<p><code>ZINCRBY</code>命令用于增加有序集合中某个元素的分数（热度）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY article_hotness 10 &quot;article_id_1&quot;</span><br><span class="line">ZINCRBY article_hotness 20 &quot;article_id_2&quot;</span><br><span class="line">ZINCRBY article_hotness 30 &quot;article_id_3&quot;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们分别增加了三篇文章的热度，<code>article_id_1</code>增加了10，<code>article_id_2</code>增加了20，<code>article_id_3</code>增加了30。</p>
<ol start="3">
<li><strong>使用<code>ZRANGE</code>和<code>WITHSCORES</code>获取热度前三的文章</strong></li>
</ol>
<p><code>ZRANGE</code>命令用于获取有序集合中指定范围内的元素。由于Zset默认是按升序排列的，因此我们需要获取热度最高的三篇文章时，可以使用反转范围来获取。<code>WITHSCORES</code>选项用于同时返回元素的分数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREVRANGE article_hotness 0 2 WITHSCORES</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用<code>ZREVRANGE</code>命令来获取热度前三的文章及其热度值。</p>
<ol start="4">
<li><strong>使用<code>ZRANGEBYSCORE</code>找出热度大于500的文章</strong></li>
</ol>
<p><code>ZRANGEBYSCORE</code>命令用于获取有序集合中分数在指定范围内的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE article_hotness 500 +inf WITHSCORES</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们获取了热度大于500的所有文章及其热度值。</p>
<h2 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h2><p>链表在查询数据时，需要一个个元素遍历，时间复杂度是O(N)的，查询效率贼低，所以就有了跳表。跳表是在链表的基础上改进的，实现了一种“多层”的有序链表结构，以便于快速定位数据位置。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409272108847.png" alt="跳表数据结构" style="zoom:80%;">

<p>以上图中头节点有L0~L2三个头指针，分别指向不同层级的节点，每个层级的节点都通过指针连接起来。</p>
<ul>
<li>L0层有5个节点：1、2、3、4、5</li>
<li>L1层有3个节点：2、3、4</li>
<li>L2层有1个节点：3</li>
</ul>
<p>跳表的核心思想是通过增加多级索引来加速查找过程。跳表的每一层都是一个有序链表，高层级的节点数量较少，低层级的节点数量较多。通过这种方式，跳表可以在O(log n)的时间复杂度内完成查找操作。</p>
<p>跳表是如何工作的呢？举个例子，假设我们在链表中需要查找33这个数据节点，一个个元素遍历到该节点需要查找6次(1-&gt;5-&gt;11-&gt;20-&gt;27-&gt;33)，加了一层索引后，优化到需要4次(1-&gt;11-&gt;27-x-&gt;50转往下一层节点找27-&gt;33)，以此类推。查找流程示意图如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409272106480.png" alt="跳表查找元素模拟"></p>
<p>这个查找的过程在链表中跳跃，最后定位到元素，当数据量巨大时，查询的时间复杂度就来到了O(logn)。</p>
<p>那么跳表的节点如何实现多层级的？跳表的节点结构包含以下几个关键部分：</p>
<ul>
<li><strong>元素值（ele）</strong>：存储节点的值，通常是一个字符串（sds类型）。</li>
<li><strong>分数（score）</strong>：存储节点的分数，用于排序，通常是一个双精度浮点数（double类型）。</li>
<li><strong>后向指针（backward）</strong>：指向前一个节点，方便从跳表的尾节点开始访问，倒序查找时方便。</li>
<li><strong>层级数组（level[]）</strong>：包含多个层级的信息，每个层级包含两个信息：<ul>
<li><strong>前向节点指针（forward）</strong>：指向当前层级的下一个节点。</li>
<li><strong>跨度（span）</strong>：表示当前节点到下一个节点之间的跨度，用于计算节点的排名。</li>
</ul>
</li>
</ul>
<p>以下是跳表节点的C语言数据结构示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;  <span class="comment">// 元素值</span></span><br><span class="line">    <span class="type">double</span> score;  <span class="comment">// 分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>  <span class="comment">// 后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">// 前向节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;  <span class="comment">// 跨度</span></span><br><span class="line">    &#125; level[];  <span class="comment">// 层级数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>跟我的刚开始想象不同的是，在跳表中，跨度（Span）并<strong>不是固定的步长</strong>，而是表示当前节点到下一个节点之间的<strong>“距离”</strong>。跨度可以是1，也可以是2，不必与上一个节点同层级的跨度一致。跨度的主要作用是帮助计算节点的排名（rank），而不是用于遍历操作。遍历操作只需要通过链表的前向指针（forward）来实现。在这里继续引用小林哥的模拟图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409272144039.png" alt="zset多层级示意图" style="zoom: 80%;">

<p>Redis跳表在创建节点时，随机生成每个节点的层数，并没有严格维持相邻两层的节点数量比例为2:1的情况。具体的做法是，跳表在创建节点时，会生成一个范围是[0, 1]的随机数，并根据这个随机数来决定节点的层数。如果随机数小于0.25（选取0.25基于概率和性能考虑），则增加一层，然后生成下一个随机数，直到随机数大于0.25结束。最后，层数越高，概率越低，最高不会超过<strong>64</strong>层。</p>
<h3 id="Redis-为啥使用跳表而不是B-树？"><a href="#Redis-为啥使用跳表而不是B-树？" class="headerlink" title="Redis 为啥使用跳表而不是B+树？"></a>Redis 为啥使用跳表而不是B+树？</h3><p>Redis选择跳表（Skip List）而不是B+树（B+ Tree）作为有序集合（Zset）的底层数据结构，主要是基于以下几个方面的考虑：内存占用、对范围查找的支持、实现难易程度。</p>
<ol>
<li>内存占用更少</li>
</ol>
<ul>
<li><strong>B+树</strong>：每个节点通常包含两个指针（至少），一个指向左子节点，一个指向右子节点。此外，B+树的叶子节点还需要存储数据，这会占用更多的内存。</li>
<li><strong>跳表</strong>：跳表的节点包含一个前向指针和一个跨度（span），平均每个节点包含约1.33个指针（概率期望值，p &#x3D; 0.25）。由于跳表的层数是随机生成的，高层级的节点数量较少，因此总体内存占用较少。</li>
</ul>
<ol start="2">
<li>范围查询更简单</li>
</ol>
<ul>
<li><strong>B+树</strong>：B+树的范围查询需要从根节点开始遍历，找到范围的起始节点，然后沿着叶子节点链表遍历到范围的结束节点。这个过程相对复杂，尤其是在范围较大时。</li>
<li><strong>跳表</strong>：跳表的范围查询非常简单。只需要从最高层级开始，逐级向下查找，直到找到范围的起始节点，然后沿着链表遍历到范围的结束节点。由于跳表的层级结构，范围查询的效率非常高。</li>
</ul>
<ol start="3">
<li>算法实现难度更简单</li>
</ol>
<ul>
<li><strong>B+树</strong>：B+树的实现相对复杂，需要维护平衡性，插入和删除操作需要进行复杂的旋转和分裂操作，以保持树的平衡。</li>
<li><strong>跳表</strong>：跳表的实现相对简单，插入和删除操作只需要更新指针，不需要进行复杂的平衡操作。跳表的层数是随机生成的，不需要严格维持平衡性，因此实现难度较低。</li>
</ul>
<h2 id="压缩列表实现"><a href="#压缩列表实现" class="headerlink" title="压缩列表实现"></a>压缩列表实现</h2><p>压缩列表（ziplist）是Redis为优化内存使用而设计的一种紧凑的顺序存储结构，类似于数组。它通过一系列精心设计的字段来高效地存储和访问数据，特别适用于存储少量数据。</p>
<h3 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h3><p>压缩列表包含以下几个关键字段：</p>
<ul>
<li><strong>zlbytes</strong>：记录当前压缩列表总共占用的字节数。这个字段帮助快速计算列表的总大小，无需遍历整个列表。</li>
<li><strong>zltail</strong>：记录最后一个节点相对于头节点的偏移量。通过这个字段，可以快速定位到最后一个节点，而不需要从头遍历整个列表。</li>
<li><strong>zllen</strong>：记录当前压缩列表中节点的数量。这个字段帮助快速获取列表的长度。</li>
<li><strong>zlend</strong>：表示压缩列表的结束位置，通常值为0xff（即十进制的255）。这个字段用于标识列表的结束，类似于C语言中的空字符（’\0’）。</li>
</ul>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>在压缩列表中，查找第一个和最后一个元素非常高效，时间复杂度为O(1)。具体来说：</p>
<ul>
<li><strong>查找第一个元素</strong>：直接从列表头开始，时间复杂度为O(1)。</li>
<li><strong>查找最后一个元素</strong>：通过<code>zltail</code>字段可以直接计算出最后一个节点的位置，时间复杂度也为O(1)。</li>
</ul>
<p>然而，查找其他元素则需要遍历列表，时间复杂度为O(n)，其中n是列表中节点的数量。因此，压缩列表并不适合存储大量数据，更适合用于存储少量、频繁访问的数据。</p>
<h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><p>压缩列表中的每个节点包含以下三个部分：</p>
<ul>
<li><strong>prevlen</strong>：记录前一个节点的长度。这个字段使得从后向前遍历列表成为可能，因为可以通过<code>prevlen</code>快速定位到前一个节点。</li>
<li><strong>encoding</strong>：记录当前节点实际数据的类型和长度。Redis支持两种主要的数据类型：字符串和整数。<code>encoding</code>字段根据数据类型和大小动态调整，以节省内存。</li>
<li><strong>data</strong>：记录当前节点的实际数据。根据<code>encoding</code>字段的不同，<code>data</code>部分可以是字符串或整数。</li>
</ul>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>当向压缩列表插入数据时，Redis会根据插入数据的类型和大小动态调整<code>prevlen</code>和<code>encoding</code>字段的空间占用。例如：</p>
<ul>
<li>如果插入的是一个较小的整数，<code>encoding</code>字段可能会使用较少的字节来表示这个整数。</li>
<li>如果插入的是一个较长的字符串，<code>encoding</code>字段可能会使用更多的字节来表示字符串的长度。</li>
</ul>
<p>这种根据数据类型和大小进行动态空间分配的设计思想，正是Redis为了节省内存而采用的核心策略。</p>
<h3 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h3><p>压缩列表的缺点是会发生<strong>“连锁更新”</strong>问题，因为连锁更新一旦发生，就会导致压缩列表多次重新分配分配，从而影响直接压缩列表的访问性能。</p>
<p>为什么会发生连锁更新问题？因为当插入或删除节点时，如果前一个节点的长度发生变化，可能会导致后续节点的<code>prevlen</code>字段需要更新，从而引发连锁更新。</p>
<ul>
<li>在压缩列表中，<code>prevlen</code>字段的长度是动态的，根据前一个节点的长度来决定。例如，如果前一个节点的长度小于254字节，<code>prevlen</code>字段占用1字节；如果大于等于254字节，<code>prevlen</code>字段占用5字节。</li>
</ul>
<h2 id="Listpack实现"><a href="#Listpack实现" class="headerlink" title="Listpack实现"></a>Listpack实现</h2><p>尽管<code>quicklist</code>通过控制<code>quicklistnode</code>中元素的大小和数量来缓解压缩列表（ziplist）的性能问题，但它并未完全解决压缩列表中存在的“连锁更新”问题。为了进一步优化，Redis在5.0版本中引入了一个新的数据结构——<code>listpack</code>。</p>
<h3 id="Listpack的特点"><a href="#Listpack的特点" class="headerlink" title="Listpack的特点"></a>Listpack的特点</h3><p><code>listpack</code>最大的特点是每个节点不再包含前一个节点的长度信息。这一设计从根本上消除了“连锁更新”问题，从而提高了数据结构的稳定性和性能。</p>
<h3 id="Listpack的头部信息"><a href="#Listpack的头部信息" class="headerlink" title="Listpack的头部信息"></a>Listpack的头部信息</h3><p><code>listpack</code>的头部包含两个关键数据：</p>
<ul>
<li><strong>listpack总字节数</strong>：记录整个<code>listpack</code>结构占用的总字节数。这个字段帮助快速计算<code>listpack</code>的大小，无需遍历整个结构。</li>
<li><strong>listpack元素数量</strong>：记录<code>listpack</code>中包含的元素数量。这个字段帮助快速获取<code>listpack</code>的长度。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409280938820.png" alt="listpack结构示意"></p>
<h3 id="Listpack节点的结构"><a href="#Listpack节点的结构" class="headerlink" title="Listpack节点的结构"></a>Listpack节点的结构</h3><p><code>listpack</code>中的每个节点包含以下三个部分：</p>
<ul>
<li><strong>encoding</strong>：定义该元素的编码类型。<code>encoding</code>字段根据数据类型和大小动态调整，以节省内存。例如，如果数据是一个小整数，<code>encoding</code>字段可能会使用较少的字节来表示这个整数。</li>
<li><strong>data</strong>：实际存放的数据。根据<code>encoding</code>字段的不同，<code>data</code>部分可以是字符串或整数。</li>
<li><strong>len</strong>：<code>encoding</code>和<code>data</code>的总长度。这个字段记录了当前节点的总字节数，帮助快速计算节点的长度。</li>
</ul>
<p>假设我们有一个<code>listpack</code>，其中存储了三个节点：</p>
<ol>
<li>第一个节点存储了一个整数<code>123</code>。</li>
<li>第二个节点存储了一个字符串<code>&quot;hello&quot;</code>。</li>
<li>第三个节点存储了一个整数<code>456</code>。</li>
</ol>
<p>在这种情况下，<code>listpack</code>的头部会记录整个<code>listpack</code>的总字节数和元素数量。每个节点的<code>encoding</code>字段会根据数据类型（整数或字符串）和数据大小动态调整，而<code>len</code>字段会记录当前节点的总字节数。</p>
<p>例如：</p>
<ul>
<li>第一个节点的<code>encoding</code>可能是<code>0x01</code>（表示一个小整数），<code>data</code>是<code>123</code>，<code>len</code>可能是<code>2</code>字节。</li>
<li>第二个节点的<code>encoding</code>可能是<code>0x02</code>（表示一个字符串），<code>data</code>是<code>&quot;hello&quot;</code>，<code>len</code>可能是<code>7</code>字节。</li>
<li>第三个节点的<code>encoding</code>可能是<code>0x01</code>（表示一个小整数），<code>data</code>是<code>456</code>，<code>len</code>可能是<code>2</code>字节。</li>
</ul>
<p>通过这种设计，<code>listpack</code>在存储数据时更加紧凑和高效，同时避免了压缩列表中“连锁更新”的问题（因为已经不会影响其他节点长度字段的变化），从而提高了整体性能和稳定性。</p>
<h2 id="Hash表扩容"><a href="#Hash表扩容" class="headerlink" title="Hash表扩容"></a>Hash表扩容</h2><p>在Redis中，Hash表的扩容（rehash）是一个关键操作，用于处理Hash表在数据量增加时可能出现的性能问题。然而，传统的rehash过程可能会导致性能瓶颈，特别是在Hash表中数据量非常大的情况下。为了解决这个问题，Redis采用了渐进式rehash机制。</p>
<h3 id="传统rehash的问题"><a href="#传统rehash的问题" class="headerlink" title="传统rehash的问题"></a>传统rehash的问题</h3><p>在传统的rehash过程中，需要使用两个Hash表：</p>
<ol>
<li><strong>Hash表1</strong>：当前正在使用的Hash表。</li>
<li><strong>Hash表2</strong>：新建的Hash表，空间大小通常是Hash表1的两倍。</li>
</ol>
<p>传统rehash的步骤如下：</p>
<ol>
<li><strong>分配空间</strong>：为Hash表2分配空间。</li>
<li><strong>数据迁移</strong>：将Hash表1中的所有数据重新分配到Hash表2中。</li>
<li><strong>释放空间</strong>：数据迁移完成后，释放Hash表1的空间，并将Hash表2设置为当前使用的Hash表。</li>
</ol>
<p>这种一次性完成数据迁移的方式存在以下问题：</p>
<ul>
<li><strong>性能影响</strong>：如果Hash表1中的数据量非常大，数据迁移过程需要大量复制操作，可能导致Redis阻塞，影响性能。</li>
<li><strong>阻塞风险</strong>：在数据迁移期间，Redis无法处理其他请求，可能导致服务中断。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281016047.png" alt="Redis中Hash扩容(图片来源小林coding)">

<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>为了避免上述问题，Redis采用了渐进式rehash机制。渐进式rehash的核心思想是将数据迁移过程分散到多次操作中，而不是一次性完成。</p>
<h4 id="渐进式rehash的步骤"><a href="#渐进式rehash的步骤" class="headerlink" title="渐进式rehash的步骤"></a>渐进式rehash的步骤</h4><ol>
<li><strong>分配空间</strong>：为Hash表2分配空间。</li>
<li><strong>逐步迁移</strong>：在rehash期间，每次对Hash表进行增删改查操作时，Redis除了执行这些操作，还会顺序地将索引位置上的所有key-value迁移到Hash表2中。</li>
<li><strong>完成迁移</strong>：随着处理客户端发起的Hash表操作越来越多，最终某个时间点会将Hash表1中的所有key-value迁移到Hash表2中，完成rehash操作。</li>
</ol>
<h4 id="渐进式rehash的优势"><a href="#渐进式rehash的优势" class="headerlink" title="渐进式rehash的优势"></a>渐进式rehash的优势</h4><ul>
<li><strong>避免阻塞</strong>：通过将数据迁移分散到多次操作中，避免了在rehash过程中Redis的阻塞，提高了系统的可用性。</li>
<li><strong>平滑过渡</strong>：渐进式rehash使得Hash表的扩容过程更加平滑，减少了性能波动。</li>
</ul>
<h3 id="渐进式rehash期间的Hash表操作"><a href="#渐进式rehash期间的Hash表操作" class="headerlink" title="渐进式rehash期间的Hash表操作"></a>渐进式rehash期间的Hash表操作</h3><p>在渐进式rehash进行期间，Redis会同时维护两个Hash表（Hash表1和Hash表2）。因此，Hash表的删除、查找、更新等操作会在两个Hash表中进行：</p>
<ul>
<li><strong>查找操作：先在Hash表1中查找，如果没找到，再在Hash表2中查找。</strong></li>
<li><strong>新增操作：新增的key-value会被保存到Hash表2中，而Hash表1不再进行任何添加操作。</strong></li>
<li><strong>删除和更新操作：同样会在两个Hash表中进行查找和操作。</strong></li>
</ul>
<p>随着渐进式rehash的进行，Hash表1的key-value数量会逐渐减少，最终变为空表。当所有数据都迁移到Hash表2后，Hash表1会被释放，Hash表2成为当前使用的Hash表。</p>
<p>假设我们有一个Hash表1，其中包含100万个key-value对。当Hash表1需要扩容时，Redis会执行以下步骤：</p>
<ol>
<li><strong>分配空间</strong>：为Hash表2分配空间，大小为Hash表1的两倍。</li>
<li><strong>逐步迁移</strong>：在每次对Hash表进行操作时，Redis会逐步将Hash表1中的数据迁移到Hash表2中。例如，每次操作时迁移1000个key-value对。</li>
<li><strong>完成迁移</strong>：随着操作的进行，最终所有数据都会迁移到Hash表2中。</li>
</ol>
<p>通过这种方式，Redis避免了在rehash过程中可能出现的性能瓶颈和阻塞问题，确保了系统的稳定性和性能。</p>
<h2 id="String存储"><a href="#String存储" class="headerlink" title="String存储"></a>String存储</h2><p>在Redis中，String类型的数据是通过SDS（Simple Dynamic String）数据结构来存储的。SDS是Redis自己实现的一种字符串表示方式，相较于C语言中的字符数组（char[]），SDS提供了更多的功能和优势。</p>
<h3 id="SDS的结构"><a href="#SDS的结构" class="headerlink" title="SDS的结构"></a>SDS的结构</h3><p>SDS的结构中包含以下几个成员变量：</p>
<ul>
<li><strong>len</strong>：记录了字符串的实际长度。这个字段使得获取字符串长度的时间复杂度为O(1)，因为可以直接从<code>len</code>属性读取，而不需要像C语言中的<code>strlen</code>函数那样遍历整个字符数组。</li>
<li><strong>alloc</strong>：分配给字符串的空间数组长度。这个字段记录了当前SDS结构中为字符数组分配的总空间大小，用于管理内存分配和释放。</li>
<li><strong>flags</strong>：用来表示不同类型的SDS。SDS有多种类型，<code>flags</code>字段用于区分这些类型，以便在不同情况下进行不同的处理。</li>
<li>**buf[]**：字符数组，用来保存实际的字符串数据。这个字段存储了字符串的内容。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281042500.png" alt="SDS数据结构示意图" style="zoom:67%;">

<h3 id="SDS的优势"><a href="#SDS的优势" class="headerlink" title="SDS的优势"></a>SDS的优势</h3><p>相较于C语言的字符数组，SDS具备以下优势：</p>
<ol>
<li><p><strong>O(1)的获取长度时间复杂度</strong>：</p>
<ul>
<li>在C语言中，获取字符串长度需要调用<code>strlen</code>函数，该函数需要遍历整个字符数组，时间复杂度为O(n)。</li>
<li>在SDS中，字符串的长度直接存储在<code>len</code>字段中，获取长度的时间复杂度为O(1)，极大地提高了性能。</li>
</ul>
</li>
<li><p><strong>二进制安全</strong>：</p>
<ul>
<li>C语言的字符串以空字符（’\0’）作为字符串的结束标志，这使得C语言字符串不能存储包含空字符的二进制数据。</li>
<li>SDS使用<code>len</code>字段来表示字符串的长度，因此不需要以空字符作为结束标志，可以安全地存储任意二进制数据。</li>
</ul>
</li>
<li><p><strong>避免缓冲区溢出</strong>：</p>
<ul>
<li>在C语言中，如果字符串操作不当，可能会导致缓冲区溢出，即写入的数据超出了分配的内存空间，导致程序崩溃或安全漏洞。</li>
<li>SDS通过<code>alloc</code>字段记录分配的内存空间大小，并在字符串操作时检查是否超出分配的空间，从而避免了缓冲区溢出的问题。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个字符串<code>&quot;hello&quot;</code>，在C语言中，它通常表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在SDS中，这个字符串的表示方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;   <span class="comment">// 字符串长度，值为5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc; <span class="comment">// 分配的空间大小，假设为10</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">// SDS类型标志，假设为0</span></span><br><span class="line">    <span class="type">char</span> buf[];         <span class="comment">// 字符数组，存储&quot;hello&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>len</code>字段的值为5，表示字符串<code>&quot;hello&quot;</code>的长度。</li>
<li><code>alloc</code>字段的值为10，表示为字符数组分配了10个字节的内存空间。</li>
<li><code>flags</code>字段的值为0，表示这是一个基本的SDS类型。</li>
<li><code>buf[]</code>字段存储了字符串<code>&quot;hello&quot;</code>的实际内容。</li>
</ul>
<p>通过这种方式，SDS不仅提供了高效的性能，还解决了C语言字符串的一些常见问题，如缓冲区溢出和二进制不安全等。</p>
<h1 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h1><h2 id="Redis为什么快？"><a href="#Redis为什么快？" class="headerlink" title="Redis为什么快？"></a>Redis为什么快？</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281051071.png" alt="Redis基准测试" style="zoom:80%;">

<p>Redis以其极高的性能而闻名，官方基准测试结果显示，单线程的Redis吞吐量可以达到每秒10万次操作（100,000 ops&#x2F;s）。Redis之所以能够实现如此高的性能，主要有以下几个原因：</p>
<ol>
<li><strong>内存操作</strong></li>
</ol>
<p>Redis的大部分操作都是在内存中完成的。内存的访问速度远远快于磁盘I&#x2F;O，因此数据操作的性能瓶颈通常不在于CPU，而在于数据的I&#x2F;O操作。Redis基于内存操作，将性能瓶颈从磁盘I&#x2F;O转移到了内存和网络传输上。此外，Redis还采用了高性能的数据结构，如哈希表、跳表等，进一步提升了操作效率。</p>
<ol start="2">
<li><strong>单线程模型</strong></li>
</ol>
<p>Redis采用单线程模型来处理网络I&#x2F;O和请求数据。单线程模型有以下几个优势：</p>
<ul>
<li><strong>避免线程竞争</strong>：多线程程序中，线程间的竞争和同步开销较大。单线程模型避免了线程间的竞争问题，减少了线程切换的开销。</li>
<li><strong>简化设计</strong>：单线程模型简化了程序设计，避免了复杂的线程同步和锁机制，降低了出错的概率。</li>
</ul>
<ol start="3">
<li><strong>I&#x2F;O多路复用机制</strong></li>
</ol>
<p>Redis采用I&#x2F;O多路复用机制来处理大量的客户端socket请求。I&#x2F;O多路复用机制允许一个线程同时处理多个I&#x2F;O流，具体来说：</p>
<ul>
<li><strong>内核监听</strong>：在Redis单线程的情况下，I&#x2F;O多路复用机制允许内核同时监听多个socket上的连接请求和数据请求。</li>
<li><strong>请求处理</strong>：一旦有请求到达，内核会将请求交给Redis线程处理，从而实现了一个Redis线程处理多个I&#x2F;O流的效果。</li>
</ul>
<ol start="4">
<li><strong>高效的数据结构</strong></li>
</ol>
<p>Redis内部使用了多种高效的数据结构，如哈希表、跳表、压缩列表等。这些数据结构在内存中操作时，能够提供高效的插入、删除和查找操作，进一步提升了Redis的性能。</p>
<h2 id="Redis对多线程的使用"><a href="#Redis对多线程的使用" class="headerlink" title="Redis对多线程的使用"></a>Redis对多线程的使用</h2><p>Redis的单线程模型指的是“接收客户端请求 -&gt; 解析客户端请求 -&gt; 进行数据操作 -&gt; 返回数据给客户端”这个过程由一个主线程完成。</p>
<p>虽然Redis在处理客户端请求时采用单线程模型，但这并不意味着Redis程序本身是单线程的。实际上，Redis在启动时会启动多个后台线程（BIO，Background I&#x2F;O）来处理一些耗时的任务，从而避免这些任务占用主线程的资源，影响Redis的性能。</p>
<ul>
<li>在Redis2.6，后台会启动线程分别完成关闭文件和AOF刷盘任务；</li>
<li>在Redis4.0版本后，新增了一个线程用于异步释放内存操作，也就是lazyfree。例如，执行unlink key &#x2F; flushdb async &#x2F; flushall async等命令，异步释放内存，这样的好处是不占用主线程。</li>
</ul>
<p>将这些“关闭文件”、“AOF算盘”、“释放空间”任务交由创建的独立线程完成，能够极大地提升Redis的处理效率，因为这些操作都是极为耗时的，若由主线程完成可能会造成阻塞，同时也没法处理其他socket请求了，严重影响了Redis的性能。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281141887.png" alt="Redis BIO(图片来源小林coding)" style="zoom:80%;">

<p>虽然Redis的主要工作（网络I&#x2F;O和执行命令）一直是单线程模型，但在Redis 6.0版本也引入了多个线程来处理网络I&#x2F;O请求。这是因为随着网络硬件性能的提升，Redis的性能瓶颈有时候会出现在处理网络I&#x2F;O上。</p>
<p><strong>多线程网络I&#x2F;O的优势</strong></p>
<ul>
<li><strong>提升网络I&#x2F;O并行度</strong>：通过引入多线程处理网络I&#x2F;O请求，Redis能够更高效地处理大量的并发连接和数据传输，从而提升整体的性能。</li>
<li><strong>不影响命令执行</strong>：尽管引入了多线程处理网络I&#x2F;O，<strong>但对于执行命令，Redis仍然采用单线程模型</strong>。这种设计确保了命令执行的顺序性和一致性，避免了多线程带来的复杂性和潜在的竞争问题。</li>
</ul>
<h2 id="Redis如何实现IO多路复用"><a href="#Redis如何实现IO多路复用" class="headerlink" title="Redis如何实现IO多路复用"></a>Redis如何实现IO多路复用</h2><p>Redis采用单线程模型来执行命令，这意味着所有的任务都按照顺序执行。然而，由于输入输出（I&#x2F;O）操作是阻塞的，如果一个文件的I&#x2F;O操作阻塞，整个进程将无法为其他客户端提供服务。为了解决这个问题，Redis采用了I&#x2F;O多路复用技术。</p>
<h3 id="I-O多路复用的概念"><a href="#I-O多路复用的概念" class="headerlink" title="I&#x2F;O多路复用的概念"></a>I&#x2F;O多路复用的概念</h3><p>I&#x2F;O多路复用（I&#x2F;O Multiplexing）是一种允许单个线程同时监视多个文件描述符（如socket）的技术。通过这种技术，单个线程可以检查多个socket的I&#x2F;O就绪状态，从而在单个线程中处理多个I&#x2F;O流。</p>
<h3 id="Redis中的I-O多路复用"><a href="#Redis中的I-O多路复用" class="headerlink" title="Redis中的I&#x2F;O多路复用"></a>Redis中的I&#x2F;O多路复用</h3><p>在Redis中，I&#x2F;O多路复用主要用于处理多个客户端连接的网络I&#x2F;O操作。Redis使用了一种称为<code>epoll</code>的机制来实现I&#x2F;O多路复用。<code>epoll</code>是Linux系统中的一种高效的I&#x2F;O多路复用技术，能够显著提高Redis在高并发环境下的性能。其模型参考一张网络来源图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281246104.png" alt="Redis I/O多路复用" style="zoom: 67%;">

<ol>
<li><strong>监听多个socket</strong>：Redis主线程会监听多个客户端连接的socket。每个socket代表一个客户端连接。</li>
<li><strong>事件通知</strong>：当某个socket上有数据到达（如客户端发送请求），<code>epoll</code>机制会通知Redis主线程。</li>
<li><strong>处理事件</strong>：Redis主线程接收到事件通知后，会处理该socket上的请求，执行相应的命令，并将结果返回给客户端。<strong>epoll机制使用非阻塞I&#x2F;O操作。当某个文件描述符上的I&#x2F;O操作无法立即完成时，I&#x2F;O多路复用机制会立即返回，并继续监听其他文件描述符上的事件。</strong></li>
<li><strong>继续监听</strong>：处理完一个事件后，Redis主线程继续监听其他socket，等待下一个事件的到来。</li>
</ol>
<p>假设我们有一个Redis服务器，它需要处理多个客户端的请求。在传统的阻塞I&#x2F;O模型中，每个客户端连接都需要一个独立的线程来处理，这会导致线程数量过多，资源消耗大。而在Redis的I&#x2F;O多路复用模型中，所有客户端连接的socket都由一个主线程监听和处理。</p>
<p>例如，当客户端A发送一个请求时，<code>epoll</code>机制会通知Redis主线程处理该请求；同时，客户端B的请求也会被<code>epoll</code>监听到，并交给Redis主线程处理。通过这种方式，Redis能够高效地处理大量的并发请求，而不会因为线程切换和竞争导致性能下降。</p>
<p>Redis通过采用I&#x2F;O多路复用技术，实现了在单个线程中高效处理多个客户端连接的请求。这种设计使得Redis能够在高并发环境下提供极高的性能，同时确保系统的稳定性和响应速度。通过<code>epoll</code>机制，Redis能够监听多个socket，并在事件发生时及时处理，避免了传统阻塞I&#x2F;O模型中的性能瓶颈。</p>
<h2 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h2><p>Redis在6.0版本之前，采用的是单Reactor单线程模型。这种模型虽然简单，但在高并发环境下存在一些性能瓶颈。为了进一步提升性能，Redis在6.0版本引入了多线程处理网络I&#x2F;O，但<strong>命令的执行仍然保持单线程模式</strong>。</p>
<h3 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h3><p>在Redis 6.0之前，Redis采用的是单Reactor单线程模型。缺点：</p>
<ul>
<li><strong>无法充分利用多核CPU</strong>：单线程模型无法充分利用多核CPU的计算能力，限制了Redis在高并发环境下的性能。</li>
<li><strong>业务处理延时</strong>：在进行业务处理时，无法执行其他连接的事件。如果业务处理时间较长，会造成较大的延时，影响系统的响应速度。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281311664.png" alt="单Reactor" style="zoom:80%;">

<h3 id="Redis-6-0的多线程网络I-O"><a href="#Redis-6-0的多线程网络I-O" class="headerlink" title="Redis 6.0的多线程网络I&#x2F;O"></a>Redis 6.0的多线程网络I&#x2F;O</h3><p>为了解决单Reactor单线程模型的性能瓶颈，Redis在6.0版本引入了多线程处理网络I&#x2F;O。具体来说：</p>
<ul>
<li><strong>多线程处理网络I&#x2F;O</strong>：Redis 6.0将网络I&#x2F;O操作从主线程中分离出来，使用多个线程来处理网络I&#x2F;O请求，从而提高网络I&#x2F;O的并行度和处理效率。</li>
<li><strong>单线程执行命令</strong>：尽管网络I&#x2F;O采用了多线程处理，但对于命令的执行，Redis仍然保持单线程模式。这种设计确保了命令执行的顺序性和一致性，避免了多线程带来的复杂性和潜在的竞争问题。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li><strong>提升网络I&#x2F;O并行度</strong>：通过多线程处理网络I&#x2F;O，Redis能够更高效地处理大量的并发连接和数据传输，从而提升整体的性能。</li>
<li><strong>不影响命令执行</strong>：尽管引入了多线程处理网络I&#x2F;O，但对于命令的执行，Redis仍然采用单线程模型。这种设计确保了命令执行的顺序性和一致性，避免了多线程带来的复杂性和潜在的竞争问题。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281311428.png" alt="多线程Reactor" style="zoom:80%;">

<p>假设我们有一个Redis服务器，它需要处理大量的客户端请求。在Redis 6.0之前，所有的网络I&#x2F;O和命令执行都在一个主线程中进行。如果某个客户端的请求处理时间较长，会导致主线程阻塞，无法处理其他客户端的请求。</p>
<p>在Redis 6.0中，网络I&#x2F;O操作被分离出来，由多个线程处理。例如，当客户端A发送一个请求时，网络I&#x2F;O线程会处理该请求的读取和写入操作；同时，客户端B的请求也会被其他网络I&#x2F;O线程处理。这样，即使某个客户端的请求处理时间较长，也不会影响其他客户端的请求处理。</p>
<p>Redis在6.0版本之前采用单Reactor单线程模型，虽然简单，但在高并发环境下存在性能瓶颈。为了进一步提升性能，Redis在6.0版本引入了多线程处理网络I&#x2F;O，但命令的执行仍然保持单线程模式。这种设计使得Redis能够在高并发环境下提供极高的性能，同时确保系统的稳定性和响应速度。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">xiaoyan</div><div class="post-copyright__author_desc">无限进步。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/')">Redis-数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Redis-数据结构&amp;url=http://example.com/2024/09/27/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/&amp;pic=https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409271934547.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">XIAOYAN</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>数据库&amp;缓存<span class="categoryesPageCount">12</span></a><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BC%93%E5%AD%98/Redis/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Redis<span class="categoryesPageCount">5</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据结构<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>线程模型<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/25/DDD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DDD架构设计</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/27/Redis-%E4%BA%8B%E5%8A%A1%E4%B8%8E%E6%97%A5%E5%BF%97/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409281555558.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis-事务与日志</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">是一只时时翻垃圾吃的宅子。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">xiaoyan</h1><div class="author-info__desc">无限进步。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoyanfufu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/483597064" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">Redis底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据类型与底层结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Zset实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BA%86%E8%A7%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Zset"><span class="toc-number">1.2.2.</span> <span class="toc-text">如何使用Zset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">跳表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E4%B8%BA%E5%95%A5%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AFB-%E6%A0%91%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">Redis 为啥使用跳表而不是B+树？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">压缩列表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">主要字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.2.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">节点结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.4.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.</span> <span class="toc-text">连锁更新问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Listpack%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">Listpack实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Listpack%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">Listpack的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Listpack%E7%9A%84%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">Listpack的头部信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Listpack%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">Listpack节点的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E8%A1%A8%E6%89%A9%E5%AE%B9"><span class="toc-number">1.6.</span> <span class="toc-text">Hash表扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9Frehash%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">传统rehash的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.6.2.</span> <span class="toc-text">渐进式rehash</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">渐进式rehash的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">渐进式rehash的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash%E6%9C%9F%E9%97%B4%E7%9A%84Hash%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">渐进式rehash期间的Hash表操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.</span> <span class="toc-text">String存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">SDS的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.7.2.</span> <span class="toc-text">SDS的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Redis为什么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">Redis对多线程的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">Redis如何实现IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">I&#x2F;O多路复用的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%AD%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">Redis中的I&#x2F;O多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">Redis网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">单Reactor单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-6-0%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9CI-O"><span class="toc-number">2.4.2.</span> <span class="toc-text">Redis 6.0的多线程网络I&#x2F;O</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-分库分表"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表">数据库优化-分库分表</a><time datetime="2024-11-03T08:20:54.000Z" title="发表于 2024-11-03 16:20:54">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202411041125092.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-读写分离与冷热分离"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离">数据库优化-读写分离与冷热分离</a><time datetime="2024-11-03T08:18:25.000Z" title="发表于 2024-11-03 16:18:25">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410282316960.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-进程管理"/></a><div class="content"><a class="title" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理">操作系统-进程管理</a><time datetime="2024-10-28T14:52:35.000Z" title="发表于 2024-10-28 22:52:35">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410281041645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式事务"/></a><div class="content"><a class="title" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务">分布式-分布式事务</a><time datetime="2024-10-27T13:08:20.000Z" title="发表于 2024-10-27 21:08:20">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410272103963.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-服务治理（下）"/></a><div class="content"><a class="title" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）">分布式-服务治理（下）</a><time datetime="2024-10-21T07:24:49.000Z" title="发表于 2024-10-21 15:24:49">2024-10-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="xiaoyan" target="_blank">xiaoyan</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">17</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 0.88rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 0.88rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 0.88rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 0.88rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 0.88rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 0.88rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 0.88rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 0.88rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 0.88rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 0.88rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 0.88rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 0.88rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 0.88rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 0.88rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>