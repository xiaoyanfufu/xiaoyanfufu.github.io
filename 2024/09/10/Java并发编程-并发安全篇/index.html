<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java并发编程-并发安全篇 | XIAOYAN</title><meta name="keywords" content="并发安全"><meta name="author" content="xiaoyan"><meta name="copyright" content="xiaoyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java并发编程-并发安全篇"><meta name="application-name" content="Java并发编程-并发安全篇"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java并发编程-并发安全篇"><meta property="og:url" content="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/index.html"><meta property="og:site_name" content="XIAOYAN"><meta property="og:description" content="Java提供了多种机制来保证线程安全，包括内置锁、显式锁、原子类、线程局部变量和并发集合等。本文将深入探讨Java中的并发安全机制，涵盖线程同步、锁机制、原子操作、线程局部变量以及并发集合等内容。   如何保证多线程安全在 Java 中，保证多线程安全主要有以下几种方式： 1.synchronize"><meta property="og:locale" content="zn-CN"><meta property="og:image" content="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/cover.png"><meta property="article:author" content="xiaoyan"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/cover.png"><meta name="description" content="Java提供了多种机制来保证线程安全，包括内置锁、显式锁、原子类、线程局部变量和并发集合等。本文将深入探讨Java中的并发安全机制，涵盖线程同步、锁机制、原子操作、线程局部变量以及并发集合等内容。   如何保证多线程安全在 Java 中，保证多线程安全主要有以下几种方式： 1.synchronize"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: xiaoyan","link":"链接: ","source":"来源: XIAOYAN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XIAOYAN',
  title: 'Java并发编程-并发安全篇',
  postAI: '',
  pageFillDescription: '如何保证多线程安全, Java 中常用的锁及其使用场景, 什么是可重入锁, 可重入锁的工作原理, synchronized 和 ReentrantLock 的区别, synchronized 工作原理, ReentrantLock 工作原理, 区别, synchronized 锁升级过程, 锁升级过程, 锁升级的触发条件, AQS, AQS 的核心思想, CLH 队列, AQS 的核心组成部分, AQS 的工作原理, ThreadLocal 详解, ThreadLocal 的作用, ThreadLocal 的原理, 核心操作, 可能存在的问题, 内存泄漏问题, 乐观锁x2F悲观锁, Java 实现乐观锁的方式, CAS 的缺点, volatile, 保证变量对所有线程的可见性, 禁止指令重排序优化, volatile 不能完全保证线程安全, 保证线程安全的解决方案, 指令重排的原理, 指令重排的原则, 指令重排的类型, 指令重排的示例, 指令重排的影响, 公平锁与非公平锁, 公平锁, 非公平锁, 对比提供了多种机制来保证线程安全包括内置锁显式锁原子类线程局部变量和并发集合等本文将深入探讨中的并发安全机制涵盖线程同步锁机制原子操作线程局部变量以及并发集合等内容如何保证多线程安全在中保证多线程安全主要有以下几种方式关键字使用关键字来同步代码块或方法确保同一时刻只有一个线程能访问这些代码优点简单易用适用于简单的同步需求缺点可能会导致性能问题特别是在高并发场景下可能会导致死锁关键字使用关键字确保所有的线程都能看到该变量的最新值而不是可能存储在本地寄存器中的副本优点确保变量的可见性适用于简单的状态标志缺点不能保证复合操作的原子性如接口和类使用接口和类来实现更灵活的锁机制优点提供更灵活的锁机制支持可中断锁公平锁等缺点需要手动管理锁的获取和释放容易出错原子类并发库提供了原子类这些类提供原子操作可以用来更新基本数据类型而无需同步优点提供原子操作无需手动同步缺点仅适用于基本数据类型的原子操作线程局部变量可以为每个线程创建独立的副本这样每个副本都拥有自己的变量消除竞争条件优点每个线程拥有独立的变量副本消除竞争条件缺点可能会导致内存泄漏特别是在线程池中使用时并发集合包中提供了线程安全的集合已实现线程安全逻辑优点提供线程安全的集合操作无需手动同步缺点可能会导致性能问题特别是在高并发场景下中常用的锁及其使用场景在中锁是用于管理多线程并发访问共享资源的关键机制锁可以确保在任意给定时间内只有一个线程可以访问特定的资源从而避免数据竞争和不一致性提供了多种锁机制以下是常用的锁及其使用场景内置锁关键字是内置的锁机制可以用于方法或代码块当一个线程进入代码块或方法时它会获取关联对象的锁当线程离开该代码块或方法时锁会被释放优点简单易用适用于简单的同步需求缺点可能会导致性能问题特别是在高并发场景下可能会导致死锁使用场景适用于简单的同步需求如单个对象的同步访问示例代码是一个显式的锁类提供了比更高级的功能如可中断的锁等待定时锁等待公平锁选项等优点提供更灵活的锁机制支持可中断锁公平锁等缺点需要手动管理锁的获取和释放容易出错使用场景适用于需要更高级锁功能的场景如可中断锁公平锁等示例代码读写锁接口定义了一种锁允许多个读取者同时访问共享资源但只允许一个写入者优点适用于读取远多于写入的场景提高并发性缺点实现复杂需要管理读锁和写锁的获取和释放使用场景适用于读取操作远多于写入操作的场景如缓存系统示例代码乐观锁和悲观锁悲观锁在访问数据前就锁定资源假设最坏的情况即数据很可能被其他线程修改和都是悲观锁的例子乐观锁通常不锁定资源而是在更新数据时检查数据是否已被其他线程修改乐观锁常使用版本号或时间戳来实现优点乐观锁适用于冲突较少的场景减少锁的开销悲观锁适用于冲突较多的场景确保数据一致性缺点乐观锁在冲突较多时性能较差悲观锁在冲突较少时性能较差使用场景乐观锁适用于读多写少的场景如版本控制系统悲观锁适用于写操作频繁的场景如数据库事务示例代码自旋锁自旋锁是一种锁机制线程在等待锁时会持续循环检查锁是否可用而不是放弃并阻塞通常可以使用来实现优点在锁等待时间很短的情况下可以提高性能缺点过度自旋会浪费资源使用场景适用于锁等待时间很短的场景如轻量级同步示例代码自旋等待什么是可重入锁可重入锁是指同一个线程在获取了锁之后可以再次重复获取该锁而不会造成死锁或其他问题当一个线程持有锁时如果再次尝试获取该锁就会成功获取而不会被阻塞可重入锁的工作原理实现可重入锁的机制是基于线程持有锁的计数器具体工作原理如下计数器初始化当一个线程第一次获取锁时计数器会加表示该线程持有了锁重复获取锁在此之后如果同一个线程再次获取锁计数器会再次加每次线程成功获取锁时都会将计数器加释放锁当线程释放锁时计数器会相应地减只有当计数器减到时锁才会完全释放其他线程才有机会获取锁避免死锁这种计数器的设计使得同一个线程可以多次获取同一个锁而不会造成死锁或其他问题每次获取锁时计数器加每次释放锁时计数器减只有当计数器减到时锁才会完全释放和的区别工作原理是提供的原子性内置锁这种内置的并且使用者看不到的锁也被称为监视器锁使用之后会在编译之后在同步的代码块前后加上和字节码指令它依赖操作系统底层互斥锁实现它的作用主要就是实现原子性操作和解决共享变量的内存可见性问题工作原理执行指令时会尝试获取对象锁如果对象没有被锁定或者已经获得了锁锁的计数器此时其他竞争锁的线程则会进入等待队列中执行指令时则会把计数器当计数器值为时锁释放处于等待队列中的线程再继续竞争锁特点是排它锁当一个线程获得锁之后其他线程必须等待该线程释放锁后才能获得锁由于中的线程和操作系统原生线程是一一对应的线程被阻塞或者唤醒时会从用户态切换到内核态这种转换非常消耗性能从内存语义来说加锁的过程会清除工作内存中的共享变量再从主内存读取而释放锁的过程则是将工作内存中的共享变量写回主内存工作原理的底层实现主要依赖于这个抽象类是一个提供了基本同步机制的框架其中包括了队列状态值等工作原理在的基础上通过内部类来实现具体的锁操作不同的子类实现了公平锁和非公平锁的不同逻辑提供了更灵活的锁机制支持可中断的锁等待定时锁等待公平锁选项等特点可见性通过变量来保证锁状态的可见性设置超时时间支持在获取锁时设置超时时间避免无限等待公平锁和非公平锁提供了公平锁和非公平锁的选项公平锁按照线程请求锁的顺序来分配锁非公平锁不保证锁分配的顺序多个条件变量支持多个条件变量可以更细粒度地控制线程的等待和唤醒可重入性支持可重入性即同一个线程可以多次获取同一个锁区别和都是中提供的可重入锁但它们在用法获取和释放锁的方式锁类型响应中断以及底层实现等方面存在显著差异用法不同可以用来修饰普通方法静态方法和代码块只能用在代码块中获取锁和释放锁方式不同会自动加锁和释放锁当进入修饰的代码块之后会自动加锁当离开的代码段之后会自动释放锁需要手动加锁和释放锁通过方法获取锁通过方法释放锁锁类型不同属于非公平锁既可以是公平锁也可以是非公平锁通过构造函数可以指定锁的类型响应中断不同可以响应中断解决死锁的问题通过方法可以实现可中断的锁等待不能响应中断底层实现不同是层面通过监视器实现的在编译后的字节码中会生成和指令是基于实现的是一个提供了基本同步机制的框架其中包括了队列状态值等锁升级过程锁在中的升级过程是一个逐步优化的过程从无锁状态到偏向锁轻量级锁最终升级为重量级锁这个过程旨在根据不同的竞争情况动态调整锁的实现方式以提高性能锁升级过程无锁状态描述这是还没有开启偏向锁时的状态启动后会有一个偏向延时延迟一段时间后才会开启偏向锁特点无锁状态下对象的中存储的是对象的哈希码和分代年龄等信息偏向锁描述偏向锁开启后的锁状态如果无线程拿到该锁这个状态叫匿名偏向当一个线程想要竞争该锁时只需要拿线程和中存储的线程比较如果线程相同则直接获取锁即锁偏向于这个线程不需要进行操作和将线程挂起特点偏向锁减少了无竞争情况下的锁开销适用于单线程访问的场景轻量级锁描述在这个状态下线程主要通过操作实现将对象的存储到线程的虚拟栈上然后将对象的更新为指向线程栈中锁记录的指针特点轻量级锁适用于竞争不激烈的场景通过操作避免了线程挂起和唤醒的开销重量级锁描述当两个以上的线程获取锁时轻量级锁就会升级为重量级锁因为操作如果没有成功的话线程会自旋等待进行循环操作非常消耗资源特点重量级锁通过操作系统底层的互斥锁实现适用于高并发竞争场景锁升级的触发条件无锁到偏向锁启动后经过偏向延时默认情况下偏向锁是开启的偏向锁到轻量级锁当有其他线程尝试获取偏向锁时偏向锁会升级为轻量级锁轻量级锁到重量级锁当多个线程竞争同一个锁时轻量级锁会升级为重量级锁锁的升级过程是一个动态优化的过程从无锁状态到偏向锁轻量级锁最终升级为重量级锁这个过程根据不同的竞争情况动态调整锁的实现方式以提高性能简称是中的一个抽象类是用于构建锁同步器协作工具类的工具类框架提供了一个基于队列的阻塞锁和相关的同步器如信号量事件等的框架是并发包的基础的核心思想的核心思想是如果当前请求的资源空闲那么就将当前请求资源的线程设置为有效工作线程将共享资源锁定如果资源被占用就需要一定的等待阻塞唤醒机制来保证锁的分配这个机制主要用的是队列变体实现的将暂时获取不到锁的线程加入到队列中队列队列是一种基于链表的自旋锁队列使用队列的变体来管理等待线程的队列的核心组成部分最核心的就是三大部分状态使用一个的类型的成员变量来表示同步状态的值可以表示锁的状态信号量的计数等通过和方法来操作的值队列内置了一个队列来管理等待线程当线程获取锁失败时会被加入到这个队列中等待队列中的每个节点代表一个等待线程节点之间通过和指针连接获取释放操作重写定义了获取和释放资源的方法但具体的实现需要子类去重写子类需要实现等方法来定义资源的获取和释放逻辑的工作原理获取资源线程调用方法尝试获取资源如果返回表示获取成功线程继续执行如果返回表示获取失败线程会被加入到等待队列中并进入阻塞状态释放资源线程调用方法释放资源如果返回表示释放成功会唤醒等待队列中的一个或多个线程让它们重新竞争资源以下是一个简单的自定义锁的示例展示了如何使用实现一个独占锁详解是中为了线程安全设置的一种机制每个线程可以设置局部变量也就是允许设置自己线程的一个数据副本线程对副本的修改不会影响到线程间的资源共享和同步问题的作用线程隔离每个线程都有自己独立的变量副本线程之间的数据互不影响降低耦合度在同一个线程的多个函数或组件之间使用可以减少参数的传递降低代码之间的耦合度使得模块清晰化性能优势由于避免了线程间的同步开销所以大量线程并发执行时相比传统的锁机制它可以提供更好的性能的原理的实现依赖于类中的一个字段这是一个存储变量本身和对应值的映射每个线程都有自己的实例用于存储该线程所持有的所有变量的值核心操作方法当调用的方法时会检查当前线程的中是否有与之关联的值如果有则返回值如果没有会调用方法初始化该值然后将其放入中并返回方法当调用方法时会将当前线程与给定的值关联起来即向中存入键值对键为当前对象本身值为给定的值方法当调用方法时会从当前线程的中移除与当前对象关联的键值对可能存在的问题内存泄漏问题原因中的对象持有对对象的强引用如果对象没有被显式移除即使线程结束对象仍然存在导致对象无法被垃圾回收解决方法在不再需要变量时显式调用方法确保对象能够被及时回收以下是一个简单的示例代码展示了的使用显式移除变量乐观锁悲观锁乐观锁总是假设最好的情况认为共享资源每次被访问的时候不会出现问题线程可以不停地执行无需加锁也无需等待只是在提交修改的时候去验证对应的资源也就是数据是否被其它线程修改了具体方法可以使用版本号机制或算法如果没有被修改则更新资源如果被修改则重试操作悲观锁总是假设最坏的情况认为共享资源每次被访问的时候就会出现问题比如共享数据被修改所以每次在获取资源操作的时候都会上锁这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放也就是说共享资源每次只给一个线程使用其它线程阻塞用完后再把资源转让给其它线程实现乐观锁的方式在中实现乐观锁的方式主要有以下几种操作是乐观锁的基础提供了原子类包包含各种原子变量类操作这些类通过使用操作方式实现了线程安全的原子操作可用来实现乐观锁以下是一个使用实现乐观锁的示例代码版本号控制增加一个字段记录更新的版本每次更新递增版本号在更新时同时比较版本号如果一致则替换更新完成若不一致则更新失败以下是一个使用版本号控制实现乐观锁的示例代码时间戳使用时间戳记录更新时的时间每次更新时比较时间戳如果一致则替换更新完成若不一致则更新失败以下是一个使用时间戳实现乐观锁的示例代码的缺点操作是实现乐观锁的基础但它也存在一些缺点主要包括以下三个方面问题问题是指在操作中一个变量在操作过程中经历了从到再回到的变化而操作只比较变量的当前值和预期值是否一致无法检测到这种中间变化解决方案版本号在变量中增加一个版本号字段每次更新时递增版本号操作同时比较变量值和版本号时间戳使用时间戳记录变量的更新时间操作同时比较变量值和时间戳循环时间过长若无法更新成功线程会一直自旋循环长时间占用资源带来无用的花销这也就造成了不能所有锁都使用解决方案自旋次数限制设置自旋次数上限超过次数后放弃自旋进入阻塞状态自旋时间限制设置自旋时间上限超过时间后放弃自旋进入阻塞状态只能保证一个共享变量的原子性操作只能保证单个共享变量的原子性无法保证多个共享变量的原子性解决方案锁机制使用或等锁机制保证多个共享变量的原子性组合操作将多个共享变量封装在一个对象中使用进行操作是中的一个关键字主要用于修饰变量它具有两个主要作用保证变量对所有线程的可见性和禁止指令重排序优化保证变量对所有线程的可见性当一个变量被声明为时它会保证对这个变量的写操作会立即刷新到主存中而对这个变量的读操作会直接从主存中读取从而确保了多线程环境下对该变量访问的可见性这意味着一个线程修改了变量的值其他线程能够立刻看到这个修改不会受到各自线程工作内存的影响禁止指令重排序优化关键字在中主要通过内存屏障来禁止特定类型的指令重排序内存屏障分为以下几种写写屏障在对变量执行写操作之前会插入一个写屏障这确保了在该变量写操作之前的所有普通写操作都已完成防止了这些写操作被移到写操作之后读写屏障在对变量执行读操作之后会插入一个读屏障它确保了对变量的读操作之后的所有普通读操作都不会被提前到读之前执行保证了读取到的数据是最新的写读屏障这是最重要的一个屏障它发生在写之后和读之前这个屏障确保了写操作之前的所有内存操作包括写操作都不会被重排序到读之后同时也确保了读操作之后的所有内存操作包括读操作都不会被重排序到写之前不能完全保证线程安全关键字在中主要用于保证变量对所有线程的可见性和禁止指令重排序优化然而并不能完全保证线程安全因为它没有保证数据操作的原子性在多线程环境下进行复合操作如自增自减等自增自减包含读取修改和写入三个步骤可能会出现覆盖问题时无法保证操作的原子性因此可能会导致线程安全问题保证线程安全的解决方案为了保证复合操作的线程安全可以使用以下方法关键字使用关键字来同步代码块或方法确保同一时刻只有一个线程能访问这些代码接口和类使用接口和类来实现更灵活的锁机制确保同一时刻只有一个线程能访问这些代码原子类使用包中的原子类如来实现原子操作确保操作的原子性指令重排的原理在执行程序时为了提高性能处理器和编译器往往会对指令进行重排优化指令重排的目的是在不改变程序运行结果的前提下优化指令的执行顺序以提高处理器的执行效率指令重排的原则指令重排遵循以下两个原则不能改变程序的运行结果指令重排不能改变单线程程序的运行结果也就是说无论指令如何重排单线程程序的执行结果必须保持一致存在依赖关系的指令不能进行重排如果两条指令之间存在数据依赖关系即一条指令的执行结果会影响另一条指令的执行那么这两条指令不能进行重排指令重排的类型指令重排可以分为以下几种类型编译器重排编译器在生成机器码时可能会对指令进行重排以优化代码的执行顺序处理器重排处理器在执行指令时可能会对指令进行重排以提高指令流水线的效率指令重排的示例以下是一个简单的示例代码展示了指令重排的效果在这个示例中线程中的两条指令和之间没有数据依赖关系因此编译器和处理器可能会对这两条指令进行重排重排后的执行顺序可能是先执行后执行指令重排的影响指令重排在单线程环境下通常不会影响程序的运行结果但在多线程环境下可能会导致不可预期的结果例如在上述示例中如果线程在线程完成之前读取了的值那么线程可能会输出这与预期的不一致公平锁与非公平锁在多线程编程中锁机制是保证线程安全的重要手段根据线程获取锁的顺序锁可以分为公平锁和非公平锁公平锁公平锁是指多个线程按照申请锁的顺序来获取锁线程直接进入队列中排队队列中的第一个线程才能获得锁流程获取锁线程尝试获取锁若锁已被占用则将自身加入等待队列队尾并进入休眠状态释放锁持有锁的线程释放锁后会唤醒等待队列队首的线程该线程尝试获取锁状态切换线程在运行和休眠状态之间切换每次切换都需要进行用户态和内核态的转换这种转换开销较大导致公平锁执行速度较慢非公平锁非公平锁是指多个线程加锁时直接尝试获取锁能抢到锁的线程直接占有锁抢不到才会到等待队列的队尾等待流程获取锁线程尝试通过操作直接获取锁若成功则直接持有锁无需进入等待队列竞争锁若失败线程才会进入等待队列等待下次获取锁的机会效率提升非公平锁避免了线程频繁的休眠和唤醒操作减少了用户态和内核态的切换开销从而提高了程序执行效率对比公平锁与非公平锁的优缺点对比特性公平锁非公平锁获取锁顺序严格按照等待队列顺序不保证顺序可能出现插队现象吞吐量较低频繁的线程切换开销大较高减少了线程切换开销响应时间较长新线程需要等待较短新线程有机会立即获取锁饥饿问题不易发生可能发生某些线程可能长时间无法获取锁适用场景对公平性要求较高例如银行排队系统对性能要求较高例如高并发场景是不公平锁默认情况下也是不公平锁但可以通过构造函数参数指定为公平锁在其获取锁的方法中设置前置判断条件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 11:43:47',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/images/star.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XIAOYAN</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 1.05rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 1.05rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 1.05rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 1.05rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 1.05rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.05rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 1.05rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 1.05rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 1.05rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 1.05rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 1.05rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url">并发编程</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>并发安全</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java并发编程-并发安全篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-10T00:08:09.000Z" title="发表于 2024-09-10 08:08:09">2024-09-10</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T03:43:47.573Z" title="更新于 2024-11-04 11:43:47">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为桂林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>桂林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/cover.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url">并发编程</a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" tabindex="-1" itemprop="url">并发安全</a><h1 id="CrawlerTitle" itemprop="name headline">Java并发编程-并发安全篇</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">xiaoyan</span><time itemprop="dateCreated datePublished" datetime="2024-09-10T00:08:09.000Z" title="发表于 2024-09-10 08:08:09">2024-09-10</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T03:43:47.573Z" title="更新于 2024-11-04 11:43:47">2024-11-04</time></header><p>Java提供了多种机制来保证线程安全，包括内置锁、显式锁、原子类、线程局部变量和并发集合等。本文将深入探讨Java中的并发安全机制，涵盖线程同步、锁机制、原子操作、线程局部变量以及并发集合等内容。</p>
<span id="more"></span>

<h1 id="如何保证多线程安全"><a href="#如何保证多线程安全" class="headerlink" title="如何保证多线程安全"></a>如何保证多线程安全</h1><p>在 Java 中，保证多线程安全主要有以下几种方式：</p>
<p><strong>1.<code>synchronized</code> 关键字</strong></p>
<p>使用 <code>synchronized</code> 关键字来同步代码块或方法，确保同一时刻只有一个线程能访问这些代码。</p>
<p><strong>优点</strong>：简单易用，适用于简单的同步需求。</p>
<p><strong>缺点</strong>：可能会导致性能问题，特别是在高并发场景下。可能会导致死锁。</p>
<p><strong>2. <code>volatile</code> 关键字</strong></p>
<p>使用 <code>volatile</code> 关键字，确保所有的线程都能看到该变量的最新值，而不是可能存储在本地寄存器中的副本。</p>
<p><strong>优点</strong>：确保变量的可见性，适用于简单的状态标志。</p>
<p><strong>缺点</strong>：不能保证复合操作的原子性，如 <code>count++</code>。</p>
<p><strong>3. <code>Lock</code> 接口和 <code>ReentrantLock</code> 类</strong></p>
<p>使用 <code>Lock</code> 接口和 <code>ReentrantLock</code> 类来实现更灵活的锁机制。</p>
<p><strong>优点</strong>：提供更灵活的锁机制，支持可中断锁、公平锁等。</p>
<p><strong>缺点</strong>：需要手动管理锁的获取和释放，容易出错。</p>
<p><strong>4. 原子类</strong></p>
<p>Java 并发库提供了原子类，这些类提供原子操作，可以用来更新基本数据类型而无需同步。</p>
<p><strong>优点</strong>：提供原子操作，无需手动同步。</p>
<p><strong>缺点</strong>：仅适用于基本数据类型的原子操作。</p>
<p><strong>5. 线程局部变量 <code>ThreadLocal</code></strong></p>
<p>可以为每个线程创建独立的副本，这样每个副本都拥有自己的变量，消除竞争条件。</p>
<p><strong>优点</strong>：每个线程拥有独立的变量副本，消除竞争条件。</p>
<p><strong>缺点</strong>：可能会导致内存泄漏，特别是在线程池中使用时。</p>
<p><strong>6. 并发集合</strong></p>
<p><code>java.util.concurrent</code> 包中提供了线程安全的集合，已实现线程安全逻辑。</p>
<p><strong>优点</strong>：提供线程安全的集合操作，无需手动同步。</p>
<p><strong>缺点</strong>：可能会导致性能问题，特别是在高并发场景下。</p>
<h1 id="Java-中常用的锁及其使用场景"><a href="#Java-中常用的锁及其使用场景" class="headerlink" title="Java 中常用的锁及其使用场景"></a>Java 中常用的锁及其使用场景</h1><p>在 Java 中，锁是用于管理多线程并发访问共享资源的关键机制。锁可以确保在任意给定时间内只有一个线程可以访问特定的资源，从而避免数据竞争和不一致性。Java 提供了多种锁机制，以下是常用的锁及其使用场景：</p>
<p><strong>1. 内置锁 (<code>synchronized</code>)</strong></p>
<p><code>synchronized</code> 关键字是 Java 内置的锁机制，可以用于方法或代码块。当一个线程进入 <code>synchronized</code> 代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。</p>
<p><strong>优点</strong>：简单易用，适用于简单的同步需求。</p>
<p><strong>缺点</strong>：可能会导致性能问题，特别是在高并发场景下。可能会导致死锁。</p>
<p><strong>使用场景</strong>：适用于简单的同步需求，如单个对象的同步访问。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <code>ReentrantLock</code></strong></p>
<p><code>java.util.concurrent.locks.ReentrantLock</code> 是一个显式的锁类，提供了比 <code>synchronized</code> 更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。</p>
<p><strong>优点</strong>：提供更灵活的锁机制，支持可中断锁、公平锁等。</p>
<p><strong>缺点</strong>：需要手动管理锁的获取和释放，容易出错。</p>
<p><strong>使用场景</strong>：适用于需要更高级锁功能的场景，如可中断锁、公平锁等。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 读写锁 (<code>ReadWriteLock</code>)</strong></p>
<p><code>java.util.concurrent.locks.ReadWriteLock</code> 接口定义了一种锁，允许多个读取者同时访问共享资源，但只允许一个写入者。</p>
<p><strong>优点</strong>：适用于读取远多于写入的场景，提高并发性。</p>
<p><strong>缺点</strong>：实现复杂，需要管理读锁和写锁的获取和释放。</p>
<p><strong>使用场景</strong>：适用于读取操作远多于写入操作的场景，如缓存系统。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 乐观锁和悲观锁</strong></p>
<ul>
<li>**悲观锁 (Pessimistic Locking)**：在访问数据前就锁定资源，假设最坏的情况即数据很可能被其他线程修改。<code>synchronized</code> 和 <code>ReentrantLock</code> 都是悲观锁的例子。</li>
<li>**乐观锁 (Optimistic Locking)**：通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。</li>
</ul>
<p><strong>优点</strong>：乐观锁适用于冲突较少的场景，减少锁的开销；悲观锁适用于冲突较多的场景，确保数据一致性。</p>
<p><strong>缺点</strong>：乐观锁在冲突较多时性能较差；悲观锁在冲突较少时性能较差。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>乐观锁适用于读多写少的场景，如版本控制系统。</li>
<li>悲观锁适用于写操作频繁的场景，如数据库事务。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">version</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(<span class="type">int</span> expectedVersion, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (version.compareAndSet(expectedVersion, expectedVersion + <span class="number">1</span>)) &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> version.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 自旋锁</strong></p>
<p>自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃 CPU 并阻塞。通常可以使用 CAS（Compare-And-Swap）来实现。</p>
<p><strong>优点</strong>：在锁等待时间很短的情况下可以提高性能。</p>
<p><strong>缺点</strong>：过度自旋会浪费 CPU 资源。</p>
<p><strong>使用场景</strong>：适用于锁等待时间很短的场景，如轻量级同步。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!lock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.set(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h1><p>可重入锁（Reentrant Lock）是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。</p>
<h2 id="可重入锁的工作原理"><a href="#可重入锁的工作原理" class="headerlink" title="可重入锁的工作原理"></a>可重入锁的工作原理</h2><p><code>ReentrantLock</code> 实现可重入锁的机制是基于线程持有锁的计数器。具体工作原理如下：</p>
<ol>
<li><strong>计数器初始化</strong>：当一个线程第一次获取锁时，计数器会加 1，表示该线程持有了锁。</li>
<li><strong>重复获取锁</strong>：在此之后，如果同一个线程再次获取锁，计数器会再次加 1。每次线程成功获取锁时，都会将计数器加 1。</li>
<li><strong>释放锁</strong>：当线程释放锁时，计数器会相应地减 1。只有当计数器减到 0 时，锁才会完全释放，其他线程才有机会获取锁。</li>
<li><strong>避免死锁</strong>：这种计数器的设计使得同一个线程可以多次获取同一个锁，而不会造成死锁或其他问题。每次获取锁时计数器加 1；每次释放锁时，计数器减 1。只有当计数器减到 0 时，锁才会完全释放。</li>
</ol>
<h1 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a><code>synchronized</code> 和 <code>ReentrantLock</code> 的区别</h1><h2 id="synchronized-工作原理"><a href="#synchronized-工作原理" class="headerlink" title="synchronized 工作原理"></a><code>synchronized</code> 工作原理</h2><p><code>synchronized</code> 是 Java 提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为监视器锁。使用 <code>synchronized</code> 之后，会在编译之后在同步的代码块前后加上 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令，它依赖操作系统底层互斥锁实现。它的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li>执行 <code>monitorenter</code> 指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器 +1。此时其他竞争锁的线程则会进入等待队列中。</li>
<li>执行 <code>monitorexit</code> 指令时则会把计数器 -1，当计数器值为 0 时锁释放，处于等待队列中的线程再继续竞争锁。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><code>synchronized</code> 是排它锁，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁。</li>
<li>由于 Java 中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时会从用户态切换到内核态，这种转换非常消耗性能。</li>
<li>从内存语义来说，加锁的过程会清除工作内存中的共享变量，再从主内存读取，而释放锁的过程则是将工作内存中的共享变量写回主内存。</li>
</ul>
<h2 id="ReentrantLock-工作原理"><a href="#ReentrantLock-工作原理" class="headerlink" title="ReentrantLock 工作原理"></a><code>ReentrantLock</code> 工作原理</h2><p><code>ReentrantLock</code> 的底层实现主要依赖于 <code>AbstractQueuedSynchronizer</code> (AQS) 这个抽象类。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。</p>
<p><strong>工作原理</strong>：</p>
<ul>
<li><code>ReentrantLock</code> 在 AQS 的基础上通过内部类 <code>Sync</code> 来实现具体的锁操作。不同的 <code>Sync</code> 子类实现了公平锁和非公平锁的不同逻辑。</li>
<li><code>ReentrantLock</code> 提供了更灵活的锁机制，支持可中断的锁等待、定时锁等待、公平锁选项等。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>可见性</strong>：<code>ReentrantLock</code> 通过 <code>volatile</code> 变量来保证锁状态的可见性。</li>
<li><strong>设置超时时间</strong>：<code>ReentrantLock</code> 支持在获取锁时设置超时时间，避免无限等待。</li>
<li><strong>公平锁和非公平锁</strong>：<code>ReentrantLock</code> 提供了公平锁和非公平锁的选项，公平锁按照线程请求锁的顺序来分配锁，非公平锁不保证锁分配的顺序。</li>
<li><strong>多个条件变量</strong>：<code>ReentrantLock</code> 支持多个条件变量，可以更细粒度地控制线程的等待和唤醒。</li>
<li><strong>可重入性</strong>：<code>ReentrantLock</code> 支持可重入性，即同一个线程可以多次获取同一个锁。</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是 Java 中提供的可重入锁，但它们在用法、获取和释放锁的方式、锁类型、响应中断以及底层实现等方面存在显著差异。</p>
<p><strong>1.用法不同</strong></p>
<ul>
<li>**<code>synchronized</code>**：可以用来修饰普通方法、静态方法和代码块。</li>
<li>**<code>ReentrantLock</code>**：只能用在代码块中。</li>
</ul>
<p><strong>2.获取锁和释放锁方式不同</strong></p>
<ul>
<li>**<code>synchronized</code>**：会自动加锁和释放锁。当进入 <code>synchronized</code> 修饰的代码块之后会自动加锁，当离开 <code>synchronized</code> 的代码段之后会自动释放锁。</li>
<li>**<code>ReentrantLock</code>**：需要手动加锁和释放锁。通过 <code>lock()</code> 方法获取锁，通过 <code>unlock()</code> 方法释放锁。</li>
</ul>
<p><strong>3.锁类型不同</strong></p>
<ul>
<li>**<code>synchronized</code>**：属于非公平锁。</li>
<li>**<code>ReentrantLock</code>**：既可以是公平锁也可以是非公平锁。通过构造函数可以指定锁的类型。</li>
</ul>
<p><strong>4.响应中断不同</strong></p>
<ul>
<li>**<code>ReentrantLock</code>**：可以响应中断，解决死锁的问题。通过 <code>lockInterruptibly()</code> 方法可以实现可中断的锁等待。</li>
<li>**<code>synchronized</code>**：不能响应中断。</li>
</ul>
<p><strong>5.底层实现不同</strong></p>
<ul>
<li>**<code>synchronized</code>**：是 JVM 层面通过监视器（Monitor）实现的。在编译后的字节码中会生成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。</li>
<li>**<code>ReentrantLock</code>**：是基于 AQS（AbstractQueuedSynchronizer）实现的。AQS 是一个提供了基本同步机制的框架，其中包括了队列、状态值等。</li>
</ul>
<h1 id="synchronized-锁升级过程"><a href="#synchronized-锁升级过程" class="headerlink" title="synchronized 锁升级过程"></a><code>synchronized</code> 锁升级过程</h1><p><code>synchronized</code> 锁在 Java 中的升级过程是一个逐步优化的过程，从无锁状态到偏向锁、轻量级锁，最终升级为重量级锁。这个过程旨在根据不同的竞争情况，动态调整锁的实现方式，以提高性能。</p>
<h2 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h2><p><strong>1. 无锁状态</strong></p>
<ul>
<li><strong>描述</strong>：这是还没有开启偏向锁时的状态。JVM 启动后会有一个偏向延时，延迟一段时间后才会开启偏向锁。</li>
<li><strong>特点</strong>：无锁状态下，对象的 Mark Word 中存储的是对象的哈希码和分代年龄等信息。</li>
</ul>
<p><strong>2. 偏向锁</strong></p>
<ul>
<li><strong>描述</strong>：偏向锁开启后的锁状态。如果无线程拿到该锁，这个状态叫匿名偏向。当一个线程想要竞争该锁时，只需要拿线程 ID 和 Mark Word 中存储的线程 ID 比较，如果线程 ID 相同则直接获取锁（即锁偏向于这个线程），不需要进行 CAS 操作和将线程挂起。</li>
<li><strong>特点</strong>：偏向锁减少了无竞争情况下的锁开销，适用于单线程访问的场景。</li>
</ul>
<p><strong>3. 轻量级锁</strong></p>
<ul>
<li><strong>描述</strong>：在这个状态下，线程主要通过 CAS（Compare-And-Swap）操作实现。将对象的 Mark Word 存储到线程的虚拟栈上，然后将对象的 Mark Word 更新为指向线程栈中锁记录的指针。</li>
<li><strong>特点</strong>：轻量级锁适用于竞争不激烈的场景，通过 CAS 操作避免了线程挂起和唤醒的开销。</li>
</ul>
<p><strong>4. 重量级锁</strong></p>
<ul>
<li><strong>描述</strong>：当两个以上的线程获取锁时，轻量级锁就会升级为重量级锁。因为 CAS 操作如果没有成功的话，线程会自旋等待，进行 while 循环操作，非常消耗 CPU 资源。</li>
<li><strong>特点</strong>：重量级锁通过操作系统底层的互斥锁实现，适用于高并发竞争场景。</li>
</ul>
<h2 id="锁升级的触发条件"><a href="#锁升级的触发条件" class="headerlink" title="锁升级的触发条件"></a>锁升级的触发条件</h2><ul>
<li><strong>无锁到偏向锁</strong>：JVM 启动后经过偏向延时，默认情况下偏向锁是开启的。</li>
<li><strong>偏向锁到轻量级锁</strong>：当有其他线程尝试获取偏向锁时，偏向锁会升级为轻量级锁。</li>
<li><strong>轻量级锁到重量级锁</strong>：当多个线程竞争同一个锁时，轻量级锁会升级为重量级锁。</li>
</ul>
<p><code>synchronized</code> 锁的升级过程是一个动态优化的过程，从无锁状态到偏向锁、轻量级锁，最终升级为重量级锁。这个过程根据不同的竞争情况，动态调整锁的实现方式，以提高性能。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p><code>AbstractQueuedSynchronizer</code>（简称 AQS）是 Java 中的一个抽象类，是用于构建锁、同步器、协作工具类的工具类（框架）。AQS 提供了一个基于 FIFO 队列的阻塞锁和相关的同步器（如信号量、事件等）的框架，是 Java 并发包（<code>java.util.concurrent</code>）的基础。</p>
<h2 id="AQS-的核心思想"><a href="#AQS-的核心思想" class="headerlink" title="AQS 的核心思想"></a>AQS 的核心思想</h2><p>AQS 的核心思想是，如果当前请求的资源空闲，那么就将当前请求资源的线程设置为有效工作线程，将共享资源锁定；如果资源被占用，就需要一定的等待阻塞唤醒机制来保证锁的分配。这个机制主要用的是 CLH 队列变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<h3 id="CLH-队列"><a href="#CLH-队列" class="headerlink" title="CLH 队列"></a>CLH 队列</h3><p>CLH（Craig, Landin, and Hagersten）队列是一种基于链表的自旋锁队列。AQS 使用 CLH 队列的变体来管理等待线程的队列。</p>
<h2 id="AQS-的核心组成部分"><a href="#AQS-的核心组成部分" class="headerlink" title="AQS 的核心组成部分"></a>AQS 的核心组成部分</h2><p>AQS 最核心的就是三大部分：</p>
<ol>
<li><p><strong>状态（State）</strong>：</p>
<ul>
<li>AQS 使用一个 <code>volatile</code> 的 <code>int</code> 类型的成员变量 <code>state</code> 来表示同步状态。<code>state</code> 的值可以表示锁的状态、信号量的计数等。</li>
<li>通过 <code>getState()</code>、<code>setState()</code> 和 <code>compareAndSetState()</code> 方法来操作 <code>state</code> 的值。</li>
</ul>
</li>
<li><p><strong>FIFO 队列</strong>：</p>
<ul>
<li>AQS 内置了一个 FIFO 队列来管理等待线程。当线程获取锁失败时，会被加入到这个队列中等待。</li>
<li>队列中的每个节点代表一个等待线程，节点之间通过 <code>prev</code> 和 <code>next</code> 指针连接。</li>
</ul>
</li>
<li><p><strong>获取&#x2F;释放操作（重写）</strong>：</p>
<ul>
<li>AQS 定义了获取和释放资源的方法，但具体的实现需要子类去重写。</li>
<li>子类需要实现 <code>tryAcquire()</code>、<code>tryRelease()</code>、<code>tryAcquireShared()</code>、<code>tryReleaseShared()</code> 等方法，来定义资源的获取和释放逻辑。</li>
</ul>
</li>
</ol>
<h2 id="AQS-的工作原理"><a href="#AQS-的工作原理" class="headerlink" title="AQS 的工作原理"></a>AQS 的工作原理</h2><ol>
<li><p><strong>获取资源</strong>：</p>
<ul>
<li>线程调用 <code>acquire()</code> 方法尝试获取资源。</li>
<li>如果 <code>tryAcquire()</code> 返回 <code>true</code>，表示获取成功，线程继续执行。</li>
<li>如果 <code>tryAcquire()</code> 返回 <code>false</code>，表示获取失败，线程会被加入到等待队列中，并进入阻塞状态。</li>
</ul>
</li>
<li><p><strong>释放资源</strong>：</p>
<ul>
<li>线程调用 <code>release()</code> 方法释放资源。</li>
<li>如果 <code>tryRelease()</code> 返回 <code>true</code>，表示释放成功，AQS 会唤醒等待队列中的一个或多个线程，让它们重新竞争资源。</li>
</ul>
</li>
</ol>
<p>以下是一个简单的自定义锁的示例，展示了如何使用 AQS 实现一个独占锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal-详解"><a href="#ThreadLocal-详解" class="headerlink" title="ThreadLocal 详解"></a>ThreadLocal 详解</h1><p><code>ThreadLocal</code> 是 Java 中为了线程安全设置的一种机制，每个线程可以设置局部变量，也就是允许设置自己线程的一个数据副本，线程对副本的修改不会影响到线程间的资源共享和同步问题。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202409221604085.png" alt="ThreadLocal" style="zoom:67%;">



<h2 id="ThreadLocal-的作用"><a href="#ThreadLocal-的作用" class="headerlink" title="ThreadLocal 的作用"></a>ThreadLocal 的作用</h2><ul>
<li><strong>线程隔离</strong>：每个线程都有自己独立的 <code>ThreadLocal</code> 变量副本，线程之间的数据互不影响。</li>
<li><strong>降低耦合度</strong>：在同一个线程的多个函数或组件之间，使用 <code>ThreadLocal</code> 可以减少参数的传递，降低代码之间的耦合度，使得模块清晰化。</li>
<li><strong>性能优势</strong>：由于 <code>ThreadLocal</code> 避免了线程间的同步开销，所以大量线程并发执行时，相比传统的锁机制，它可以提供更好的性能。</li>
</ul>
<h2 id="ThreadLocal-的原理"><a href="#ThreadLocal-的原理" class="headerlink" title="ThreadLocal 的原理"></a>ThreadLocal 的原理</h2><p><code>ThreadLocal</code> 的实现依赖于 <code>Thread</code> 类中的一个 <code>ThreadLocalMap</code> 字段，这是一个存储 <code>ThreadLocal</code> 变量本身和对应值的映射。每个线程都有自己的 <code>ThreadLocalMap</code> 实例，用于存储该线程所持有的所有 <code>ThreadLocal</code> 变量的值。</p>
<h3 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h3><ul>
<li><p><strong><code>get()</code> 方法</strong>：</p>
<ul>
<li>当调用 <code>ThreadLocal</code> 的 <code>get()</code> 方法时，<code>ThreadLocal</code> 会检查当前线程的 <code>ThreadLocalMap</code> 中是否有与之关联的值。</li>
<li>如果有，则返回值；如果没有，会调用 <code>initialValue()</code> 方法初始化该值，然后将其放入 <code>ThreadLocalMap</code> 中并返回。</li>
</ul>
</li>
<li><p><strong><code>set()</code> 方法</strong>：</p>
<ul>
<li>当调用 <code>set()</code> 方法时，<code>ThreadLocal</code> 会将当前线程与给定的值关联起来，即向 <code>ThreadLocalMap</code> 中存入键值对，键为当前 <code>ThreadLocal</code> 对象本身，值为给定的值。</li>
</ul>
</li>
<li><p><strong><code>remove()</code> 方法</strong>：</p>
<ul>
<li>当调用 <code>remove()</code> 方法时，<code>ThreadLocal</code> 会从当前线程的 <code>ThreadLocalMap</code> 中移除与当前 <code>ThreadLocal</code> 对象关联的键值对。</li>
</ul>
</li>
</ul>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><ul>
<li><strong>原因</strong>：<code>ThreadLocalMap</code> 中的 <code>Entry</code> 对象持有对 <code>ThreadLocal</code> 对象的强引用，如果 <code>ThreadLocal</code> 对象没有被显式移除，即使线程结束，<code>Entry</code> 对象仍然存在，导致 <code>ThreadLocal</code> 对象无法被垃圾回收。</li>
<li><strong>解决方法</strong>：在不再需要 <code>ThreadLocal</code> 变量时，显式调用 <code>remove()</code> 方法，确保 <code>ThreadLocal</code> 对象能够被及时回收。</li>
</ul>
<p>以下是一个简单的示例代码，展示了 <code>ThreadLocal</code> 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; initial value: &quot;</span> + value);</span><br><span class="line">            threadLocal.set(value + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; updated value: &quot;</span> + threadLocal.get());</span><br><span class="line">            threadLocal.remove(); <span class="comment">// 显式移除 ThreadLocal 变量</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h1><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法），如果没有被修改，则更新资源；如果被修改，则重试操作。</p>
<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>
<h1 id="Java-实现乐观锁的方式"><a href="#Java-实现乐观锁的方式" class="headerlink" title="Java 实现乐观锁的方式"></a>Java 实现乐观锁的方式</h1><p>在 Java 中，实现乐观锁的方式主要有以下几种：</p>
<ol>
<li><strong>CAS（Compare-and-Swap）操作</strong></li>
</ol>
<p>CAS 是乐观锁的基础，Java 提供了原子类包（<code>java.util.concurrent.atomic</code>），包含各种原子变量类操作，这些类通过使用 CAS 操作方式，实现了线程安全的原子操作，可用来实现乐观锁。</p>
<p>以下是一个使用 <code>AtomicInteger</code> 实现乐观锁的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateValue</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.compareAndSet(expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 版本号控制</strong></p>
<p>增加一个字段记录更新的版本，每次更新递增版本号。在更新时，同时比较版本号，如果一致则替换更新完成，若不一致则更新失败。</p>
<p>以下是一个使用版本号控制实现乐观锁的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VersionControlExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(<span class="type">int</span> expectedVersion, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">            version++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVersion</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>时间戳</strong></li>
</ol>
<p>使用时间戳记录更新时的时间，每次更新时比较时间戳，如果一致则替换更新完成，若不一致则更新失败。</p>
<p>以下是一个使用时间戳实现乐观锁的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimestampExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Date</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(Date expectedTimestamp, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timestamp.equals(expectedTimestamp)) &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">            timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h1><p>CAS（Compare-and-Swap）操作是实现乐观锁的基础，但它也存在一些缺点，主要包括以下三个方面：</p>
<ol>
<li><strong>ABA 问题</strong></li>
</ol>
<p>ABA 问题是指在 CAS 操作中，一个变量在操作过程中经历了从 A 到 B 再回到 A 的变化，而 CAS 操作只比较变量的当前值和预期值是否一致，无法检测到这种中间变化。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>版本号</strong>：在变量中增加一个版本号字段，每次更新时递增版本号，CAS 操作同时比较变量值和版本号。</li>
<li><strong>时间戳</strong>：使用时间戳记录变量的更新时间，CAS 操作同时比较变量值和时间戳。</li>
</ul>
<ol start="2">
<li><strong>循环时间过长</strong></li>
</ol>
<p>若 CAS 无法更新成功，线程会一直自旋（循环），长时间占用 CPU 资源，带来无用的花销。这也就造成了不能所有锁都使用CAS。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>自旋次数限制</strong>：设置自旋次数上限，超过次数后放弃自旋，进入阻塞状态。</li>
<li><strong>自旋时间限制</strong>：设置自旋时间上限，超过时间后放弃自旋，进入阻塞状态。</li>
</ul>
<ol start="3">
<li><strong>只能保证一个共享变量的原子性</strong></li>
</ol>
<p>CAS 操作只能保证单个共享变量的原子性，无法保证多个共享变量的原子性。</p>
<p><strong>解决方案</strong></p>
<ul>
<li><strong>锁机制</strong>：使用 <code>synchronized</code> 或 <code>ReentrantLock</code> 等锁机制，保证多个共享变量的原子性。</li>
<li><strong>组合操作</strong>：将多个共享变量封装在一个对象中，使用 <code>AtomicReference</code> 进行 CAS 操作。</li>
</ul>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h1><p><code>volatile</code> 是 Java 中的一个关键字，主要用于修饰变量。它具有两个主要作用：保证变量对所有线程的可见性和禁止指令重排序优化。</p>
<h2 id="保证变量对所有线程的可见性"><a href="#保证变量对所有线程的可见性" class="headerlink" title="保证变量对所有线程的可见性"></a>保证变量对所有线程的可见性</h2><p>当一个变量被声明为 <code>volatile</code> 时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取，从而确保了多线程环境下对该变量访问的可见性。这意味着一个线程修改了 <code>volatile</code> 变量的值，其他线程能够立刻看到这个修改，不会受到各自线程工作内存的影响。</p>
<h2 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h2><p><code>volatile</code> 关键字在 Java 中主要通过内存屏障来禁止特定类型的指令重排序。内存屏障分为以下几种：</p>
<ol>
<li><p><strong>写-写（Write-Write）屏障</strong>：</p>
<p>在对 <code>volatile</code> 变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到 <code>volatile</code> 写操作之后。</p>
</li>
<li><p><strong>读-写（Read-Write）屏障</strong>：</p>
<p>在对 <code>volatile</code> 变量执行读操作之后，会插入一个读屏障。它确保了对 <code>volatile</code> 变量的读操作之后的所有普通读操作都不会被提前到 <code>volatile</code> 读之前执行，保证了读取到的数据是最新的。</p>
</li>
<li><p><strong>写-读（Write-Read）屏障</strong>：</p>
<p>这是最重要的一个屏障，它发生在 <code>volatile</code> 写之后和 <code>volatile</code> 读之前。这个屏障确保了 <code>volatile</code> 写操作之前的所有内存操作（包括写操作）都不会被重排序到 <code>volatile</code> 读之后，同时也确保了 <code>volatile</code> 读操作之后的所有内存操作（包括读操作）都不会被重排序到 <code>volatile</code> 写之前。</p>
</li>
</ol>
<h2 id="volatile-不能完全保证线程安全"><a href="#volatile-不能完全保证线程安全" class="headerlink" title="volatile 不能完全保证线程安全"></a><code>volatile</code> 不能完全保证线程安全</h2><p><code>volatile</code> 关键字在 Java 中主要用于保证变量对所有线程的可见性和禁止指令重排序优化。然而，<code>volatile</code> 并不能完全保证线程安全，因为它没有保证数据操作的原子性。在多线程环境下，进行复合操作（如自增、自减等，自增、自减包含读取、修改和写入三个步骤，可能会出现覆盖问题）时，<code>volatile</code> 无法保证操作的原子性，因此可能会导致线程安全问题。</p>
<h3 id="保证线程安全的解决方案"><a href="#保证线程安全的解决方案" class="headerlink" title="保证线程安全的解决方案"></a>保证线程安全的解决方案</h3><p>为了保证复合操作的线程安全，可以使用以下方法：</p>
<ol>
<li><p><strong><code>synchronized</code> 关键字</strong>：使用 <code>synchronized</code> 关键字来同步代码块或方法，确保同一时刻只有一个线程能访问这些代码。</p>
</li>
<li><p><strong><code>Lock</code> 接口和 <code>ReentrantLock</code> 类</strong>：使用 <code>Lock</code> 接口和 <code>ReentrantLock</code> 类来实现更灵活的锁机制，确保同一时刻只有一个线程能访问这些代码。</p>
</li>
<li><p><strong>原子类</strong>：使用 <code>java.util.concurrent.atomic</code> 包中的原子类（如 <code>AtomicInteger</code>）来实现原子操作，确保操作的原子性。</p>
</li>
</ol>
<h1 id="指令重排的原理"><a href="#指令重排的原理" class="headerlink" title="指令重排的原理"></a>指令重排的原理</h1><p>在执行程序时，为了提高性能，处理器和编译器往往会对指令进行重排优化。指令重排的目的是在不改变程序运行结果的前提下，优化指令的执行顺序，以提高处理器的执行效率。</p>
<h2 id="指令重排的原则"><a href="#指令重排的原则" class="headerlink" title="指令重排的原则"></a>指令重排的原则</h2><p>指令重排遵循以下两个原则：</p>
<ol>
<li><p><strong>不能改变程序的运行结果</strong>：指令重排不能改变单线程程序的运行结果。也就是说，无论指令如何重排，单线程程序的执行结果必须保持一致。</p>
</li>
<li><p><strong>存在依赖关系的指令不能进行重排</strong>：如果两条指令之间存在数据依赖关系（即一条指令的执行结果会影响另一条指令的执行），那么这两条指令不能进行重排。</p>
</li>
</ol>
<h2 id="指令重排的类型"><a href="#指令重排的类型" class="headerlink" title="指令重排的类型"></a>指令重排的类型</h2><p>指令重排可以分为以下几种类型：</p>
<ol>
<li><p><strong>编译器重排</strong>：编译器在生成机器码时，可能会对指令进行重排，以优化代码的执行顺序。</p>
</li>
<li><p><strong>处理器重排</strong>：处理器在执行指令时，可能会对指令进行重排，以提高指令流水线的效率。</p>
</li>
</ol>
<h2 id="指令重排的示例"><a href="#指令重排的示例" class="headerlink" title="指令重排的示例"></a>指令重排的示例</h2><p>以下是一个简单的示例代码，展示了指令重排的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorderingExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            b = <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> b;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> a;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>t1</code> 线程中的两条指令 <code>a = 1</code> 和 <code>b = 2</code> 之间没有数据依赖关系，因此编译器和处理器可能会对这两条指令进行重排。重排后的执行顺序可能是 <code>b = 2</code> 先执行，<code>a = 1</code> 后执行。</p>
<h2 id="指令重排的影响"><a href="#指令重排的影响" class="headerlink" title="指令重排的影响"></a>指令重排的影响</h2><p>指令重排在单线程环境下通常不会影响程序的运行结果，但在多线程环境下可能会导致不可预期的结果。例如，在上述示例中，如果 <code>t2</code> 线程在 <code>t1</code> 线程完成 <code>a = 1</code> 之前读取了 <code>b</code> 的值，那么 <code>t2</code> 线程可能会输出 <code>x = 2, y = 0</code>，这与预期的 <code>x = 2, y = 1</code> 不一致。</p>
<h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p>在多线程编程中，锁机制是保证线程安全的重要手段。根据线程获取锁的顺序，锁可以分为公平锁和非公平锁。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>公平锁（Fair Lock）是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p>
<p><strong>流程</strong></p>
<ol>
<li><strong>获取锁:</strong> 线程尝试获取锁，若锁已被占用，则将自身加入等待队列队尾，并进入休眠状态。</li>
<li><strong>释放锁:</strong> 持有锁的线程释放锁后，会唤醒等待队列队首的线程，该线程尝试获取锁。</li>
<li><strong>状态切换:</strong> 线程在运行和休眠状态之间切换，每次切换都需要进行用户态和内核态的转换，这种转换开销较大，导致公平锁执行速度较慢。</li>
</ol>
<h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><p>非公平锁（Non-Fair Lock）是指多个线程加锁时直接尝试获取锁，能抢到锁的线程直接占有锁，抢不到才会到等待队列的队尾等待。</p>
<p><strong>流程</strong></p>
<ol>
<li><strong>获取锁:</strong> 线程尝试通过CAS操作直接获取锁，若成功则直接持有锁，无需进入等待队列。</li>
<li><strong>竞争锁:</strong> 若CAS失败，线程才会进入等待队列，等待下次获取锁的机会。</li>
<li><strong>效率提升:</strong> 非公平锁避免了线程频繁的休眠和唤醒操作，减少了用户态和内核态的切换开销，从而提高了程序执行效率。</li>
</ol>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>公平锁与非公平锁的优缺点对比:</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取锁顺序</strong></td>
<td>严格按照等待队列顺序</td>
<td>不保证顺序，可能出现“插队”现象</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>较低，频繁的线程切换开销大</td>
<td>较高，减少了线程切换开销</td>
</tr>
<tr>
<td><strong>响应时间</strong></td>
<td>较长，新线程需要等待</td>
<td>较短，新线程有机会立即获取锁</td>
</tr>
<tr>
<td><strong>饥饿问题</strong></td>
<td>不易发生</td>
<td>可能发生，某些线程可能长时间无法获取锁</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>对公平性要求较高，例如银行排队系统</td>
<td>对性能要求较高，例如高并发场景</td>
</tr>
</tbody></table>
<p><code>Synchronized</code> 是不公平锁，<code>ReentrantLock</code> 默认情况下也是不公平锁，但可以通过构造函数参数指定为公平锁（在其获取锁的方法中，设置前置判断条件 <code>!hasQueuedPredecessors()</code>）。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">xiaoyan</div><div class="post-copyright__author_desc">无限进步。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/')">Java并发编程-并发安全篇</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java并发编程-并发安全篇&amp;url=http://example.com/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/&amp;pic=/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%AF%87/cover.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">XIAOYAN</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>编程语言<span class="categoryesPageCount">21</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">20</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>并发编程<span class="categoryesPageCount">3</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>并发安全<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发编程-多线程篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/2024/09/10/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AF%87/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java并发编程-线程池篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">是一只时时翻垃圾吃的宅子。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">xiaoyan</h1><div class="author-info__desc">无限进步。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoyanfufu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/483597064" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">如何保证多线程安全</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E9%94%81%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">Java 中常用的锁及其使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">什么是可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">可重入锁的工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">synchronized 和 ReentrantLock 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">synchronized 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">ReentrantLock 工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">synchronized 锁升级过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">锁升级过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">锁升级的触发条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS"><span class="toc-number">6.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">6.1.</span> <span class="toc-text">AQS 的核心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CLH-%E9%98%9F%E5%88%97"><span class="toc-number">6.1.1.</span> <span class="toc-text">CLH 队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">6.2.</span> <span class="toc-text">AQS 的核心组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">AQS 的工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal-%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">ThreadLocal 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">ThreadLocal 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">ThreadLocal 的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">核心操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.</span> <span class="toc-text">可能存在的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.1.</span> <span class="toc-text">内存泄漏问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">乐观锁&#x2F;悲观锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">Java 实现乐观锁的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">CAS 的缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile"><span class="toc-number">11.</span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E5%AF%B9%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">11.1.</span> <span class="toc-text">保证变量对所有线程的可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">11.2.</span> <span class="toc-text">禁止指令重排序优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E4%B8%8D%E8%83%BD%E5%AE%8C%E5%85%A8%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">11.3.</span> <span class="toc-text">volatile 不能完全保证线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">11.3.1.</span> <span class="toc-text">保证线程安全的解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">指令重排的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">12.1.</span> <span class="toc-text">指令重排的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">指令重排的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.3.</span> <span class="toc-text">指令重排的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">12.4.</span> <span class="toc-text">指令重排的影响</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">13.</span> <span class="toc-text">公平锁与非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">13.1.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">13.2.</span> <span class="toc-text">非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">13.3.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-分库分表"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表">数据库优化-分库分表</a><time datetime="2024-11-03T08:20:54.000Z" title="发表于 2024-11-03 16:20:54">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202411041125092.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-读写分离与冷热分离"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离">数据库优化-读写分离与冷热分离</a><time datetime="2024-11-03T08:18:25.000Z" title="发表于 2024-11-03 16:18:25">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410282316960.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-进程管理"/></a><div class="content"><a class="title" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理">操作系统-进程管理</a><time datetime="2024-10-28T14:52:35.000Z" title="发表于 2024-10-28 22:52:35">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410281041645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式事务"/></a><div class="content"><a class="title" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务">分布式-分布式事务</a><time datetime="2024-10-27T13:08:20.000Z" title="发表于 2024-10-27 21:08:20">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410272103963.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-服务治理（下）"/></a><div class="content"><a class="title" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）">分布式-服务治理（下）</a><time datetime="2024-10-21T07:24:49.000Z" title="发表于 2024-10-21 15:24:49">2024-10-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="xiaoyan" target="_blank">xiaoyan</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">17</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 0.88rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 0.88rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 0.88rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 0.88rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 0.88rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 0.88rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 0.88rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 0.88rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 0.88rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 0.88rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 0.88rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 0.88rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 0.88rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 0.88rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>