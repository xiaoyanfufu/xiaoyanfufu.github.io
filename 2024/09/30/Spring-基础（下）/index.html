<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Spring-基础（下） | XIAOYAN</title><meta name="keywords" content="Bean"><meta name="author" content="xiaoyan"><meta name="copyright" content="xiaoyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Spring-基础（下）"><meta name="application-name" content="Spring-基础（下）"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Spring-基础（下）"><meta property="og:url" content="http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/index.html"><meta property="og:site_name" content="XIAOYAN"><meta property="og:description" content="Spring设计Spring 如何解决循环依赖什么是循环依赖？循环依赖（Circular Dependency）是指两个或多个类之间互相依赖，形成一个闭环。例如，类 A 依赖类 B，而类 B 又依赖类 A，从而形成依赖闭环。循环依赖在软件设计中是一个常见的问题，尤其是在使用依赖注入（Dependen"><meta property="og:locale" content="zn-CN"><meta property="og:image" content="https://spring.io/img/extra/why-spring.svg"><meta property="article:author" content="xiaoyan"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://spring.io/img/extra/why-spring.svg"><meta name="description" content="Spring设计Spring 如何解决循环依赖什么是循环依赖？循环依赖（Circular Dependency）是指两个或多个类之间互相依赖，形成一个闭环。例如，类 A 依赖类 B，而类 B 又依赖类 A，从而形成依赖闭环。循环依赖在软件设计中是一个常见的问题，尤其是在使用依赖注入（Dependen"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: xiaoyan","link":"链接: ","source":"来源: XIAOYAN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XIAOYAN',
  title: 'Spring-基础（下）',
  postAI: '',
  pageFillDescription: 'Spring设计, Spring 如何解决循环依赖, 什么是循环依赖？, 循环依赖的三种情况, Spring 如何解决循环依赖, 三级缓存策略详解, 一级缓存（singletonObjects）, 二级缓存（earlySingletonObjects）, 三级缓存（singletonFactories）, 三级缓存策略的工作流程, Spring 设计模式, 1. 工厂模式（Factory Pattern）, 2. 代理模式（Proxy Pattern）, 3. 单例模式（Singleton Pattern）, 4. 模板方法模式（Template Method Pattern）, 5. 装饰器模式（Decorator Pattern）, 6. 观察者模式（Observer Pattern）, 7. 适配器模式（Adapter Pattern）, Spring 常用注解, 1. @Autowired 注解, 2. @Component 注解, 3. @Configuration 注解, 4. @Bean 注解, 5. @Service 注解, 6. @Repository 注解, 7. @Controller 注解, 总结, Spring 扩展机制, 1. BeanFactoryPostProcessor, 2. BeanPostProcessor, 3. PropertySource, 4. Spring MVC中的HandlerInterceptor, 5. Spring MVC中的ControllerAdvice, 6. Spring Boot的自动配置, 7. 自定义注解, 事务管理, Spring事务失效场景分析, 1. 未捕获的异常, 2. 未受检异常, 3. 事务属性传递不当, 4. 多数据源配置不当, 5. 事务调用外部方法, 6. 非公有方法, Spring事务中调用this是否生效？, Spring事务的实现机制, 调用this是否生效？, 原因分析, 解决方案, Bean, Spring Bean的生命周期, Spring Bean的单例与多例模式, 单例模式（Singleton）, 默认行为, 优点, 多例模式（Prototype）, 配置方式, 行为, 优点, Spring Bean的作用域, 在Bean加载x2F销毁前后增加自定义逻辑, 1. 使用init-method和destroy-method, XML配置示例, Bean类实现, 2. 实现InitializingBean接口和DisposableBean接口, Bean类实现, 3. 使用@PostConstruct注解和@PreDestroy注解, Bean类实现, 4. 使用@Bean注解的initMethod属性和destroyMethod属性, Java配置示例, Bean类实现, Bean注入与XML注入, Bean注解注入, XML注入, Spring MVC, 了解MVC, Spring MVC的处理流程, HandlerMapping与HandlerAdapter, HandlerMapping, HandlerAdapter设计如何解决循环依赖什么是循环依赖循环依赖是指两个或多个类之间互相依赖形成一个闭环例如类依赖类而类又依赖类从而形成依赖闭环循环依赖在软件设计中是一个常见的问题尤其是在使用依赖注入框架时循环依赖的三种情况在中循环依赖问题可以分为以下三种情况使用构造参数传递依赖构成的循环依赖问题两个类通过构造器注入形成循环依赖使用方法传递依赖且是原型模式下构成的循环依赖问题两个类通过方法注入形成循环依赖并且的作用域是原型使用方法传递依赖且是单例模式下构成的循环依赖问题两个类通过方法注入形成循环依赖并且的作用域是单例如何解决循环依赖在中只有第三种情况单例模式下使用方法构成的循环依赖被解决了其他两种情况在遇到循环依赖问题时仍然会抛出相应的异常通过三级缓存来解决单例模式下使用方法构成的循环依赖问题具体步骤如下实例化在实例化时会先创建一个空的对象并将其放入一级缓存中属性赋值当发现存在循环依赖时会先将当前暴露给后续的依赖从而解决循环依赖问题这一步通过提前暴露来解决循环依赖初始化完成属性赋值后将实例化并放入二级缓存中依赖注入继续对进行依赖注入如果发现循环注入会将二级缓存中的对象取出完成初始化的实例三级缓存策略详解在中三级缓存策略是解决单例模式下使用方法构成的循环依赖问题的核心机制三级缓存采用的都是类型的缓存数据结构用于存储不同阶段的实例以下是对三级缓存策略的详细解释一级缓存一级缓存使用存放完全初始化好的单例也就是开箱即用的实例一级缓存存放在中的属性中数据结构其中是的名称是完全初始化好的实例作用存放已经完全初始化好的单例这些可以直接使用二级缓存二级缓存使用存放已经实例化但还未完全初始化的这些可能还没有进行属性注入等操作二级缓存存放在中的属性中数据结构其中是的名称是已经实例化但还未完全初始化的实例作用存放提前暴露的这些已经实例化但还未完全初始化用于解决循环依赖问题三级缓存三级缓存同样是一个类型的缓存存储的是对象这些对象可以生成早期的引用当一个正在创建过程中如果被其他依赖那么这个正在创建的就会通过这个来创建一个早期引用从而解决循环依赖问题三级缓存存放在中的属性中数据结构其中是的名称是对象用于生成早期的引用作用存放工厂用于创建提前暴露的解决循环依赖问题三级缓存策略的工作流程实例化在实例化时会先创建一个空的对象并将其放入三级缓存中提前暴露当发现存在循环依赖时会先将当前暴露给后续的依赖从而解决循环依赖问题这一步通过将工厂放入三级缓存中来实现属性赋值完成属性赋值后将实例化并放入二级缓存中依赖注入继续对进行依赖注入如果发现循环注入会将二级缓存中的对象取出完成初始化的实例完全初始化当完全初始化后将其放入一级缓存中并从二级缓存和三级缓存中移除设计模式框架是一个高度模块化和可扩展的框架它广泛使用了多种设计模式来实现其核心功能以下是中常用的一些设计模式及其应用场景工厂模式工厂模式是一种创建型设计模式用于创建对象而不指定具体的类使用工厂模式来创建和管理对象的核心接口之一用于创建和管理实例提供了基本的创建和获取功能是的子接口提供了更高级的功能如国际化事件发布等代理模式代理模式是一种结构型设计模式用于为其他对象提供一个代理以控制对这个对象的访问通过使用反射机制和动态代理来实现切面编程适用于被代理对象实现了接口的情况适用于被代理对象没有实现接口的情况单例模式单例模式是一种创建型设计模式确保一个类只有一个实例并提供一个全局访问点中默认的都是单例的单例容器中的默认是单例的即在整个应用中只有一个实例模板方法模式模板方法模式是一种行为型设计模式定义了一个算法的骨架并允许子类在不改变算法结构的情况下重新定义算法的某些步骤中的和等就是模板方法模式的典型应用提供了数据库操作的模板方法子类可以通过实现回调接口来定义具体的操作装饰器模式装饰器模式是一种结构型设计模式允许动态地向对象添加功能中的实现类如就是装饰器模式的典型应用观察者模式观察者模式是一种行为型设计模式定义了对象之间的一对多依赖关系当一个对象状态发生改变时所有依赖它的对象都会收到通知并自动更新事件驱动模型就是一个典型的观察者模式中的事件类用于定义事件中的监听器接口用于监听事件适配器模式适配器模式是一种结构型设计模式用于将一个类的接口转换成客户端所期望的另一个接口的增强和通知使用了适配器模式中的控制器层也使用了适配器模式中的适配器接口用于将通知适配为增强中的适配器接口用于将控制器适配为处理器常用注解框架提供了丰富的注解来简化配置和开发过程以下是一些常用的注解及其作用注解注解主要用于自动装配当容器中存在与注入属性类型匹配的时它会自动将注入到属性中类似于对象一样注解注解用于将一个类标记为中的当一个类被标记后会将该类实例化为一个并将其存放到容器中注解注解用于将一个类标记为的配置类配置类可以包含注解的方法用于定义和配置作为全局配置注解注解用于标记一个方法将该方法作为的工厂方法当一个方法被注解标记时会将该方法的返回值作为一个并将其添加到容器中如果自定义配置会经常用到该注解注解注解用于将一个类标记为服务层的组件它是注解的特例用于标记服务层的一般用于标记服务层的实现类注解注解通常用于标记一个类作为数据访问层的组件它也是注解的特例用于标记数据访问层的组件该注解开发过程中很容易忘记而导致无法访问数据库注解注解通常用于标记一个类作为控制层的组件它也是注解的特例用于标记控制层的总结框架提供了丰富的注解来简化配置和开发过程通过合理使用这些注解可以提高代码的可读性可维护性和可扩展性以下是这些注解的简要总结注解作用自动装配将类标记为将类标记为配置类将方法标记为工厂方法将类标记为服务层组件将类标记为数据访问层组件将类标记为控制层组件扩展机制框架提供了丰富的扩展机制使得开发者可以根据自己的需求定制和扩展的功能以下是一些常用的扩展点及其详细介绍允许在容器实例化之前修改的定义开发者可以通过实现该接口在实例化之前对定义进行自定义处理修改定义允许在实例化配置以及初始化的前后对其进行额外的处理开发者可以通过实现该接口在生命周期的关键点插入自定义逻辑初始化前的处理逻辑初始化后的处理逻辑用于定义不同的属性源如文件数据库等以便在应用中使用开发者可以通过自定义来加载和使用外部属性配置类中的用于拦截处理请求可以在请求处理前处理中和处理后执行特定逻辑开发者可以通过实现该接口在请求处理的不同阶段插入自定义逻辑请求处理前的逻辑请求处理中的逻辑请求处理后的逻辑中的用于全局处理控制器的异常数据绑定和校验开发者可以通过实现该接口在控制器处理请求时插入全局逻辑异常处理逻辑的自动配置提供了自动配置机制开发者可以通过创建配置类实现对框架和第三方库的自动配置自定义注解支持自定义注解开发者可以通过创建自定义注解来实现特定的功能事务管理事务失效场景分析在应用中事务管理是确保数据一致性和完整性的关键机制通过其事务管理模块特别是注解来实现事务操作然而事务失效的情况时有发生这通常是由于配置不当或代码实现中的细微问题所致以下是一些可能导致事务失效的典型场景及其深入分析未捕获的异常场景描述当一个异常未被捕获并且该异常未被处理或传播至事务边界之外时事务会失效深入分析在中默认情况下事务会在遇到未捕获的异常时自动回滚然而如果异常被捕获但未重新抛出或者异常被捕获后通过某种方式被吞噬事务管理器将无法感知到异常的发生从而导致事务无法回滚解决方案确保所有可能引发异常的代码路径都被正确处理并在必要时重新抛出异常以便事务管理器能够检测到异常并触发回滚操作未受检异常场景描述默认情况下会对未受检异常如及其子类进行回滚此时事务失效深入分析未受检异常通常表示程序逻辑中的错误或不可恢复的情况默认将这些异常视为事务失败的信号并触发回滚操作然而如果开发者未意识到这一点可能会在代码中无意间抛出未受检异常导致事务失效解决方案在编写代码时应尽量避免抛出未受检异常或者在必要时通过注解的属性显式指定哪些异常应触发回滚事务属性传递不当场景描述当事务内存在嵌套事务且传播了一定的属性时若传播的属性配置不当可能导致事务失效深入分析提供了多种事务传播行为如等这些行为决定了事务如何在方法调用链中传播如果传播行为配置不当可能会导致事务边界不明确从而引发事务失效解决方案仔细选择和配置事务传播行为确保每个方法调用链中的事务边界清晰且符合业务逻辑需求多数据源配置不当场景描述当事务操作涉及多个数据源时若配置文件不当可能导致事务失效深入分析在多数据源场景下需要明确指定每个事务操作所涉及的数据源如果配置不当可能会导致事务管理器无法正确识别和处理事务从而引发事务失效解决方案确保多数据源配置正确并在必要时使用注解的属性显式指定事务管理器事务调用外部方法场景描述当事务内调用其他方法且其他方法未使用标记可能导致事务失效深入分析在中事务是通过代理机制实现的如果一个事务方法调用了另一个未标记为事务的方法的事务代理将无法拦截该调用从而导致事务失效解决方案确保所有需要事务支持的方法都使用注解进行标记或者通过面向切面编程机制显式配置事务拦截非公有方法场景描述如果标记在私有方法或其他非公有方法上事务也会失效深入分析的事务管理依赖于代理机制而代理机制通常只能拦截公有方法的调用因此如果注解被应用于非公有方法如私有方法受保护方法或包级私有方法将无法创建事务代理从而导致事务失效解决方案将注解应用于公有方法或者通过机制显式配置事务拦截事务中调用是否生效在事务管理中调用是否生效是一个常见且重要的技术问题为了深入理解这一问题我们需要从事务的实现机制入手事务的实现机制事务管理的核心机制是通过面向切面编程实现的具体来说使用代理模式来拦截被注解标记的方法并在方法执行前后插入事务管理逻辑调用是否生效结论在事务中调用是不生效的原因分析代理对象与目标对象分离在中事务管理是通过代理对象实现的代理对象与目标对象即实际的业务逻辑类是分离的当一个方法被注解标记时会创建一个代理对象来拦截该方法的调用引用指向目标对象在目标对象的方法内部引用指向的是目标对象本身而不是代理对象因此当在目标对象的方法内部调用引用的其他方法时实际上是直接调用了目标对象的方法绕过了代理对象的事务管理逻辑示例代码事务管理生效事务管理不生效因为是通过调用的业务逻辑在上面的示例中被注解标记因此会为其创建一个代理对象然而当内部调用时实际上是直接调用了目标对象的绕过了代理对象的事务管理逻辑导致的事务管理不生效解决方案为了避免上述问题可以采用以下几种解决方案注入代理对象通过依赖注入的方式获取代理对象而不是直接使用引用注入代理对象事务管理生效通过代理对象调用事务管理生效业务逻辑使用切面通过切面显式配置事务拦截逻辑事务管理逻辑在事务管理中调用是不生效的因为引用指向的是目标对象而不是代理对象为了避免事务失效可以通过注入代理对象或使用切面来确保事务管理逻辑的正确执行的生命周期框架的核心之一是其强大的依赖注入和控制反转机制而的生命周期管理则是这一机制的重要组成部分理解的生命周期对于掌握框架的工作原理和优化应用性能至关重要以下是生命周期的详细步骤实例化容器启动时首先会查找并加载需要被管理的定义然后容器会根据定义创建实例实例化过程通常涉及调用的构造函数属性注入实例化之后容器会根据定义中的配置将依赖的引用和属性值注入到实例中这一过程通常通过调用的方法或直接设置字段值来完成实现接口如果实现了接口容器会在属性注入完成后调用方法将的名称通常是的传递给实现接口如果实现了接口容器会在阶段之后调用方法将实例传递给实现接口如果实现了接口容器会在阶段之后调用方法将实例传递给前置处理器如果实现了接口容器会在初始化之前调用方法这一阶段允许开发者在初始化之前对其进行自定义处理初始化在前置处理之后容器会进行的初始化实现接口如果实现了接口容器会调用方法自定义初始化方法如果定义中通过属性指定了初始化方法容器会调用该方法后置处理器在初始化之后容器会调用的方法这一阶段允许开发者在初始化之后对其进行自定义处理的使用此时已经完全初始化并准备好被使用将在应用上下文中驻留直至应用上下文被销毁的销毁当应用上下文被销毁时容器会进行的销毁处理实现接口如果实现了接口容器会调用方法自定义销毁方法如果定义中通过属性指定了销毁方法容器会调用该方法的单例与多例模式在框架中的实例化模式是一个重要的配置选项它决定了在应用中的创建和使用方式默认采用单例模式但也可以根据需要配置为多例模式以下是对这两种模式的详细解释及其生命周期的差异单例模式默认行为在中默认是单例的这意味着在整个应用上下文中每个定义只会创建一个实例并将其缓存起来当需要使用该时容器会从缓存中取出该实例而不是重新创建优点提高性能由于实例只创建一次减少了频繁创建和销毁对象的开销节省内存单例在整个应用中共享减少了内存占用提高复用率单例可以在多个地方重复使用减少了对象的创建和销毁次数多例模式配置方式要将配置为多例模式可以在定义中设置属性为例如或者在配置中行为在多例模式下每次请求该时容器都会创建一个新的实例这意味着每个请求都会得到一个独立的实例对于多例容器只负责创建实例并将实例交给使用者不会管理多例的完整生命周期优点隔离性每个请求都得到一个独立的实例避免了状态共享的问题灵活性适用于需要频繁创建和销毁对象的场景的作用域在框架中的作用域定义了其生命周期与可见性不同的作用域决定了容器如何管理这些实例包括它们的创建销毁以及是否被多个用户共享提供了多种作用域以满足不同的应用需求单例是的默认作用域在整个应用中只会创建一次实例容器在整个生命周期中管理该实例并将其缓存起来供多个用户共享这种作用域适用于无状态的如服务层层等以及需要全局共享的多例作用域下每次请求都会新建一个实例新的实例交由使用者后容器将不再管理该实例的后续生命周期这种作用域适用于有状态的如表单对象对话框等以及需要频繁创建和销毁的请求作用域在每个请求时生成一个新的实例仅在应用程序中有效适用于需要在单个请求中保持状态的会话作用域在范围内只会创建一个实例该实例仅在会话范围内共享这种作用域适用于需要在用户会话中保持状态的如用户购物车应用作用域在当前中仅存在一个实例适用于需要在整个应用中共享的如全局配置对象作用域在范围内仅存在一个实例适用于需要在会话中保持状态的还允许开发者自定义作用域通过实现接口来自定义的作用域这种自定义作用域适用于需要特殊生命周期管理的在加载销毁前后增加自定义逻辑在框架中开发者可以通过多种方式在加载和销毁前后增加自定义逻辑这些方式包括使用生命周期回调接口注解以及配置以下是详细的方法介绍使用和在配置中可以通过和属性指定的初始化和销毁方法配置示例类实现初始化逻辑销毁逻辑实现接口和接口提供了两个生命周期回调接口和通过实现这两个接口可以在初始化和销毁时执行自定义逻辑类实现初始化逻辑销毁逻辑使用注解和注解支持使用注解和来指定的初始化和销毁方法类实现初始化逻辑销毁逻辑使用注解的属性和属性在配置中可以使用注解的和属性来指定的初始化和销毁方法配置示例类实现初始化逻辑销毁逻辑注入与注入在框架中的注入方式主要有两种注解注入和注入这两种方式各有优缺点适用于不同的场景以下是对这两种注入方式的详细解释及其底层执行步骤注解注入注解注入是中常用的一种依赖注入方式通过在类和属性上使用特定的注解容器可以自动完成的注册和依赖注入执行步骤如下类路径扫描当容器启动时它会进行类路径扫描查找带有特定注解的类如等这些注解标记的类会被容器识别为候选注册定义找到的类会被注册到中容器会为其生成定义信息包括类的全限定名作用域依赖关系等依赖注入在对进行实例化时容器会检查属性中是否存在或注解如果有会根据注解的信息进行依赖注入注入方式可以是构造函数注入方法注入或字段注入注入注入是早期常用的依赖注入方式通过在配置文件中定义及其依赖关系容器可以完成的注册和依赖注入执行步骤如下定义解析容器通过类解析配置文件读取其中的标签以获取的定义信息解析后的信息包括类的全限定名作用域依赖关系初始化和销毁方法等注册定义解析后的信息将被注册到中容器会根据这些信息生成定义实例化和依赖注入当应用程序请求某个时容器会根据已有的定义使用反射机制创建该实例然后根据定义中的配置通过构造函数方法或字段声明注入等方式注入所需要的依赖了解是一种经典的软件设计模式广泛应用于开发和其他类型的应用程序中模式通过将应用程序的不同职责分离到三个独立的组件中提高了代码的可维护性可扩展性和可重用性模型模型是应用程序的核心部分负责处理业务逻辑和数据操作模型可以分为两类数据承载这些是实体对象如等专门用于承载业务数据它们通常对应数据库中的表结构包含数据的属性和方法业务处理这些是服务层或数据访问层对象如等专门用于处理用户发起的请求它们负责执行业务逻辑数据验证数据持久化等操作视图视图是用户界面负责向用户展示数据和接收用户的输入视图通常是等前端技术实现的页面或组件控制器控制器是模型和视图之间的桥梁负责处理用户请求并将其转发给相应的模型进行处理控制器根据模型的计算结果决定如何更新视图的处理流程是框架中的一个重要模块用于构建基于模式的应用程序的处理流程涵盖了从用户请求到最终响应的整个过程以下是对处理流程的详细解释用户发送请求到前端控制器用户通过浏览器或其他客户端发送请求到应用程序请求首先被前端控制器接收调用处理器映射器接收到请求后会调用处理器映射器以确定哪个处理器应该处理该请求处理器映射器生成处理器执行链根据请求的找到具体的处理器并生成一个处理器执行链该执行链包括处理器对象和处理器拦截器如果有配置获取处理器适配器根据处理器获取相应的处理器适配器处理器适配器负责执行处理器的方法处理器适配器执行处理器执行处理器的方法进行一系列处理操作如数据封装参数解析等处理器执行完成返回处理器执行完成后返回一个对象包含视图名称和模型数据将返回给将处理器返回的对象传递给调用视图解析器接收到后调用视图解析器根据视图名称解析出具体的视图对象解析视图并返回给解析视图名称找到对应的视图对象如等并将其返回给对视图进行渲染将模型数据传递给视图对象并调用视图对象的渲染方法生成最终的或其他格式的响应内容响应用户将渲染后的响应内容返回给用户完成整个请求处理流程与在框架中和是两个关键组件它们协同工作以处理用户请求并调用相应的控制器方法以下是对这两个组件的详细解释及其工作流程的主要作用是将请求映射到相应的控制器方法它根据请求的方法请求参数等信息确定哪个控制器方法应该处理该请求工作流程接收请求接收到请求调用调用请求其查找处理该请求的控制器方法查找处理器根据请求的方法等信息查找并返回一个对象该对象包含处理器和拦截器如果有配置返回将返回给的主要作用是调用处理器方法来处理请求它负责解析请求参数调用控制器方法处理返回值等操作工作流程接收接收到返回的获取根据处理器的类型获取相应的调用处理器方法调用处理器的方法进行请求处理处理返回值处理处理器方法的返回值生成对象返回将返回给和是框架中的两个关键组件它们协同工作以处理用户请求并调用相应的控制器方法负责将请求映射到控制器方法而负责调用控制器方法并处理返回值',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 11:40:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/images/star.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XIAOYAN</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 1.05rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 1.05rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 1.05rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 1.05rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 1.05rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.05rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 1.05rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 1.05rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 1.05rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 1.05rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 1.05rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Spring/" itemprop="url">Spring</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Bean/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Bean</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Spring-基础（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-30T03:48:28.000Z" title="发表于 2024-09-30 11:48:28">2024-09-30</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.443Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为桂林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>桂林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://spring.io/img/extra/why-spring.svg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Spring/" itemprop="url">Spring</a><a href="/tags/Bean/" tabindex="-1" itemprop="url">Bean</a><h1 id="CrawlerTitle" itemprop="name headline">Spring-基础（下）</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">xiaoyan</span><time itemprop="dateCreated datePublished" datetime="2024-09-30T03:48:28.000Z" title="发表于 2024-09-30 11:48:28">2024-09-30</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.443Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></header><h1 id="Spring设计"><a href="#Spring设计" class="headerlink" title="Spring设计"></a>Spring设计</h1><h2 id="Spring-如何解决循环依赖"><a href="#Spring-如何解决循环依赖" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h2><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h3><p>循环依赖（Circular Dependency）是指两个或多个类之间互相依赖，形成一个闭环。例如，类 A 依赖类 B，而类 B 又依赖类 A，从而形成依赖闭环。循环依赖在软件设计中是一个常见的问题，尤其是在使用依赖注入（Dependency Injection, DI）框架时。</p>
<h3 id="循环依赖的三种情况"><a href="#循环依赖的三种情况" class="headerlink" title="循环依赖的三种情况"></a>循环依赖的三种情况</h3><p>在 Spring 中，循环依赖问题可以分为以下三种情况：</p>
<ol>
<li><strong>使用构造参数传递依赖构成的循环依赖问题</strong>：两个类通过构造器注入形成循环依赖。</li>
<li><strong>使用 setter 方法传递依赖且是原型模式下构成的循环依赖问题</strong>：两个类通过 setter 方法注入形成循环依赖，并且 Bean 的作用域是原型（Prototype）。</li>
<li><strong>使用 setter 方法传递依赖且是单例模式下构成的循环依赖问题</strong>：两个类通过 setter 方法注入形成循环依赖，并且 Bean 的作用域是单例（Singleton）。</li>
</ol>
<h3 id="Spring-如何解决循环依赖-1"><a href="#Spring-如何解决循环依赖-1" class="headerlink" title="Spring 如何解决循环依赖"></a>Spring 如何解决循环依赖</h3><p>在 Spring 中，只有第三种情况（单例模式下使用 setter 方法构成的循环依赖）被解决了，其他两种情况在遇到循环依赖问题时，Spring 仍然会抛出相应的异常。</p>
<p>Spring 通过三级缓存（Three-Level Cache）来解决单例模式下使用 setter 方法构成的循环依赖问题。具体步骤如下：</p>
<ol>
<li><p><strong>实例化 Bean</strong>：Spring 在实例化 Bean 时，会先创建一个空的 Bean 对象，并将其放入一级缓存（<code>singletonObjects</code>）中。</p>
</li>
<li><p><strong>属性赋值</strong>：当 Spring 发现存在循环依赖时，会先将当前 Bean 暴露给后续的依赖 Bean，从而解决循环依赖问题。这一步<strong>通过提前暴露 Bean 来解决循环依赖</strong>。</p>
</li>
<li><p><strong>Bean 初始化</strong>：完成属性赋值后，Spring 将 Bean 实例化，并放入二级缓存（<code>earlySingletonObjects</code>）中。</p>
</li>
<li><p><strong>依赖注入</strong>：Spring 继续对 Bean 进行依赖注入，如果发现循环注入，会将二级缓存中的 Bean 对象取出，完成初始化的 Bean 实例。</p>
</li>
</ol>
<h2 id="三级缓存策略详解"><a href="#三级缓存策略详解" class="headerlink" title="三级缓存策略详解"></a>三级缓存策略详解</h2><p>在 Spring 中，三级缓存策略是解决单例模式下使用 setter 方法构成的循环依赖问题的核心机制。三级缓存采用的都是 <code>Map</code> 类型的缓存数据结构，用于存储不同阶段的 Bean 实例。以下是对三级缓存策略的详细解释：</p>
<h3 id="一级缓存（singletonObjects）"><a href="#一级缓存（singletonObjects）" class="headerlink" title="一级缓存（singletonObjects）"></a>一级缓存（<code>singletonObjects</code>）</h3><p><strong>一级缓存</strong> 使用 <code>Map</code> 存放完全初始化好的单例 Bean，也就是开箱即用的 Bean 实例。一级缓存存放在 <code>DefaultSingletonBeanRegistry</code> 中的 <code>singletonObjects</code> 属性中。</p>
<ul>
<li><strong>数据结构</strong>：<code>Map&lt;String, Object&gt;</code>，其中 <code>key</code> 是 Bean 的名称，<code>value</code> 是完全初始化好的 Bean 实例。</li>
<li><strong>作用</strong>：存放已经完全初始化好的单例 Bean，这些 Bean 可以直接使用。</li>
</ul>
<h3 id="二级缓存（earlySingletonObjects）"><a href="#二级缓存（earlySingletonObjects）" class="headerlink" title="二级缓存（earlySingletonObjects）"></a>二级缓存（<code>earlySingletonObjects</code>）</h3><p><strong>二级缓存</strong> 使用 <code>Map</code> 存放已经实例化但还未完全初始化的 Bean。这些 Bean 可能还没有进行属性注入等操作。二级缓存存放在 <code>DefaultSingletonBeanRegistry</code> 中的 <code>earlySingletonObjects</code> 属性中。</p>
<ul>
<li><strong>数据结构</strong>：<code>Map&lt;String, Object&gt;</code>，其中 <code>key</code> 是 Bean 的名称，<code>value</code> 是已经实例化但还未完全初始化的 Bean 实例。</li>
<li><strong>作用</strong>：存放提前暴露的 Bean，这些 Bean 已经实例化但还未完全初始化，用于解决循环依赖问题。</li>
</ul>
<h3 id="三级缓存（singletonFactories）"><a href="#三级缓存（singletonFactories）" class="headerlink" title="三级缓存（singletonFactories）"></a>三级缓存（<code>singletonFactories</code>）</h3><p><strong>三级缓存</strong> 同样是一个 <code>Map</code> 类型的缓存，存储的是 <code>ObjectFactory</code> 对象，这些对象可以生成早期 Bean 的引用。当一个 Bean 正在创建过程中，如果被其他 Bean 依赖，那么这个正在创建的 Bean 就会通过这个 <code>ObjectFactory</code> 来创建一个早期引用，从而解决循环依赖问题。三级缓存存放在 <code>DefaultSingletonBeanRegistry</code> 中的 <code>singletonFactories</code> 属性中。</p>
<ul>
<li><strong>数据结构</strong>：<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code>，其中 <code>key</code> 是 Bean 的名称，<code>value</code> 是 <code>ObjectFactory</code> 对象，用于生成早期 Bean 的引用。</li>
<li><strong>作用</strong>：存放 Bean 工厂，用于创建提前暴露的 Bean，解决循环依赖问题。</li>
</ul>
<h3 id="三级缓存策略的工作流程"><a href="#三级缓存策略的工作流程" class="headerlink" title="三级缓存策略的工作流程"></a>三级缓存策略的工作流程</h3><ol>
<li><p><strong>实例化 Bean</strong>：Spring 在实例化 Bean 时，会先创建一个空的 Bean 对象，并将其放入三级缓存（<code>singletonFactories</code>）中。</p>
</li>
<li><p><strong>提前暴露 Bean</strong>：当 Spring 发现存在循环依赖时，会先将当前 Bean 暴露给后续的依赖 Bean，从而解决循环依赖问题。这一步通过将 Bean 工厂放入三级缓存中来实现。</p>
</li>
<li><p><strong>属性赋值</strong>：完成属性赋值后，Spring 将 Bean 实例化，并放入二级缓存（<code>earlySingletonObjects</code>）中。</p>
</li>
<li><p><strong>依赖注入</strong>：Spring 继续对 Bean 进行依赖注入，如果发现循环注入，会将二级缓存中的 Bean 对象取出，完成初始化的 Bean 实例。</p>
</li>
<li><p><strong>完全初始化</strong>：当 Bean 完全初始化后，Spring 将其放入一级缓存（<code>singletonObjects</code>）中，并从二级缓存和三级缓存中移除。</p>
</li>
</ol>
<h2 id="Spring-设计模式"><a href="#Spring-设计模式" class="headerlink" title="Spring 设计模式"></a>Spring 设计模式</h2><p>Spring 框架是一个高度模块化和可扩展的框架，它广泛使用了多种设计模式来实现其核心功能。以下是 Spring 中常用的一些设计模式及其应用场景：</p>
<h3 id="1-工厂模式（Factory-Pattern）"><a href="#1-工厂模式（Factory-Pattern）" class="headerlink" title="1. 工厂模式（Factory Pattern）"></a>1. 工厂模式（Factory Pattern）</h3><p><strong>工厂模式</strong> 是一种创建型设计模式，用于创建对象而不指定具体的类。Spring 使用工厂模式来创建和管理 Bean 对象。</p>
<ul>
<li><strong>BeanFactory</strong>：Spring 的核心接口之一，用于创建和管理 Bean 实例。<code>BeanFactory</code> 提供了基本的 Bean 创建和获取功能。</li>
<li><strong>ApplicationContext</strong>：<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，提供了更高级的功能，如国际化、事件发布等。</li>
</ul>
<h3 id="2-代理模式（Proxy-Pattern）"><a href="#2-代理模式（Proxy-Pattern）" class="headerlink" title="2. 代理模式（Proxy Pattern）"></a>2. 代理模式（Proxy Pattern）</h3><p><strong>代理模式</strong> 是一种结构型设计模式，用于为其他对象提供一个代理以控制对这个对象的访问。Spring AOP 通过使用反射机制和动态代理来实现切面编程。</p>
<ul>
<li><strong>JDK Proxy</strong>：适用于被代理对象实现了接口的情况。</li>
<li><strong>CGLIB</strong>：适用于被代理对象没有实现接口的情况。</li>
</ul>
<h3 id="3-单例模式（Singleton-Pattern）"><a href="#3-单例模式（Singleton-Pattern）" class="headerlink" title="3. 单例模式（Singleton Pattern）"></a>3. 单例模式（Singleton Pattern）</h3><p><strong>单例模式</strong> 是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。Spring 中默认的 Bean 都是单例的。</p>
<ul>
<li><strong>单例 Bean</strong>：Spring 容器中的 Bean 默认是单例的，即在整个应用中只有一个实例。</li>
</ul>
<h3 id="4-模板方法模式（Template-Method-Pattern）"><a href="#4-模板方法模式（Template-Method-Pattern）" class="headerlink" title="4. 模板方法模式（Template Method Pattern）"></a>4. 模板方法模式（Template Method Pattern）</h3><p><strong>模板方法模式</strong> 是一种行为型设计模式，定义了一个算法的骨架，并允许子类在不改变算法结构的情况下重新定义算法的某些步骤。Spring 中的 JdbcTemplate 和 HibernateTemplate 等就是模板方法模式的典型应用。</p>
<ul>
<li><strong>JdbcTemplate</strong>：提供了数据库操作的模板方法，子类可以通过实现回调接口来定义具体的操作。</li>
</ul>
<h3 id="5-装饰器模式（Decorator-Pattern）"><a href="#5-装饰器模式（Decorator-Pattern）" class="headerlink" title="5. 装饰器模式（Decorator Pattern）"></a>5. 装饰器模式（Decorator Pattern）</h3><p><strong>装饰器模式</strong> 是一种结构型设计模式，允许动态地向对象添加功能。Spring 中的 <code>DataSource</code> 实现类（如 <code>DataSourceTransactionManager</code>）就是装饰器模式的典型应用。</p>
<h3 id="6-观察者模式（Observer-Pattern）"><a href="#6-观察者模式（Observer-Pattern）" class="headerlink" title="6. 观察者模式（Observer Pattern）"></a>6. 观察者模式（Observer Pattern）</h3><p><strong>观察者模式</strong> 是一种行为型设计模式，定义了对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖它的对象都会收到通知并自动更新。Spring 事件驱动模型就是一个典型的观察者模式。</p>
<ul>
<li><strong>ApplicationEvent</strong>：Spring 中的事件类，用于定义事件。</li>
<li><strong>ApplicationListener</strong>：Spring 中的监听器接口，用于监听事件。</li>
</ul>
<h3 id="7-适配器模式（Adapter-Pattern）"><a href="#7-适配器模式（Adapter-Pattern）" class="headerlink" title="7. 适配器模式（Adapter Pattern）"></a>7. 适配器模式（Adapter Pattern）</h3><p><strong>适配器模式</strong> 是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。Spring AOP 的增强和通知使用了适配器模式，Spring MVC 中的控制器层也使用了适配器模式。</p>
<ul>
<li><strong>AdvisorAdapter</strong>：Spring AOP 中的适配器接口，用于将通知适配为增强。</li>
<li><strong>HandlerAdapter</strong>：Spring MVC 中的适配器接口，用于将控制器适配为处理器。</li>
</ul>
<h2 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h2><p>Spring 框架提供了丰富的注解（Annotation）来简化配置和开发过程。以下是一些常用的 Spring 注解及其作用：</p>
<h3 id="1-Autowired-注解"><a href="#1-Autowired-注解" class="headerlink" title="1. @Autowired 注解"></a>1. @Autowired 注解</h3><p><strong>@Autowired</strong> 注解主要用于自动装配（Dependency Injection）Bean。当 Spring 容器中存在与注入属性类型匹配的 Bean 时，它会自动将 Bean 注入到属性中，类似于 <code>new</code> 对象一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        myRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Component-注解"><a href="#2-Component-注解" class="headerlink" title="2. @Component 注解"></a>2. @Component 注解</h3><p><strong>@Component</strong> 注解用于将一个类标记为 Spring 中的 Bean。当一个类被 <code>@Component</code> 标记后，Spring 会将该类实例化为一个 Bean，并将其存放到 Bean 容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Doing something in MyComponent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Configuration-注解"><a href="#3-Configuration-注解" class="headerlink" title="3. @Configuration 注解"></a>3. @Configuration 注解</h3><p><strong>@Configuration</strong> 注解用于将一个类标记为 Spring 的配置类。配置类可以包含 <code>@Bean</code> 注解的方法，用于定义和配置 Bean，作为全局配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Bean-注解"><a href="#4-Bean-注解" class="headerlink" title="4. @Bean 注解"></a>4. @Bean 注解</h3><p><strong>@Bean</strong> 注解用于标记一个方法，将该方法作为 Spring 的 Bean 工厂方法。当一个方法被 <code>@Bean</code> 注解标记时，Spring 会将该方法的返回值作为一个 Bean，并将其添加到 Spring 容器中。如果自定义配置会经常用到该注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Service-注解"><a href="#5-Service-注解" class="headerlink" title="5. @Service 注解"></a>5. @Service 注解</h3><p><strong>@Service</strong> 注解用于将一个类标记为服务层的组件。它是 <code>@Component</code> 注解的特例，用于标记服务层的 Bean，一般用于标记服务层的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Doing something in MyService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Repository-注解"><a href="#6-Repository-注解" class="headerlink" title="6. @Repository 注解"></a>6. @Repository 注解</h3><p><strong>@Repository</strong> 注解通常用于标记一个类作为数据访问层的组件。它也是 <code>@Component</code> 注解的特例，用于标记数据访问层的组件，该注解开发过程中很容易忘记而导致无法访问数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRepository</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Saving data in MyRepository&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Controller-注解"><a href="#7-Controller-注解" class="headerlink" title="7. @Controller 注解"></a>7. @Controller 注解</h3><p><strong>@Controller</strong> 注解通常用于标记一个类作为控制层的组件。它也是 <code>@Component</code> 注解的特例，用于标记控制层的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring 框架提供了丰富的注解来简化配置和开发过程。通过合理使用这些注解，可以提高代码的可读性、可维护性和可扩展性。以下是这些注解的简要总结：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td>自动装配 Bean</td>
</tr>
<tr>
<td><code>@Component</code></td>
<td>将类标记为 Spring Bean</td>
</tr>
<tr>
<td><code>@Configuration</code></td>
<td>将类标记为 Spring 配置类</td>
</tr>
<tr>
<td><code>@Bean</code></td>
<td>将方法标记为 Spring Bean 工厂方法</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>将类标记为服务层组件</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>将类标记为数据访问层组件</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>将类标记为控制层组件</td>
</tr>
</tbody></table>
<h2 id="Spring-扩展机制"><a href="#Spring-扩展机制" class="headerlink" title="Spring 扩展机制"></a>Spring 扩展机制</h2><p>Spring框架提供了丰富的扩展机制，使得开发者可以根据自己的需求定制和扩展Spring的功能。以下是一些常用的扩展点及其详细介绍：</p>
<h3 id="1-BeanFactoryPostProcessor"><a href="#1-BeanFactoryPostProcessor" class="headerlink" title="1. BeanFactoryPostProcessor"></a>1. BeanFactoryPostProcessor</h3><p><code>BeanFactoryPostProcessor</code>允许在Spring容器实例化Bean之前修改Bean的定义。开发者可以通过实现该接口，在Bean实例化之前对Bean定义进行自定义处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 修改Bean定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-BeanPostProcessor"><a href="#2-BeanPostProcessor" class="headerlink" title="2. BeanPostProcessor"></a>2. BeanPostProcessor</h3><p><code>BeanPostProcessor</code>允许在Bean实例化、配置以及初始化的前后对其进行额外的处理。开发者可以通过实现该接口，在Bean生命周期的关键点插入自定义逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// Bean初始化前的处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// Bean初始化后的处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-PropertySource"><a href="#3-PropertySource" class="headerlink" title="3. PropertySource"></a>3. PropertySource</h3><p><code>PropertySource</code>用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。开发者可以通过自定义<code>PropertySource</code>来加载和使用外部属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:custom.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomPropertyConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Spring-MVC中的HandlerInterceptor"><a href="#4-Spring-MVC中的HandlerInterceptor" class="headerlink" title="4. Spring MVC中的HandlerInterceptor"></a>4. Spring MVC中的HandlerInterceptor</h3><p><code>HandlerInterceptor</code>用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑。开发者可以通过实现该接口，在请求处理的不同阶段插入自定义逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 请求处理前的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 请求处理中的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 请求处理后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Spring-MVC中的ControllerAdvice"><a href="#5-Spring-MVC中的ControllerAdvice" class="headerlink" title="5. Spring MVC中的ControllerAdvice"></a>5. Spring MVC中的ControllerAdvice</h3><p><code>ControllerAdvice</code>用于全局处理控制器的异常、数据绑定和校验。开发者可以通过实现该接口，在控制器处理请求时插入全局逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error: &quot;</span> + e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Spring-Boot的自动配置"><a href="#6-Spring-Boot的自动配置" class="headerlink" title="6. Spring Boot的自动配置"></a>6. Spring Boot的自动配置</h3><p>Spring Boot提供了自动配置机制，开发者可以通过创建配置类，实现对框架和第三方库的自动配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(name = &quot;custom.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CustomService <span class="title function_">customService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-自定义注解"><a href="#7-自定义注解" class="headerlink" title="7. 自定义注解"></a>7. 自定义注解</h3><p>Spring支持自定义注解，开发者可以通过创建自定义注解来实现特定的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h2 id="Spring事务失效场景分析"><a href="#Spring事务失效场景分析" class="headerlink" title="Spring事务失效场景分析"></a>Spring事务失效场景分析</h2><p>在Spring Boot应用中，事务管理是确保数据一致性和完整性的关键机制。Spring通过其事务管理模块，特别是<code>@Transactional</code>注解，来实现事务操作。然而，事务失效的情况时有发生，这通常是由于配置不当或代码实现中的细微问题所致。以下是一些可能导致Spring事务失效的典型场景及其深入分析：</p>
<h3 id="1-未捕获的异常"><a href="#1-未捕获的异常" class="headerlink" title="1. 未捕获的异常"></a>1. 未捕获的异常</h3><p><strong>场景描述：</strong> 当一个异常未被捕获，并且该异常未被处理或传播至事务边界之外时，事务会失效。</p>
<p><strong>深入分析：</strong> 在Spring中，默认情况下，事务会在遇到未捕获的异常时自动回滚。然而，如果异常被捕获但未重新抛出，或者异常被捕获后通过某种方式被“吞噬”，事务管理器将无法感知到异常的发生，从而导致事务无法回滚。</p>
<p><strong>解决方案：</strong> 确保所有可能引发异常的代码路径都被正确处理，并在必要时重新抛出异常，以便事务管理器能够检测到异常并触发回滚操作。</p>
<h3 id="2-未受检异常"><a href="#2-未受检异常" class="headerlink" title="2. 未受检异常"></a>2. 未受检异常</h3><p><strong>场景描述：</strong> 默认情况下，Spring会对未受检异常（如<code>RuntimeException</code>及其子类）进行回滚，此时事务失效。</p>
<p><strong>深入分析：</strong> 未受检异常通常表示程序逻辑中的错误或不可恢复的情况。Spring默认将这些异常视为事务失败的信号，并触发回滚操作。然而，如果开发者未意识到这一点，可能会在代码中无意间抛出未受检异常，导致事务失效。</p>
<p><strong>解决方案：</strong> 在编写代码时，应尽量避免抛出未受检异常，或者在必要时通过<code>@Transactional</code>注解的<code>rollbackFor</code>属性显式指定哪些异常应触发回滚。</p>
<h3 id="3-事务属性传递不当"><a href="#3-事务属性传递不当" class="headerlink" title="3. 事务属性传递不当"></a>3. 事务属性传递不当</h3><p><strong>场景描述：</strong> 当事务内存在嵌套事务且传播了一定的属性时，若传播的属性配置不当，可能导致事务失效。</p>
<p><strong>深入分析：</strong> Spring提供了多种事务传播行为（如<code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>NESTED</code>等），这些行为决定了事务如何在方法调用链中传播。如果传播行为配置不当，可能会导致事务边界不明确，从而引发事务失效。</p>
<p><strong>解决方案：</strong> 仔细选择和配置事务传播行为，确保每个方法调用链中的事务边界清晰且符合业务逻辑需求。</p>
<h3 id="4-多数据源配置不当"><a href="#4-多数据源配置不当" class="headerlink" title="4. 多数据源配置不当"></a>4. 多数据源配置不当</h3><p><strong>场景描述：</strong> 当事务操作涉及多个数据源时，若配置文件不当可能导致事务失效。</p>
<p><strong>深入分析：</strong> 在多数据源场景下，Spring需要明确指定每个事务操作所涉及的数据源。如果配置不当，可能会导致事务管理器无法正确识别和处理事务，从而引发事务失效。</p>
<p><strong>解决方案：</strong> 确保多数据源配置正确，并在必要时使用<code>@Transactional</code>注解的<code>value</code>属性显式指定事务管理器。</p>
<h3 id="5-事务调用外部方法"><a href="#5-事务调用外部方法" class="headerlink" title="5. 事务调用外部方法"></a>5. 事务调用外部方法</h3><p><strong>场景描述：</strong> 当事务内调用其他方法，且其他方法未使用<code>@Transactional</code>标记，可能导致事务失效。</p>
<p><strong>深入分析：</strong> 在Spring中，事务是通过代理机制实现的。如果一个事务方法调用了另一个未标记为事务的方法，Spring的事务代理将无法拦截该调用，从而导致事务失效。</p>
<p><strong>解决方案：</strong> 确保所有需要事务支持的方法都使用<code>@Transactional</code>注解进行标记，或者通过AOP（面向切面编程）机制显式配置事务拦截。</p>
<h3 id="6-非公有方法"><a href="#6-非公有方法" class="headerlink" title="6. 非公有方法"></a>6. 非公有方法</h3><p><strong>场景描述：</strong> 如果<code>@Transactional</code>标记在私有方法或其他非公有方法上，事务也会失效。</p>
<p><strong>深入分析：</strong> Spring的事务管理依赖于代理机制，而代理机制通常只能拦截公有方法的调用。因此，如果<code>@Transactional</code>注解被应用于非公有方法（如私有方法、受保护方法或包级私有方法），Spring将无法创建事务代理，从而导致事务失效。</p>
<p><strong>解决方案：</strong> 将<code>@Transactional</code>注解应用于公有方法，或者通过AOP机制显式配置事务拦截。</p>
<h2 id="Spring事务中调用this是否生效？"><a href="#Spring事务中调用this是否生效？" class="headerlink" title="Spring事务中调用this是否生效？"></a>Spring事务中调用<code>this</code>是否生效？</h2><p>在Spring事务管理中，调用<code>this</code>是否生效是一个常见且重要的技术问题。为了深入理解这一问题，我们需要从Spring事务的实现机制入手。</p>
<h3 id="Spring事务的实现机制"><a href="#Spring事务的实现机制" class="headerlink" title="Spring事务的实现机制"></a>Spring事务的实现机制</h3><p>Spring事务管理的核心机制是通过AOP（面向切面编程）实现的。具体来说，Spring使用代理模式来拦截被<code>@Transactional</code>注解标记的方法，并在方法执行前后插入事务管理逻辑。</p>
<h3 id="调用this是否生效？"><a href="#调用this是否生效？" class="headerlink" title="调用this是否生效？"></a>调用<code>this</code>是否生效？</h3><p><strong>结论：</strong> 在Spring事务中，调用<code>this</code>是不生效的。</p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><ol>
<li><p><strong>代理对象与目标对象分离</strong>：</p>
<ul>
<li>在Spring中，事务管理是通过代理对象实现的。代理对象与目标对象（即实际的业务逻辑类）是分离的。</li>
<li>当一个方法被<code>@Transactional</code>注解标记时，Spring会创建一个代理对象来拦截该方法的调用。</li>
</ul>
</li>
<li><p><strong><code>this</code>引用指向目标对象</strong>：</p>
<ul>
<li>在目标对象的方法内部，<code>this</code>引用指向的是目标对象本身，而不是代理对象。</li>
<li>因此，当在目标对象的方法内部调用<code>this</code>引用的其他方法时，实际上是直接调用了目标对象的方法，绕过了代理对象的事务管理逻辑。</li>
</ul>
</li>
</ol>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 事务管理生效</span></span><br><span class="line">        methodB(); <span class="comment">// 事务管理不生效，因为是通过this调用的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>methodA</code>被<code>@Transactional</code>注解标记，因此Spring会为其创建一个代理对象。然而，当<code>methodA</code>内部调用<code>this.methodB()</code>时，实际上是直接调用了目标对象的<code>methodB</code>，绕过了代理对象的事务管理逻辑，导致<code>methodB</code>的事务管理不生效。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了避免上述问题，可以采用以下几种解决方案：</p>
<ol>
<li><strong>注入代理对象</strong>：通过依赖注入的方式获取代理对象，而不是直接使用<code>this</code>引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService self; <span class="comment">// 注入代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 事务管理生效</span></span><br><span class="line">        self.methodB(); <span class="comment">// 通过代理对象调用，事务管理生效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用AOP切面</strong>：通过AOP切面显式配置事务拦截逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundTransactionalMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 事务管理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring事务管理中，调用<code>this</code>是不生效的，因为<code>this</code>引用指向的是目标对象，而不是代理对象。为了避免事务失效，可以通过注入代理对象或使用AOP切面来确保事务管理逻辑的正确执行。</p>
<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p>Spring框架的核心之一是其强大的依赖注入（DI）和控制反转（IoC）机制，而Bean的生命周期管理则是这一机制的重要组成部分。理解Spring Bean的生命周期对于掌握Spring框架的工作原理和优化应用性能至关重要。以下是Spring Bean生命周期的详细步骤：</p>
<ol>
<li><strong>实例化Bean</strong></li>
</ol>
<p>Spring容器启动时，首先会查找并加载需要被管理的Bean定义。然后，Spring容器会根据Bean定义创建Bean实例。实例化过程通常涉及调用Bean的构造函数。</p>
<ol start="2">
<li><strong>属性注入</strong></li>
</ol>
<p>Bean实例化之后，Spring容器会根据Bean定义中的配置，将依赖的Bean引用和属性值注入到Bean实例中。这一过程通常通过调用Bean的setter方法或直接设置字段值来完成。</p>
<ol start="3">
<li><strong>实现BeanNameAware接口</strong></li>
</ol>
<p>如果Bean实现了<code>BeanNameAware</code>接口，Spring容器会在属性注入完成后，调用<code>setBeanName(String name)</code>方法，将Bean的名称（通常是Bean的id）传递给Bean。</p>
<ol start="4">
<li><strong>实现BeanFactoryAware接口</strong></li>
</ol>
<p>如果Bean实现了<code>BeanFactoryAware</code>接口，Spring容器会在BeanNameAware阶段之后，调用<code>setBeanFactory(BeanFactory beanFactory)</code>方法，将BeanFactory实例传递给Bean。</p>
<ol start="5">
<li><strong>实现ApplicationContextAware接口</strong></li>
</ol>
<p>如果Bean实现了<code>ApplicationContextAware</code>接口，Spring容器会在BeanFactoryAware阶段之后，调用<code>setApplicationContext(ApplicationContext applicationContext)</code>方法，将ApplicationContext实例传递给Bean。</p>
<ol start="6">
<li><strong>前置处理器（BeanPostProcessor）</strong></li>
</ol>
<p>如果Bean实现了<code>BeanPostProcessor</code>接口，Spring容器会在初始化之前调用<code>postProcessBeforeInitialization(Object bean, String beanName)</code>方法。这一阶段允许开发者在Bean初始化之前对其进行自定义处理。</p>
<ol start="7">
<li><strong>初始化Bean</strong></li>
</ol>
<p>在BeanPostProcessor前置处理之后，Spring容器会进行Bean的初始化。</p>
<ul>
<li><strong>实现InitializingBean接口</strong>：如果Bean实现了<code>InitializingBean</code>接口，Spring容器会调用<code>afterPropertiesSet()</code>方法。</li>
<li><strong>自定义初始化方法</strong>：如果Bean定义中通过<code>init-method</code>属性指定了初始化方法，Spring容器会调用该方法。</li>
</ul>
<ol start="8">
<li><strong>后置处理器（BeanPostProcessor）</strong></li>
</ol>
<p>在Bean初始化之后，Spring容器会调用<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization(Object bean, String beanName)</code>方法。这一阶段允许开发者在Bean初始化之后对其进行自定义处理。</p>
<ol start="9">
<li><strong>Bean的使用</strong></li>
</ol>
<p>此时，Bean已经完全初始化并准备好被使用。Bean将在应用上下文中驻留，直至应用上下文被销毁。</p>
<ol start="10">
<li><strong>Bean的销毁</strong></li>
</ol>
<p>当应用上下文被销毁时，Spring容器会进行Bean的销毁处理。</p>
<ul>
<li><strong>实现DisposableBean接口</strong>：如果Bean实现了<code>DisposableBean</code>接口，Spring容器会调用<code>destroy()</code>方法。</li>
<li><strong>自定义销毁方法</strong>：如果Bean定义中通过<code>destroy-method</code>属性指定了销毁方法，Spring容器会调用该方法。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719570477922-ad595a67-be98-4272-9e13-8ad73dd75c13.png" alt="Spring Bean生命周期(图片来源小林coding)"></p>
<h2 id="Spring-Bean的单例与多例模式"><a href="#Spring-Bean的单例与多例模式" class="headerlink" title="Spring Bean的单例与多例模式"></a>Spring Bean的单例与多例模式</h2><p>在Spring框架中，Bean的实例化模式是一个重要的配置选项，它决定了Bean在应用中的创建和使用方式。Spring默认采用单例（Singleton）模式，但也可以根据需要配置为多例（Prototype）模式。以下是对这两种模式的详细解释及其生命周期的差异。</p>
<h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><h4 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h4><p>在Spring中，Bean默认是单例的。这意味着在整个应用上下文中，每个Bean定义只会创建一个实例，并将其缓存起来。当需要使用该Bean时，Spring容器会从缓存中取出该实例，而不是重新创建。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>提高性能</strong>：由于Bean实例只创建一次，减少了频繁创建和销毁对象的开销。</li>
<li><strong>节省内存</strong>：单例Bean在整个应用中共享，减少了内存占用。</li>
<li><strong>提高复用率</strong>：单例Bean可以在多个地方重复使用，减少了对象的创建和销毁次数。</li>
</ul>
<h3 id="多例模式（Prototype）"><a href="#多例模式（Prototype）" class="headerlink" title="多例模式（Prototype）"></a>多例模式（Prototype）</h3><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>要将Bean配置为多例模式，可以在Bean定义中设置<code>scope</code>属性为<code>prototype</code>。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者在Java配置中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h4><p>在多例模式下，每次请求该Bean时，Spring容器都会创建一个新的实例。这意味着每个请求都会得到一个独立的Bean实例。对于多例Bean，Spring容器只负责创建实例，并将实例交给使用者。Spring不会管理多例Bean的完整生命周期。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li><strong>隔离性</strong>：每个请求都得到一个独立的Bean实例，避免了状态共享的问题。</li>
<li><strong>灵活性</strong>：适用于需要频繁创建和销毁对象的场景。</li>
</ul>
<h2 id="Spring-Bean的作用域"><a href="#Spring-Bean的作用域" class="headerlink" title="Spring Bean的作用域"></a>Spring Bean的作用域</h2><p>在Spring框架中，Bean的作用域（Scope）定义了其生命周期与可见性。不同的作用域决定了Spring容器如何管理这些Bean实例，包括它们的创建、销毁以及是否被多个用户共享。Spring提供了多种作用域，以满足不同的应用需求。</p>
<ul>
<li><p><strong>Singleton（单例）</strong>是Spring的默认作用域，在整个应用中只会创建一次Bean实例。Spring容器在整个生命周期中管理该Bean实例，并将其缓存起来，供多个用户共享。这种作用域适用于无状态的Bean，如服务层、DAO层等，以及需要全局共享的Bean。</p>
</li>
<li><p><strong>Prototype（多例）</strong>作用域下，每次请求都会新建一个Bean实例。新的实例交由使用者后，容器将不再管理该实例的后续生命周期。这种作用域适用于有状态的Bean，如表单对象、对话框等，以及需要频繁创建和销毁的Bean。</p>
</li>
<li><p><strong>Request（请求）</strong>作用域在每个HTTP请求时生成一个新的Bean实例，仅在Spring Web应用程序中有效，适用于需要在单个HTTP请求中保持状态的Bean。</p>
</li>
<li><p><strong>Session（会话）</strong>作用域在Session范围内只会创建一个Bean实例，该Bean实例仅在会话范围内共享。这种作用域适用于需要在用户会话中保持状态的Bean，如用户购物车。</p>
</li>
<li><p><strong>Application（应用）</strong>作用域在当前ServletContext中仅存在一个Bean实例，适用于需要在整个应用中共享的Bean，如全局配置对象。</p>
</li>
<li><p><strong>WebSocket（WebSocket）</strong>作用域在WebSocket范围内仅存在一个Bean实例，适用于需要在WebSocket会话中保持状态的Bean。</p>
</li>
<li><p>Spring还允许开发者<strong>自定义作用域</strong>，通过实现<code>Scope</code>接口来自定义Bean的作用域。这种自定义作用域适用于需要特殊生命周期管理的Bean。</p>
</li>
</ul>
<h2 id="在Bean加载-销毁前后增加自定义逻辑"><a href="#在Bean加载-销毁前后增加自定义逻辑" class="headerlink" title="在Bean加载&#x2F;销毁前后增加自定义逻辑"></a>在Bean加载&#x2F;销毁前后增加自定义逻辑</h2><p>在Spring框架中，开发者可以通过多种方式在Bean加载和销毁前后增加自定义逻辑。这些方式包括使用生命周期回调接口、注解以及XML配置。以下是详细的方法介绍：</p>
<h3 id="1-使用init-method和destroy-method"><a href="#1-使用init-method和destroy-method" class="headerlink" title="1. 使用init-method和destroy-method"></a>1. 使用<code>init-method</code>和<code>destroy-method</code></h3><p>在XML配置中，可以通过<code>init-method</code>和<code>destroy-method</code>属性指定Bean的初始化和销毁方法。</p>
<h4 id="XML配置示例"><a href="#XML配置示例" class="headerlink" title="XML配置示例"></a>XML配置示例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBeanClass&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Bean类实现"><a href="#Bean类实现" class="headerlink" title="Bean类实现"></a>Bean类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-实现InitializingBean接口和DisposableBean接口"><a href="#2-实现InitializingBean接口和DisposableBean接口" class="headerlink" title="2. 实现InitializingBean接口和DisposableBean接口"></a>2. 实现<code>InitializingBean</code>接口和<code>DisposableBean</code>接口</h3><p>Spring提供了两个生命周期回调接口：<code>InitializingBean</code>和<code>DisposableBean</code>。通过实现这两个接口，可以在Bean初始化和销毁时执行自定义逻辑。</p>
<h4 id="Bean类实现-1"><a href="#Bean类实现-1" class="headerlink" title="Bean类实现"></a>Bean类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 销毁逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-PostConstruct注解和-PreDestroy注解"><a href="#3-使用-PostConstruct注解和-PreDestroy注解" class="headerlink" title="3. 使用@PostConstruct注解和@PreDestroy注解"></a>3. 使用<code>@PostConstruct</code>注解和<code>@PreDestroy</code>注解</h3><p>Spring支持使用JSR-250注解<code>@PostConstruct</code>和<code>@PreDestroy</code>来指定Bean的初始化和销毁方法。</p>
<h4 id="Bean类实现-2"><a href="#Bean类实现-2" class="headerlink" title="Bean类实现"></a>Bean类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-Bean注解的initMethod属性和destroyMethod属性"><a href="#4-使用-Bean注解的initMethod属性和destroyMethod属性" class="headerlink" title="4. 使用@Bean注解的initMethod属性和destroyMethod属性"></a>4. 使用<code>@Bean</code>注解的<code>initMethod</code>属性和<code>destroyMethod</code>属性</h3><p>在Java配置中，可以使用<code>@Bean</code>注解的<code>initMethod</code>和<code>destroyMethod</code>属性来指定Bean的初始化和销毁方法。</p>
<h4 id="Java配置示例"><a href="#Java配置示例" class="headerlink" title="Java配置示例"></a>Java配置示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyBeanClass <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBeanClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean类实现-3"><a href="#Bean类实现-3" class="headerlink" title="Bean类实现"></a>Bean类实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean注入与XML注入"><a href="#Bean注入与XML注入" class="headerlink" title="Bean注入与XML注入"></a>Bean注入与XML注入</h2><p>在Spring框架中，Bean的注入方式主要有两种：注解注入和XML注入。这两种方式各有优缺点，适用于不同的场景。以下是对这两种注入方式的详细解释及其底层执行步骤。</p>
<h3 id="Bean注解注入"><a href="#Bean注解注入" class="headerlink" title="Bean注解注入"></a>Bean注解注入</h3><p>注解注入是Spring中常用的一种依赖注入方式，通过在类和属性上使用特定的注解，Spring容器可以自动完成Bean的注册和依赖注入。执行步骤如下：</p>
<ol>
<li><p><strong>类路径扫描</strong>：当Spring容器启动时，它会进行类路径扫描，查找带有特定注解的类，如<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等。这些注解标记的类会被Spring容器识别为候选Bean。</p>
</li>
<li><p><strong>注册Bean定义</strong>：找到的类会被注册到<code>BeanDefinitionRegistry</code>中，Spring容器会为其生成Bean定义信息，包括类的全限定名、作用域、依赖关系等。</p>
</li>
<li><p><strong>依赖注入</strong>：在对Bean进行实例化时，Spring容器会检查属性中是否存在<code>@Autowired</code>、<code>@Inject</code>或<code>@Resource</code>注解。如果有，Spring会根据注解的信息进行依赖注入。注入方式可以是构造函数注入、setter方法注入或字段注入。</p>
</li>
</ol>
<h3 id="XML注入"><a href="#XML注入" class="headerlink" title="XML注入"></a>XML注入</h3><p>XML注入是Spring早期常用的依赖注入方式，通过在XML配置文件中定义Bean及其依赖关系，Spring容器可以完成Bean的注册和依赖注入。执行步骤如下：</p>
<ol>
<li><p><strong>Bean定义解析</strong>：Spring容器通过<code>XmlBeanDefinitionReader</code>类解析XML配置文件，读取其中的<code>&lt;bean&gt;</code>标签以获取Bean的定义信息。解析后的Bean信息包括类的全限定名、作用域、依赖关系、初始化和销毁方法等。</p>
</li>
<li><p><strong>注册Bean定义</strong>：解析后的Bean信息将被注册到<code>BeanDefinitionRegistry</code>中，Spring容器会根据这些信息生成Bean定义。</p>
</li>
<li><p><strong>实例化和依赖注入</strong>：当应用程序请求某个Bean时，Spring容器会根据已有的Bean定义，使用反射机制创建该Bean实例。然后根据Bean定义中的配置，通过构造函数、setter方法或字段声明注入等方式注入所需要的依赖Bean。</p>
</li>
</ol>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="了解MVC"><a href="#了解MVC" class="headerlink" title="了解MVC"></a>了解MVC</h2><p>MVC（Model-View-Controller）是一种经典的软件设计模式，广泛应用于Web开发和其他类型的应用程序中。MVC模式通过将应用程序的不同职责分离到三个独立的组件中，提高了代码的可维护性、可扩展性和可重用性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/06abb9ae8d3146d38d3537c2d9209799.png" alt="Spring MVC(图片来源网络)"></p>
<ol>
<li><strong>Model（模型）</strong></li>
</ol>
<p><strong>模型</strong>是应用程序的核心部分，负责处理业务逻辑和数据操作。模型可以分为两类：</p>
<ul>
<li><strong>数据承载Bean</strong>：这些是实体对象（如<code>User</code>、<code>Product</code>等），专门用于承载业务数据。它们通常对应数据库中的表结构，包含数据的属性和方法。</li>
<li><strong>业务处理Bean</strong>：这些是服务层或数据访问层对象（如<code>Service</code>、<code>Dao</code>等），专门用于处理用户发起的请求。它们负责执行业务逻辑、数据验证、数据持久化等操作。</li>
</ul>
<ol start="2">
<li><strong>View（视图）</strong></li>
</ol>
<p><strong>视图</strong>是用户界面，负责向用户展示数据和接收用户的输入。视图通常是HTML、JSP、Thymeleaf、React等前端技术实现的页面或组件。</p>
<ol start="3">
<li><strong>Controller（控制器）</strong></li>
</ol>
<p><strong>控制器</strong>是模型和视图之间的桥梁，负责处理用户请求并将其转发给相应的模型进行处理。控制器根据模型的计算结果，决定如何更新视图。</p>
<h2 id="Spring-MVC的处理流程"><a href="#Spring-MVC的处理流程" class="headerlink" title="Spring MVC的处理流程"></a>Spring MVC的处理流程</h2><p>Spring MVC是Spring框架中的一个重要模块，用于构建基于MVC模式的Web应用程序。Spring MVC的处理流程涵盖了从用户请求到最终响应的整个过程。以下是对Spring MVC处理流程的详细解释：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410041218731.png" alt="Spring MVC处理流程(图片来源网络)"></p>
<ol>
<li><p><strong>用户发送请求到前端控制器（DispatcherServlet）</strong>：用户通过浏览器或其他客户端发送HTTP请求到Spring MVC应用程序。请求首先被前端控制器<code>DispatcherServlet</code>接收。</p>
</li>
<li><p><strong>DispatcherServlet调用处理器映射器（HandlerMapping）</strong>：<code>DispatcherServlet</code>接收到请求后，会调用处理器映射器<code>HandlerMapping</code>，以确定哪个处理器（Controller）应该处理该请求。</p>
</li>
<li><p><strong>处理器映射器生成处理器执行链（HandlerExecutionChain）</strong>：<code>HandlerMapping</code>根据请求的URL找到具体的处理器（Controller），并生成一个处理器执行链<code>HandlerExecutionChain</code>。该执行链包括处理器对象和处理器拦截器（如果有配置）。</p>
</li>
<li><p><strong>DispatcherServlet获取处理器适配器（HandlerAdapter）</strong>：<code>DispatcherServlet</code>根据处理器（Controller）获取相应的处理器适配器<code>HandlerAdapter</code>。处理器适配器负责执行处理器（Controller）的方法。</p>
</li>
<li><p><strong>处理器适配器执行处理器（Controller）</strong>：<code>HandlerAdapter</code>执行处理器（Controller）的方法，进行一系列处理操作，如数据封装、参数解析等。</p>
</li>
<li><p><strong>处理器执行完成返回ModelAndView</strong>：处理器（Controller）执行完成后，返回一个<code>ModelAndView</code>对象。<code>ModelAndView</code>包含视图名称和模型数据。</p>
</li>
<li><p><strong>HandlerAdapter将ModelAndView返回给DispatcherServlet</strong>：<code>HandlerAdapter</code>将处理器（Controller）返回的<code>ModelAndView</code>对象传递给<code>DispatcherServlet</code>。</p>
</li>
<li><p><strong>DispatcherServlet调用视图解析器（ViewResolver）</strong>：<code>DispatcherServlet</code>接收到<code>ModelAndView</code>后，调用视图解析器<code>ViewResolver</code>，根据视图名称解析出具体的视图对象。</p>
</li>
<li><p><strong>ViewResolver解析视图并返回给DispatcherServlet</strong>：<code>ViewResolver</code>解析视图名称，找到对应的视图对象（如JSP、Thymeleaf等），并将其返回给<code>DispatcherServlet</code>。</p>
</li>
<li><p><strong>DispatcherServlet对视图进行渲染</strong>：<code>DispatcherServlet</code>将模型数据传递给视图对象，并调用视图对象的渲染方法，生成最终的HTML或其他格式的响应内容。</p>
</li>
<li><p><strong>DispatcherServlet响应用户</strong>：<code>DispatcherServlet</code>将渲染后的响应内容返回给用户，完成整个请求处理流程。</p>
</li>
</ol>
<h2 id="HandlerMapping与HandlerAdapter"><a href="#HandlerMapping与HandlerAdapter" class="headerlink" title="HandlerMapping与HandlerAdapter"></a>HandlerMapping与HandlerAdapter</h2><p>在Spring MVC框架中，<code>HandlerMapping</code>和<code>HandlerAdapter</code>是两个关键组件，它们协同工作以处理用户请求并调用相应的控制器方法。以下是对这两个组件的详细解释及其工作流程。</p>
<h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><p><code>HandlerMapping</code>的主要作用是将HTTP请求映射到相应的控制器（Controller）方法。它根据请求的URL、HTTP方法、请求参数等信息，<strong>确定哪个控制器方法应该处理该请求</strong>。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>接收请求</strong>：<code>DispatcherServlet</code>接收到HTTP请求。</li>
<li><strong>调用HandlerMapping</strong>：<code>DispatcherServlet</code>调用<code>HandlerMapping</code>，请求其查找处理该请求的控制器方法。</li>
<li><strong>查找处理器</strong>：<code>HandlerMapping</code>根据请求的URL、HTTP方法等信息，查找并返回一个<code>HandlerExecutionChain</code>对象。该对象包含处理器（Controller）和拦截器（如果有配置）。</li>
<li><strong>返回HandlerExecutionChain</strong>：<code>HandlerMapping</code>将<code>HandlerExecutionChain</code>返回给<code>DispatcherServlet</code>。</li>
</ol>
<h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><p><code>HandlerAdapter</code>的主要作用是<strong>调用处理器（Controller）方法来处理请求</strong>。它负责解析请求参数、调用控制器方法、处理返回值等操作。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>接收HandlerExecutionChain</strong>：<code>DispatcherServlet</code>接收到<code>HandlerMapping</code>返回的<code>HandlerExecutionChain</code>。</li>
<li><strong>获取HandlerAdapter</strong>：<code>DispatcherServlet</code>根据处理器（Controller）的类型，获取相应的<code>HandlerAdapter</code>。</li>
<li><strong>调用处理器方法</strong>：<code>HandlerAdapter</code>调用处理器（Controller）的方法，进行请求处理。</li>
<li><strong>处理返回值</strong>：<code>HandlerAdapter</code>处理处理器方法的返回值，生成<code>ModelAndView</code>对象。</li>
<li><strong>返回ModelAndView</strong>：<code>HandlerAdapter</code>将<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</li>
</ol>
<p><code>HandlerMapping</code>和<code>HandlerAdapter</code>是Spring MVC框架中的两个关键组件，它们协同工作以处理用户请求并调用相应的控制器方法。<code>HandlerMapping</code>负责将请求映射到控制器方法，而<code>HandlerAdapter</code>负责调用控制器方法并处理返回值。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">xiaoyan</div><div class="post-copyright__author_desc">无限进步。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/')">Spring-基础（下）</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Spring-基础（下）&amp;url=http://example.com/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/&amp;pic=https://spring.io/img/extra/why-spring.svg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">XIAOYAN</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>编程语言<span class="categoryesPageCount">21</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">20</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Spring/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Spring<span class="categoryesPageCount">5</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Bean/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Bean<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/30/Spring-%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://spring.io/img/extra/why-spring.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring-基础（上）</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/30/Spring-SpringBoot/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://ts1.cn.mm.bing.net/th/id/R-C.65c2ba6ee967ff5d49264727807ce0e2?rik=9OMwvi19owGYJQ&amp;riu=http%3a%2f%2fimg.skyheng.com%2fpicture%2fspringboot%2fspring_boot_icon.png&amp;ehk=V4kosVPO3PU%2f%2bTjRlv%2fzT77PpXdcbh%2bWam%2bGkPlpF%2fI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Boot</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">是一只时时翻垃圾吃的宅子。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">xiaoyan</h1><div class="author-info__desc">无限进步。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoyanfufu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/483597064" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">Spring设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.</span> <span class="toc-text">Spring 如何解决循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.1.2.</span> <span class="toc-text">循环依赖的三种情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-1"><span class="toc-number">1.1.3.</span> <span class="toc-text">Spring 如何解决循环依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">三级缓存策略详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%88singletonObjects%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">一级缓存（singletonObjects）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%88earlySingletonObjects%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">二级缓存（earlySingletonObjects）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%88singletonFactories%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">三级缓存（singletonFactories）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">三级缓存策略的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Spring 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 工厂模式（Factory Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 代理模式（Proxy Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Pattern%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 单例模式（Singleton Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method-Pattern%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 模板方法模式（Template Method Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator-Pattern%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 装饰器模式（Decorator Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 观察者模式（Observer Pattern）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. 适配器模式（Adapter Pattern）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">Spring 常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Autowired-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. @Autowired 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Component-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. @Component 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Configuration-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. @Configuration 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Bean-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. @Bean 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Service-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. @Service 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Repository-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.6.</span> <span class="toc-text">6. @Repository 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Controller-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.7.</span> <span class="toc-text">7. @Controller 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">Spring 扩展机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BeanFactoryPostProcessor"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BeanPostProcessor"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-PropertySource"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. PropertySource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring-MVC%E4%B8%AD%E7%9A%84HandlerInterceptor"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. Spring MVC中的HandlerInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring-MVC%E4%B8%AD%E7%9A%84ControllerAdvice"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. Spring MVC中的ControllerAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Spring-Boot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. Spring Boot的自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 自定义注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">Spring事务失效场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%AA%E6%8D%95%E8%8E%B7%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 未捕获的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%AA%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 未受检异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BC%A0%E9%80%92%E4%B8%8D%E5%BD%93"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 事务属性传递不当</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 多数据源配置不当</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8B%E5%8A%A1%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. 事务调用外部方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%9E%E5%85%AC%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. 非公有方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E4%B8%AD%E8%B0%83%E7%94%A8this%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Spring事务中调用this是否生效？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">Spring事务的实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8this%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">调用this是否生效？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">原因分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean"><span class="toc-number">3.</span> <span class="toc-text">Bean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E5%8D%95%E4%BE%8B%E4%B8%8E%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">Spring Bean的单例与多例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">单例模式（Singleton）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">默认行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Prototype%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">多例模式（Prototype）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Spring Bean的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Bean%E5%8A%A0%E8%BD%BD-%E9%94%80%E6%AF%81%E5%89%8D%E5%90%8E%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%BB%E8%BE%91"><span class="toc-number">3.4.</span> <span class="toc-text">在Bean加载&#x2F;销毁前后增加自定义逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8init-method%E5%92%8Cdestroy-method"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 使用init-method和destroy-method</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">XML配置示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">Bean类实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0InitializingBean%E6%8E%A5%E5%8F%A3%E5%92%8CDisposableBean%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 实现InitializingBean接口和DisposableBean接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%B1%BB%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">Bean类实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-PostConstruct%E6%B3%A8%E8%A7%A3%E5%92%8C-PreDestroy%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 使用@PostConstruct注解和@PreDestroy注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%B1%BB%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">Bean类实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E8%A7%A3%E7%9A%84initMethod%E5%B1%9E%E6%80%A7%E5%92%8CdestroyMethod%E5%B1%9E%E6%80%A7"><span class="toc-number">3.4.4.</span> <span class="toc-text">4. 使用@Bean注解的initMethod属性和destroyMethod属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">Java配置示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%B1%BB%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">Bean类实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%B3%A8%E5%85%A5%E4%B8%8EXML%E6%B3%A8%E5%85%A5"><span class="toc-number">3.5.</span> <span class="toc-text">Bean注入与XML注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">Bean注解注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E6%B3%A8%E5%85%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">XML注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">4.</span> <span class="toc-text">Spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3MVC"><span class="toc-number">4.1.</span> <span class="toc-text">了解MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Spring MVC的处理流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerMapping%E4%B8%8EHandlerAdapter"><span class="toc-number">4.3.</span> <span class="toc-text">HandlerMapping与HandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerMapping"><span class="toc-number">4.3.1.</span> <span class="toc-text">HandlerMapping</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HandlerAdapter"><span class="toc-number">4.3.2.</span> <span class="toc-text">HandlerAdapter</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-分库分表"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表">数据库优化-分库分表</a><time datetime="2024-11-03T08:20:54.000Z" title="发表于 2024-11-03 16:20:54">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202411041125092.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-读写分离与冷热分离"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离">数据库优化-读写分离与冷热分离</a><time datetime="2024-11-03T08:18:25.000Z" title="发表于 2024-11-03 16:18:25">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410282316960.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-进程管理"/></a><div class="content"><a class="title" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理">操作系统-进程管理</a><time datetime="2024-10-28T14:52:35.000Z" title="发表于 2024-10-28 22:52:35">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410281041645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式事务"/></a><div class="content"><a class="title" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务">分布式-分布式事务</a><time datetime="2024-10-27T13:08:20.000Z" title="发表于 2024-10-27 21:08:20">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410272103963.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-服务治理（下）"/></a><div class="content"><a class="title" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）">分布式-服务治理（下）</a><time datetime="2024-10-21T07:24:49.000Z" title="发表于 2024-10-21 15:24:49">2024-10-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="xiaoyan" target="_blank">xiaoyan</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">66</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">18</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 0.88rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 0.88rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 0.88rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 0.88rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 0.88rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 0.88rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 0.88rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 0.88rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 0.88rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 0.88rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 0.88rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 0.88rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 0.88rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 0.88rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>