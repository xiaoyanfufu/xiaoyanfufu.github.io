<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  
    <link rel="icon" href="/images/earthstars.png">
  
  
  <title>JVM-内存模型 | XIAOYAN</title>
  <link rel="canonical" href="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">
  <meta name="author" content="xiaoyan" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="内存模型" />
  
  <meta name="description" content="了解JVM内存模型根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Register）以及本地方法栈（Native Method Stacks）。此外，JVM还可以直接访问操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM-内存模型">
<meta property="og:url" content="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="XIAOYAN">
<meta property="og:description" content="了解JVM内存模型根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Register）以及本地方法栈（Native Method Stacks）。此外，JVM还可以直接访问操作系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png">
<meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410051050412.png">
<meta property="article:published_time" content="2024-10-05T00:28:49.000Z">
<meta property="article:modified_time" content="2024-10-05T09:39:02.596Z">
<meta property="article:author" content="xiaoyan">
<meta property="article:tag" content="内存模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png">
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kr-core.min.css" media="all"></link>
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/highlight.js/night-eighties.min.css" media="all"></link>
  
  <link rel="stylesheet" id="theme-light-css" href="/css/kr-theme/light.min.css" media="all"></link>
  <link rel="stylesheet" id="theme-dark-css" href="/css/kr-theme/dark.min.css" media="(prefers-color-scheme: dark)"></link>
  <script src="/js/kr-theme.min.js"></script>
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></link>
  
    <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></link>
  
  
    <link rel="stylesheet" href="/vendors/viewerjs@1.11.6/dist/viewer.min.css"></link>
  
  <!-- 不得不预先加载的一些JS文件 -->
  
    <script src="/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js"></script>
  
  <!-- 自定义站点横幅和背景 -->
  <style>
    
      .kratos-cover.kratos-cover-2 {
        background-image: url('/images/wallpaper_light.png');
      }
      html[data-theme="dark"] .kratos-cover.kratos-cover-2 {
        background-image: url('/images/wallpaper_dark.png');
      }
    
    
      @media(min-width:768px) {
        body.custom-background {
          background-image: url('/images/bg.webp');
        }
        html[data-theme="dark"] body.custom-background {
          background-image: url('/images/bg.webp');
        }
      }
    
    
      .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
      html[data-theme="dark"] .widget-kratos-about .photo-background {
        background-image: url('/images/default.webp');
      }
    
  </style>

  <!-- 额外的追加注入项 -->
  
    <link rel="stylesheet" href="/css/custom.css">

  
<meta name="generator" content="Hexo 7.3.0"></head>

    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    <li>
                                        
                                            <a href="/">
                                        
                                            
                                                <i class="fa fa-home"></i>
                                            
                                            首页
                                        </a>
                                        
                                    </li>
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">XIAOYAN</a></div>
                    <div id="kratos-nav-toggle-wrapper" class="nav-toggle">
                        <a id="kratos-nav-toggle" class="kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>XIAOYAN</h2> <br />
                        <span>山重水复疑无路，柳暗花明又一村。</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">


        

            

            <section class="kr-main-col col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">
    <div class="kratos-hentry kratos-page-inner clearfix">
        <header class="kratos-page-header">
            
                <h1 class="kratos-page-title text-center" itemprop="name headline">JVM-内存模型</h1>
            
            <ul class="kratos-page-meta text-center">
                <li><time datetime="2024-10-05T00:28:49.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-10-05</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">xiaoyan</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~17.10K
                        
                        字
                    </li>
                
                
                
            </ul>
        </header>
        <div class="kratos-page-content kr-post">
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">了解JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">元空间（Metaspace）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stacks%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stacks%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈（Native Method Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">堆内存（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">直接内存（Direct Memory）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9AJVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">1.7.</span> <span class="toc-text">扩展：JVM参数配置与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">栈中存放的是指针还是对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">栈中存储的是对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%86%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">为什么区分引用和对象很重要？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">堆的划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 新生代（Young Generation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Eden-Space"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1.1 Eden Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Survivor-Space"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">1.2 Survivor Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 老年代（Old Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 元空间（Metaspace）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%8C%BA%EF%BC%88Humongous-Region%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 大对象区（Humongous Region）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">JVM 堆和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">堆和栈的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">方法区中方法执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.</span> <span class="toc-text">方法区中的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">String保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String-abc-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">6.2.</span> <span class="toc-text">String s &#x3D; new String(&quot;abc&quot;) 执行过程中涉及的内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 堆内存（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88String-Pool%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 字符串常量池（String Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">3. 栈内存（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.2.4.</span> <span class="toc-text">执行过程详细步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">引用类型及其区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. 强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. 软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. 弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">4. 虚引用（Phantom Reference）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.</span> <span class="toc-text">弱引用应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.5.</span> <span class="toc-text">内存泄漏与内存溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">内存泄漏（Memory Leak）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88Out-of-Memory-OOM%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">内存溢出（Out of Memory, OOM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">内存溢出的常见原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="toc-number">6.6.</span> <span class="toc-text">JVM 内存溢出情况</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><h1 id="了解JVM内存模型"><a href="#了解JVM内存模型" class="headerlink" title="了解JVM内存模型"></a>了解JVM内存模型</h1><p>根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Register）以及本地方法栈（Native Method Stacks）。此外，JVM还可以直接访问操作系统提供的本地内存，这部分内存被称为直接内存（Direct Memory）。</p>
<p><img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png" alt="JVM运行时内存结构"></p>
<h2 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h2><p>元空间是JVM规范中方法区（Method Area）的实现，其本质与Java 7及之前版本中的永久代（Permanent Generation）类似。然而，元空间与永久代最大的区别在于，元空间并不位于JVM管理的内存区域，而是直接使用操作系统的本地内存。这种设计使得元空间的大小不再受限于JVM的堆内存限制，而是可以根据实际需求动态扩展。</p>
<h2 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h2><p>每个Java线程在创建时都会分配一个独立的虚拟机栈。栈中存储的是栈帧（Stack Frame），每个方法调用都会生成一个栈帧。栈帧中包含了局部变量表（Local Variable Table）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address）等信息。局部变量表主要存储基本数据类型（如int、float等）和对象引用（Reference）。虚拟机栈的大小可以是固定的，也可以是动态扩展的。</p>
<h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈与虚拟机栈的功能类似，主要区别在于虚拟机栈用于执行Java方法，而本地方法栈用于执行Native方法（即使用C&#x2F;C++等本地语言编写的方法）。本地方法栈的实现方式与虚拟机栈类似，也可以是固定大小或动态扩展的。</p>
<h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器是一个线程私有的内存区域，用于记录当前线程执行的字节码指令的地址。在多线程环境下，处理器在任意时刻只会执行一个线程的指令。为了确保线程切换后能够恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器。程序计数器的大小通常为一个字长（Word），即32位或64位，具体取决于JVM的实现。</p>
<h2 id="堆内存（Heap）"><a href="#堆内存（Heap）" class="headerlink" title="堆内存（Heap）"></a>堆内存（Heap）</h2><p>堆内存是JVM中所有线程共享的内存区域，用于存储对象实例和数组。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。堆内存的管理主要依赖于垃圾回收器（Garbage Collector, GC），当堆内存不足以分配新的对象实例时，JVM会抛出<code>OutOfMemoryError</code>异常。</p>
<p>在JDK 1.8及之后的版本中，字符串常量池（String Constant Pool）从永久代中移出，并被放置在堆内存中。这种设计优化了字符串常量的内存管理，避免了永久代内存溢出的问题。</p>
<h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>直接内存并不属于JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域。然而，在JDK 1.4中引入的NIO（New I&#x2F;O）类库中，提供了一种基于通道（Channel）和缓冲区（Buffer）的新的I&#x2F;O方式。NIO允许通过Native函数库直接分配堆外内存，并通过一个存储在堆内存中的<code>DirectByteBuffer</code>对象来引用和操作这块内存。这种设计在某些高性能场景下可以显著提升性能，因为它避免了Java堆和Native堆之间频繁的数据复制操作。</p>
<h2 id="扩展：JVM参数配置与分区"><a href="#扩展：JVM参数配置与分区" class="headerlink" title="扩展：JVM参数配置与分区"></a>扩展：JVM参数配置与分区</h2><p>在Java的JVM（Java虚拟机）中，配置JVM参数可以影响JVM的内存分配和性能。JVM的内存分区主要包括以下几个部分：</p>
<ol>
<li><strong>堆内存（Heap Memory）</strong>：用于存储对象实例。</li>
<li><strong>非堆内存（Non-Heap Memory）</strong>：包括方法区（Method Area）、运行时常量池（Runtime Constant Pool）、JIT编译代码等。</li>
<li><strong>栈内存（Stack Memory）</strong>：每个线程都有自己的栈，用于存储局部变量、方法调用等。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：用于执行本地方法（非Java代码）。</li>
<li><strong>PC寄存器（Program Counter Register）</strong>：每个线程都有自己的PC寄存器，用于存储当前执行指令的地址。</li>
</ol>
<p>以下是一些常见的JVM参数及其与内存分区的关系：</p>
<table>
<thead>
<tr>
<th>JVM参数</th>
<th>描述</th>
<th>影响的内存分区</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms&lt;size&gt;</code></td>
<td>设置JVM启动时的初始堆内存大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-Xmx&lt;size&gt;</code></td>
<td>设置JVM允许的最大堆内存大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-Xmn&lt;size&gt;</code></td>
<td>设置年轻代（Young Generation）的大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:NewRatio=&lt;ratio&gt;</code></td>
<td>设置年轻代与老年代的比例。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio=&lt;ratio&gt;</code></td>
<td>设置Eden区与Survivor区的比例。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code></td>
<td>设置方法区的最大大小（在Java 8及更高版本中，方法区被称为Metaspace）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize=&lt;size&gt;</code></td>
<td>设置方法区的初始大小。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-Xss&lt;size&gt;</code></td>
<td>设置每个线程的栈大小。</td>
<td>栈内存（Stack Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxDirectMemorySize=&lt;size&gt;</code></td>
<td>设置直接内存（Direct Memory）的最大大小。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:InitialHeapSize=&lt;size&gt;</code></td>
<td>设置JVM启动时的初始堆内存大小（等同于<code>-Xms</code>）。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxHeapSize=&lt;size&gt;</code></td>
<td>设置JVM允许的最大堆内存大小（等同于<code>-Xmx</code>）。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:PermSize=&lt;size&gt;</code></td>
<td>设置永久代（PermGen）的初始大小（在Java 8之前有效）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxPermSize=&lt;size&gt;</code></td>
<td>设置永久代的最大大小（在Java 8之前有效）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
</tbody></table>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><strong>堆内存</strong>：主要用于存储对象实例，是JVM内存中最大的一部分。通过<code>-Xms</code>和<code>-Xmx</code>可以控制堆内存的初始大小和最大大小。</li>
<li><strong>非堆内存</strong>：包括方法区、运行时常量池等，主要用于存储类的元数据、常量、静态变量等。在Java 8及更高版本中，方法区被称为Metaspace，通过<code>-XX:MaxMetaspaceSize</code>和<code>-XX:MetaspaceSize</code>进行配置。</li>
<li><strong>栈内存</strong>：每个线程都有自己的栈，用于存储局部变量、方法调用等。通过<code>-Xss</code>可以设置每个线程的栈大小。</li>
<li><strong>直接内存</strong>：通过<code>-XX:MaxDirectMemorySize</code>可以设置直接内存的最大大小，直接内存通常用于NIO操作。</li>
</ul>
<p>通过合理配置这些JVM参数，可以优化JVM的内存使用，避免内存溢出等问题，提升应用程序的性能。</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="栈中存放的是指针还是对象？"><a href="#栈中存放的是指针还是对象？" class="headerlink" title="栈中存放的是指针还是对象？"></a>栈中存放的是指针还是对象？</h2><p>在Java虚拟机（JVM）内存模型中，栈（Stack）用于存储线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例对象和数组。</p>
<h3 id="栈中存储的是对象引用"><a href="#栈中存储的是对象引用" class="headerlink" title="栈中存储的是对象引用"></a>栈中存储的是对象引用</h3><p>当我们在栈中讨论“存储”时，指的是存储基本类型的数据和对象的引用，而不是对象本身。具体来说：</p>
<ul>
<li><strong>基本类型数据</strong>：如<code>int</code>、<code>float</code>、<code>boolean</code>等，这些数据直接存储在栈中。</li>
<li><strong>对象引用</strong>：当我们在方法中声明一个对象时，比如<code>MyObject o = new MyObject();</code>，这里的<code>o</code>实际上是存储在栈中的引用（Reference），而不是对象本身。这个引用是一个固定大小的数据（例如在64位系统中是8字节），它指向堆中分配给对象的内存空间。</li>
</ul>
<p>考虑以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">primitive</span> <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// 基本类型数据，直接存储在栈中</span></span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(); <span class="comment">// 对象引用存储在栈中，对象实例存储在堆中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ol>
<li><code>primitive</code>是一个基本类型变量，其值<code>42</code>直接存储在栈中。</li>
<li><code>obj</code>是一个对象引用，它存储在栈中，指向堆中<code>MyObject</code>类的实例对象。</li>
</ol>
<p><strong>关键点总结</strong></p>
<ul>
<li><strong>栈中存储的是对象引用</strong>：栈中存储的不是对象本身，而是指向堆中对象实例的引用。</li>
<li><strong>堆中存储对象实例</strong>：所有类的实例对象和数组都存储在堆中。</li>
<li><strong>引用的固定大小</strong>：对象引用的大小是固定的，通常在64位系统中是8字节。</li>
</ul>
<h3 id="为什么区分引用和对象很重要？"><a href="#为什么区分引用和对象很重要？" class="headerlink" title="为什么区分引用和对象很重要？"></a>为什么区分引用和对象很重要？</h3><p>理解栈中存储的是对象引用而不是对象本身，对于以下几个方面非常重要：</p>
<ol>
<li><strong>内存管理</strong>：栈中的引用是轻量级的，而堆中的对象实例可能占用较大的内存空间。区分引用和对象有助于更好地理解内存分配和垃圾回收机制。</li>
<li><strong>性能优化</strong>：栈的操作速度通常比堆快，因为栈遵循先进后出原则，操作简单且快速。通过引用访问堆中的对象实例，可以减少内存访问的开销。</li>
<li><strong>并发和线程安全</strong>：栈中的数据是线程私有的，而堆中的数据是共享的。理解这一点有助于设计线程安全的代码，避免数据竞争和并发问题。</li>
</ol>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h2><p>Java堆（Heap）是JVM内存管理中一个重要的区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾回收器（Garbage Collector, GC）的实现，堆的划分可能会有所不同。然而，通常可以将堆分为以下几个部分：</p>
<p><img src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410051050412.png" alt="堆内存结构"></p>
<h3 id="1-新生代（Young-Generation）"><a href="#1-新生代（Young-Generation）" class="headerlink" title="1. 新生代（Young Generation）"></a>1. 新生代（Young Generation）</h3><p>新生代是堆内存中用于存放新创建对象的区域。新生代通常分为以下几个子区域：</p>
<h4 id="1-1-Eden-Space"><a href="#1-1-Eden-Space" class="headerlink" title="1.1 Eden Space"></a>1.1 Eden Space</h4><p>Eden Space是新生代中最大的一个区域，大多数新创建的对象首先存储在这里。由于Eden分区较小，当Eden分区满了的时候，会触发一次Minor GC（新生代垃圾回收）。Minor GC的主要目的是回收那些不再被引用的对象，并将存活的对象移动到Survivor Space。</p>
<h4 id="1-2-Survivor-Space"><a href="#1-2-Survivor-Space" class="headerlink" title="1.2 Survivor Space"></a>1.2 Survivor Space</h4><p>Survivor Space通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC回收完成之后，存活下来的对象会被移动到其中的一个Survivor空间。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</p>
<h3 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h3><p>老年代是堆内存中用于存放生命周期较长的对象的区域。经历一次或多次Minor GC回收后仍然存活的对象会被移动到老年代分区。老年代中的对象生命周期较长，因此Major GC（也称Full GC，涉及老年代的GC回收）发生的频率较低，但其执行时间通常会比Minor GC时间要长。老年代的空间通常要比新生代要大，以存储更多长期存活的对象。</p>
<h3 id="3-元空间（Metaspace）"><a href="#3-元空间（Metaspace）" class="headerlink" title="3. 元空间（Metaspace）"></a>3. 元空间（Metaspace）</h3><p>从Java 8开始，永久代（Permanent Generation）被元空间（Metaspace）替代，用于存储类元数据信息，比如类的结构信息、方法信息、常量池等。元空间并不在堆中，而是使用本地内存（Native Memory），这解决了永久代容易造成内存溢出的问题。元空间的大小可以根据实际需求动态扩展，不再受限于JVM的堆内存限制。</p>
<h3 id="4-大对象区（Humongous-Region）"><a href="#4-大对象区（Humongous-Region）" class="headerlink" title="4. 大对象区（Humongous Region）"></a>4. 大对象区（Humongous Region）</h3><p>在某些JVM实现（如G1垃圾收集器）中，为大对象分配了专门的区域，称为大对象区域（Humongous Region）。大对象指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免频繁的新生代晋升而产生内存碎片化。大对象区域的设计有助于优化大对象的内存分配和回收，减少内存碎片。</p>
<h1 id="JVM-堆和栈"><a href="#JVM-堆和栈" class="headerlink" title="JVM 堆和栈"></a>JVM 堆和栈</h1><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>在Java虚拟机（JVM）中，堆（Heap）和栈（Stack）是两个关键的内存区域，它们各自承担着不同的职责，并且在性能、生命周期、存储空间和可见性等方面有着显著的差异。</p>
<ol>
<li><strong>用途</strong></li>
</ol>
<p>栈主要用于存储线程在调用方法时产生的栈帧（Stack Frame）。每个栈帧包含了方法的局部变量、操作数栈、动态链接、方法返回地址等信息。栈帧的生命周期与方法调用的生命周期一致，当方法调用结束时，对应的栈帧即刻被销毁。栈的操作遵循先进后出（LIFO）的原则，因此操作简单且快速。</p>
<p>堆是JVM中所有线程共享的内存区域，用于存储对象实例和数组。堆内存的管理主要依赖于垃圾回收器（Garbage Collector, GC），当堆内存不足以分配新的对象实例时，JVM会抛出<code>OutOfMemoryError</code>异常。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。</p>
<p><strong>2. 生命周期</strong></p>
<p>栈中的数据具有明确的生命周期，当一个方法调用结束时，对应的栈帧即刻销毁。栈帧中的局部变量和操作数栈等数据也随之消失。因此，栈中的数据生命周期是短暂的，仅在方法调用期间存在。</p>
<p>堆中的数据生命周期一般是不确定的，交由GC进行管理。对象实例和数组在堆中创建后，其生命周期取决于是否存在对该对象的引用。当一个对象不再被引用时，GC会在适当的时机回收该对象占用的内存。</p>
<p><strong>3. 存取速度</strong></p>
<p>栈中的数据存储和访问速度通常要比堆快。这是因为栈遵循先进后出原则，操作简单且快速。栈帧的创建和销毁都是在固定的内存位置进行，因此访问速度较快。</p>
<p>堆的结构相对复杂，其存储和访问速率也就相对较慢。堆中的数据需要通过指针进行间接访问，且堆内存的管理涉及垃圾回收，这会消耗相应的性能。垃圾回收器需要扫描堆中的对象，判断哪些对象可以被回收，这个过程可能会导致一定的性能开销。</p>
<p><strong>4. 存储空间</strong></p>
<p>栈的空间相对较小且固定，由操作系统进行管理。每个线程在创建时都会分配一个独立的栈空间，栈的大小可以通过JVM参数进行配置。如果栈空间不足（例如递归层次过深或局部变量过大），JVM会抛出<code>StackOverflowError</code>异常。</p>
<p>堆的空间较大，由JVM进行管理，并且可以动态扩展。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。堆溢出通常是由于对象实例过多，超出了堆内存的大小，导致JVM抛出<code>OutOfMemoryError</code>异常。</p>
<p><strong>5. 可见性</strong></p>
<p>栈的数据是“线程私有”的，每个线程都有自己独立的栈空间。栈中的数据仅对当前线程可见，其他线程无法访问。这种设计确保了线程之间的数据隔离，避免了数据竞争和并发问题。</p>
<p>堆是所有线程共享的内存区域，堆中的数据对所有线程可见。对象实例和数组在堆中创建后，可以被多个线程共享和访问。这种设计使得堆成为多线程环境下数据共享的主要场所。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="方法区中方法执行过程"><a href="#方法区中方法执行过程" class="headerlink" title="方法区中方法执行过程"></a>方法区中方法执行过程</h2><p>在Java虚拟机（JVM）中，方法的执行过程涉及多个步骤，包括方法调用的解析、栈帧的创建、方法的执行以及返回处理。以下是对这些步骤的详细解析：</p>
<ol>
<li><strong>解析方法调用</strong></li>
</ol>
<p>当程序通过对象或类直接调用某个方法时，JVM首先需要解析方法调用。这个过程主要包括以下几个步骤：</p>
<ul>
<li><strong>符号引用解析</strong>：JVM会通过方法符号的引用（Symbolic Reference），找到实际方法的地址。符号引用存储在常量池中，包含了方法的名称、描述符（Descriptor）和所属类的信息。</li>
<li><strong>动态链接</strong>：在运行时，JVM会将符号引用解析为直接引用（Direct Reference），即方法在内存中的实际地址。这个过程称为动态链接（Dynamic Linking）。</li>
</ul>
<ol start="2">
<li><strong>栈帧创建</strong></li>
</ol>
<p>在调用方法之前，JVM会为该方法创建一个栈帧（Stack Frame）。栈帧是方法调用和执行的基本单位，包含了以下几个关键部分：</p>
<ul>
<li><strong>局部变量表（Local Variable Table）</strong>：用于存储方法的局部变量，包括基本数据类型和对象引用。局部变量表的大小在编译时就已经确定。</li>
<li><strong>操作数栈（Operand Stack）</strong>：用于存储方法执行过程中的中间结果和操作数。操作数栈的大小也在编译时确定。</li>
<li><strong>动态链接（Dynamic Linking）</strong>：指向运行时常量池中该方法的符号引用，用于支持方法调用过程中的动态链接。</li>
<li><strong>方法返回地址（Return Address）</strong>：存储方法调用完成后的返回地址，用于恢复调用者的执行环境。</li>
</ul>
<ol start="3">
<li><strong>执行方法</strong></li>
</ol>
<p>方法的执行过程涉及以下几个关键操作：</p>
<ul>
<li><strong>字节码指令执行</strong>：JVM会逐条执行方法内的字节码指令。这些指令可能涉及局部变量的读写、操作数栈的操作、跳转控制、对象的创建、方法调用等。</li>
<li><strong>局部变量操作</strong>：局部变量表中的数据可以通过字节码指令进行读取和写入。例如，<code>iload</code>指令用于将局部变量表中的int类型数据加载到操作数栈，<code>istore</code>指令用于将操作数栈中的int类型数据存储到局部变量表。</li>
<li><strong>操作数栈操作</strong>：操作数栈用于存储方法执行过程中的中间结果和操作数。例如，<code>iadd</code>指令用于将操作数栈顶的两个int类型数据相加，并将结果压入操作数栈。</li>
<li><strong>跳转控制</strong>：JVM支持条件和无条件跳转指令，用于实现循环、条件判断等控制结构。例如，<code>if_icmpge</code>指令用于比较操作数栈顶的两个int类型数据，如果第一个数据大于或等于第二个数据，则跳转到指定的字节码指令。</li>
<li><strong>对象创建和方法调用</strong>：JVM支持对象创建和方法调用指令。例如，<code>new</code>指令用于创建一个新的对象实例，并将其引用压入操作数栈；<code>invokevirtual</code>指令用于调用对象的实例方法。</li>
</ul>
<ol start="4">
<li><strong>返回处理</strong></li>
</ol>
<p>方法执行完毕后，JVM会进行返回处理，主要包括以下几个步骤：</p>
<ul>
<li><strong>返回值处理</strong>：如果方法有返回值，JVM会将返回值压入调用者的操作数栈。例如，<code>ireturn</code>指令用于将操作数栈顶的int类型数据作为返回值返回给调用者。</li>
<li><strong>栈帧销毁</strong>：方法执行完毕后，JVM会销毁当前方法的栈帧，恢复调用者的执行环境。栈帧的销毁包括释放局部变量表和操作数栈的内存空间。</li>
<li><strong>恢复调用者环境</strong>：JVM会根据方法返回地址，恢复调用者的执行环境，继续执行调用者方法的下一条指令。</li>
</ul>
<h2 id="方法区中的内容"><a href="#方法区中的内容" class="headerlink" title="方法区中的内容"></a>方法区中的内容</h2><p>在Java虚拟机（JVM）中，方法区（Method Area）是一个重要的内存区域，用于存储类的元数据信息。方法区在Java 8及之后的版本中被元空间（Metaspace）替代，但它们的功能和内容基本一致。以下是方法区中存储的主要内容：</p>
<ol>
<li><strong>类型信息（Type Information）</strong></li>
</ol>
<p>类型信息包括类的结构信息，如类的名称、父类、接口、修饰符（如public、final等）、字段信息、方法信息等。这些信息在类加载过程中被解析并存储在方法区中。</p>
<ol start="2">
<li><strong>常量池（Constant Pool）</strong></li>
</ol>
<p>常量池是一个包含类中所有常量（如字符串常量、整数常量、类和接口的符号引用等）的表。常量池在编译时生成，并在类加载过程中被解析和存储在方法区中。常量池中的常量可以被类中的字段、方法和代码引用。</p>
<ol start="3">
<li><strong>静态变量（Static Variables）</strong></li>
</ol>
<p>静态变量是类级别的变量，它们在类加载时被初始化，并在整个类的生命周期内保持不变。静态变量存储在方法区中，可以被类的所有实例共享。</p>
<ol start="4">
<li><strong>方法字节码（Method Bytecode）</strong></li>
</ol>
<p>方法字节码是类中方法的实现代码，以字节码的形式存储在方法区中。字节码是JVM能够理解和执行的指令集，它包含了方法的逻辑和操作。方法字节码在类加载过程中被加载到方法区，并在方法调用时被JVM解释执行。</p>
<ol start="5">
<li><strong>符号引用（Symbolic References）</strong></li>
</ol>
<p>符号引用是常量池中的一种常量类型，用于表示类、方法、字段等的引用。符号引用在编译时生成，并在类加载过程中被解析为直接引用（Direct Reference），即内存中的实际地址。符号引用在方法调用、字段访问等操作中起到关键作用。</p>
<ol start="6">
<li><strong>运行时常量池（Runtime Constant Pool）</strong></li>
</ol>
<p>运行时常量池是常量池在运行时的表示形式，包含了类加载过程中解析后的常量和符号引用。运行时常量池存储在方法区中，用于支持方法调用、字段访问等操作。</p>
<ol start="7">
<li><strong>常量池缓存（Constant Pool Cache）</strong></li>
</ol>
<p>常量池缓存是运行时常量池的一个优化机制，用于缓存频繁使用的常量和符号引用。常量池缓存可以减少常量池的访问开销，提高方法调用和字段访问的性能。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="String保存在哪里？"><a href="#String保存在哪里？" class="headerlink" title="String保存在哪里？"></a>String保存在哪里？</h2><p>String保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享。</p>
<p>点击String的源码，可以看到String类被<code>final</code>关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    ...<span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-s-new-String-abc-执行过程中涉及的内存分区"><a href="#String-s-new-String-abc-执行过程中涉及的内存分区" class="headerlink" title="String s = new String(&quot;abc&quot;) 执行过程中涉及的内存分区"></a><code>String s = new String(&quot;abc&quot;)</code> 执行过程中涉及的内存分区</h2><p>在Java中，<code>String s = new String(&quot;abc&quot;)</code> 这行代码的执行过程涉及多个内存分区，包括堆内存（Heap）、字符串常量池（String Pool）和栈内存（Stack）。以下是对这个过程的详细解析：</p>
<h3 id="1-堆内存（Heap）"><a href="#1-堆内存（Heap）" class="headerlink" title="1. 堆内存（Heap）"></a>1. 堆内存（Heap）</h3><p><code>new String(&quot;abc&quot;)</code> 中的 <code>new</code> 关键字用于创建一个新的 <code>String</code> 对象实例。这个对象实例在运行时被创建，并存储在堆内存中。堆内存是JVM中用于存储对象实例和数组的区域。</p>
<h3 id="2-字符串常量池（String-Pool）"><a href="#2-字符串常量池（String-Pool）" class="headerlink" title="2. 字符串常量池（String Pool）"></a>2. 字符串常量池（String Pool）</h3><p><code>&quot;abc&quot;</code> 是一个字符串常量，它在编译时就已经确定。JVM会在字符串常量池中查找是否已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象。字符串常量池是JVM中用于存储字符串常量的特殊区域，它有助于减少字符串对象的重复创建，从而节省内存。</p>
<ul>
<li><strong>如果字符串常量池中已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象</strong>，则直接返回该对象的引用。</li>
<li><strong>如果字符串常量池中不存在值为 <code>&quot;abc&quot;</code> 的字符串对象</strong>，则在堆内存中创建一个新的 <code>String</code> 对象，并将其引用存储到字符串常量池中。</li>
</ul>
<h3 id="3-栈内存（Stack）"><a href="#3-栈内存（Stack）" class="headerlink" title="3. 栈内存（Stack）"></a>3. 栈内存（Stack）</h3><p><code>String s</code> 是一个局部变量，它在栈内存中存储。栈内存用于存储方法的局部变量、操作数栈、方法调用等信息。在这个例子中，<code>s</code> 是一个指向堆内存中 <code>String</code> 对象的引用。</p>
<h3 id="执行过程详细步骤"><a href="#执行过程详细步骤" class="headerlink" title="执行过程详细步骤"></a>执行过程详细步骤</h3><ol>
<li><p><strong>字符串常量池查找</strong>：</p>
<ul>
<li>JVM首先在字符串常量池中查找是否已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象。</li>
<li>如果存在，则直接返回该对象的引用。</li>
<li>如果不存在，则在堆内存中创建一个新的 <code>String</code> 对象，并将其引用存储到字符串常量池中。</li>
</ul>
</li>
<li><p><strong>创建 <code>String</code> 对象</strong>：使用 <code>new</code> 关键字在堆内存中创建一个新的 <code>String</code> 对象，并将字符串常量池中的 <code>&quot;abc&quot;</code> 对象的引用传递给该对象。</p>
</li>
<li><p><strong>栈内存中的引用</strong>：在栈内存中创建一个局部变量 <code>s</code>，并将其指向堆内存中新创建的 <code>String</code> 对象。</p>
</li>
</ol>
<div class="panel panel-info">
    <div class="panel-title"><i class="fa fa-info"></i>注意</div>
    <div class="panel-body">
        <p><strong>注意：</strong>此时<code>&quot;abc&quot; == s</code>是返回的结果是<strong>false</strong>，而<code>&quot;abc&quot;.equals(s)</code>返回结果是<strong>true</strong>。</p>
<p>因为<code>==</code>比较的是二者的引用是否相同，”abc”的引用指向字符串常量池，而s的引用指向新创建的字符串实例对象；二者的值内容是相同的，故而<code>equals</code>方法返回结果是true。</p>

    </div>
    </div>



<h2 id="引用类型及其区别"><a href="#引用类型及其区别" class="headerlink" title="引用类型及其区别"></a>引用类型及其区别</h2><p>在Java中，引用类型主要有四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些引用类型在垃圾回收（Garbage Collection, GC）过程中的行为有所不同，适用于不同的应用场景。</p>
<h3 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h3><p>强引用是Java中最常见的引用类型，通常通过赋值操作创建。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：强引用指向的对象永远不会被垃圾回收器回收。只有当强引用被显式地置为 <code>null</code> 或超出作用域时，垃圾回收器才会回收该对象。</li>
<li><strong>应用场景</strong>：适用于大多数对象引用场景，确保对象在不再需要时能够被显式地释放。</li>
</ul>
<h3 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h3><p>软引用使用 <code>SoftReference</code> 类来描述，适用于那些有用但不是必要的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;A&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：软引用指向的对象在系统内存不足时会被垃圾回收器回收。垃圾回收器会在发生内存溢出之前尝试回收软引用对象，以释放内存。</li>
<li><strong>应用场景</strong>：适用于缓存场景，允许在内存紧张时自动释放缓存对象，避免内存溢出。</li>
</ul>
<h3 id="3-弱引用（Weak-Reference）"><a href="#3-弱引用（Weak-Reference）" class="headerlink" title="3. 弱引用（Weak Reference）"></a>3. 弱引用（Weak Reference）</h3><p>弱引用使用 <code>WeakReference</code> 类来描述，强度比软引用更低。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;A&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：弱引用指向的对象在下一次垃圾回收时会被回收，无论内存是否充足。垃圾回收器会在下一次GC时回收弱引用对象。</li>
<li><strong>应用场景</strong>：适用于需要临时持有对象引用，但允许对象在不再使用时被回收的场景，如缓存、监听器等。</li>
</ul>
<h3 id="4-虚引用（Phantom-Reference）"><a href="#4-虚引用（Phantom-Reference）" class="headerlink" title="4. 虚引用（Phantom Reference）"></a>4. 虚引用（Phantom Reference）</h3><p>虚引用使用 <code>PhantomReference</code> 类来描述，是最弱的引用关系。虚引用必须与 <code>ReferenceQueue</code> 一起使用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;A&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;A&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>(), refQueue);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：虚引用指向的对象在垃圾回收器准备回收对象时会被放入 <code>ReferenceQueue</code> 中，但对象本身并不会被立即回收。虚引用主要用于跟踪对象的垃圾回收状态。</li>
<li><strong>应用场景</strong>：适用于需要跟踪对象的垃圾回收状态，并在对象被回收时执行某些操作的场景，如管理堆外内存、资源清理等。</li>
</ul>
<h2 id="弱引用应用场景"><a href="#弱引用应用场景" class="headerlink" title="弱引用应用场景"></a>弱引用应用场景</h2><p>弱引用（Weak Reference）是一种引用类型，它不会阻止其引用的对象被垃圾回收器回收。在Java中，弱引用通过 <code>java.lang.ref.WeakReference</code> 类来实现。弱引用的主要用途是创建非强制性的对象引用，这些引用可以在内存压力时被清理，避免内存泄漏。</p>
<p><strong>1. 缓存系统</strong></p>
<p>弱引用可以用于缓存系统，当系统内存压力较大时，垃圾回收器会自动清理弱引用对象，从而释放内存资源。这种方式可以避免缓存对象占用过多的内存，导致内存溢出。</p>
<p><strong>2. 对象池</strong></p>
<p>弱引用可以用于对象池（Object Pool），管理暂时不使用的对象。当对象不再被强引用时，可以被垃圾回收器回收，从而避免对象池占用过多的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceObjectPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WeakReference&lt;Object&gt;&gt; pool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        pool.add(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!pool.isEmpty()) &#123;</span><br><span class="line">            WeakReference&lt;Object&gt; weakRef = pool.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> weakRef.get();</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeakReferenceObjectPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReferenceObjectPool</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        pool.release(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> pool.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;Acquired Object: &quot;</span> + obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>WeakReferenceObjectPool</code> 类使用弱引用实现了一个简单的对象池。当对象不再被强引用时，可以被垃圾回收器回收，从而避免对象池占用过多的内存。</p>
<p><strong>3. 避免缓存泄露</strong></p>
<p>弱引用可以用于避免缓存泄露（Cache Leak）。在某些情况下，缓存对象可能会长时间占用内存，导致内存泄漏。使用弱引用可以确保缓存对象在不再使用时能够被垃圾回收器回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceCacheLeakAvoidance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;Object&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; weakRef = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (weakRef != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> weakRef.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeakReferenceCacheLeakAvoidance</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReferenceCacheLeakAvoidance</span>();</span><br><span class="line">        cache.put(<span class="string">&quot;key1&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Object: &quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>WeakReferenceCacheLeakAvoidance</code> 类使用弱引用实现了一个避免缓存泄露的缓存系统。当缓存对象不再被强引用时，可以被垃圾回收器回收，从而避免内存泄漏。</p>
<h2 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="headerlink" title="内存泄漏与内存溢出"></a>内存泄漏与内存溢出</h2><p>在Java应用程序中，内存泄漏（Memory Leak）和内存溢出（Out of Memory, OOM）是两个常见的内存管理问题。理解这两个概念及其产生的原因，对于优化Java应用程序的性能和稳定性至关重要。</p>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><p>内存泄漏是指程序在运行过程中已不再需要某个对象，却因为持有该对象的强引用而导致其无法被垃圾回收（Garbage Collection, GC），从而导致可用内存逐渐减小。随着时间的推移，内存泄漏会导致应用程序的性能下降，甚至崩溃。</p>
<p>内存泄漏的常见原因</p>
<ol>
<li><p><strong>静态集合</strong>：</p>
<p>使用静态数据结构（如 <code>HashMap</code>、<code>ArrayList</code>）存储对象，且未及时清理。静态集合的生命周期与应用程序的生命周期相同，如果集合中存储了大量不再使用的对象，会导致这些对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCollectionLeak</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件监听</strong>：</p>
<p>未取消对事件源的监听，导致对对象的持续引用。事件监听器通常会持有对监听对象的引用，如果未及时取消监听，会导致对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListenerLeak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventSource</span>();</span><br><span class="line">        source.addListener(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">                <span class="comment">// Handle event</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Forgot to remove listener</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程</strong>：</p>
<p>未关闭的线程可能持有对对象的引用，导致无法回收。线程的生命周期通常较长，如果线程中持有对对象的引用，会导致这些对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLeak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                <span class="comment">// Do something with obj</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="内存溢出（Out-of-Memory-OOM）"><a href="#内存溢出（Out-of-Memory-OOM）" class="headerlink" title="内存溢出（Out of Memory, OOM）"></a>内存溢出（Out of Memory, OOM）</h3><p>内存溢出是指JVM在申请内存时，无法找到足够的内存而抛出 <code>OutOfMemoryError</code>。通常是由于堆内存不足，无法存放新创建的对象。内存溢出会导致应用程序立即崩溃，影响系统的稳定性和可用性。</p>
<h4 id="内存溢出的常见原因"><a href="#内存溢出的常见原因" class="headerlink" title="内存溢出的常见原因"></a>内存溢出的常见原因</h4><ol>
<li><p><strong>大量对象创建</strong>：</p>
<p>程序中创建了大量对象，且这些对象的生命周期较长，导致堆内存不足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectCreationOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 1MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>持久引用</strong>：</p>
<p>对象被持久引用（如静态变量、缓存等），导致这些对象无法被回收，最终导致堆内存不足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentReferenceOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; cache = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            cache.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 1MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>递归调用</strong>：</p>
<p>递归调用可能导致栈内存溢出（StackOverflowError），尤其是在递归深度较大的情况下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveCallOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="JVM-内存溢出情况"><a href="#JVM-内存溢出情况" class="headerlink" title="JVM 内存溢出情况"></a>JVM 内存溢出情况</h2><p>在Java虚拟机（JVM）中，内存溢出（Out of Memory, OOM）是指JVM在申请内存时，无法找到足够的内存而抛出 <code>OutOfMemoryError</code>。内存溢出会导致应用程序立即崩溃，影响系统的稳定性和可用性。以下是JVM中常见的内存溢出情况及其原因：</p>
<ol>
<li><strong>堆内存溢出（Heap OutOfMemoryError）</strong></li>
</ol>
<p>堆内存溢出是指JVM在堆内存中无法分配足够的空间来存储新创建的对象，导致抛出 <code>OutOfMemoryError</code>。</p>
<ul>
<li><strong>大量对象创建</strong>：程序中创建了大量对象，且这些对象的生命周期较长，导致堆内存不足。</li>
<li><strong>持久引用</strong>：对象被持久引用（如静态变量、缓存等），导致这些对象无法被回收，最终导致堆内存不足。</li>
<li><strong>内存泄漏</strong>：程序中存在内存泄漏，导致不再使用的对象无法被回收，最终导致堆内存不足。</li>
</ul>
<ol start="2">
<li><strong>栈溢出（StackOverflowError）</strong></li>
</ol>
<p>栈溢出是指线程的栈空间不足，导致抛出 <code>StackOverflowError</code>。栈溢出通常发生在递归调用深度过大或方法调用层次过深的情况下。</p>
<ul>
<li><strong>递归调用</strong>：递归调用深度过大，导致栈空间不足。</li>
<li><strong>方法调用层次过深</strong>：方法调用层次过深，导致栈空间不足。</li>
<li><strong>局部变量过多</strong>：方法中局部变量过多，导致栈空间不足。</li>
</ul>
<ol start="3">
<li><strong>元空间溢出（Metaspace OutOfMemoryError）</strong></li>
</ol>
<p>元空间溢出是指JVM在元空间（Metaspace）中无法分配足够的空间来存储类的元数据信息，导致抛出 <code>OutOfMemoryError</code>。元空间在Java 8及之后的版本中替代了永久代（PermGen）。</p>
<ul>
<li><strong>类加载过多</strong>：程序中加载了大量类，导致元空间不足。</li>
<li><strong>动态生成类</strong>：使用动态代理、字节码生成等技术动态生成大量类，导致元空间不足。</li>
<li><strong>元空间配置不足</strong>：元空间的大小配置不足，无法满足程序的需求。</li>
</ul>
<ol start="4">
<li><strong>直接内存溢出（Direct Memory OutOfMemoryError）</strong></li>
</ol>
<p>直接内存溢出是指JVM在直接内存（Direct Memory）中无法分配足够的空间，导致抛出 <code>OutOfMemoryError</code>。直接内存是JVM通过Native函数库直接分配的内存，不受JVM堆内存的限制。</p>
<ul>
<li><strong>NIO操作</strong>：使用NIO（New I&#x2F;O）类库进行大量直接内存分配，导致直接内存不足。</li>
<li><strong>直接内存配置不足</strong>：直接内存的大小配置不足，无法满足程序的需求。</li>
<li><strong>内存泄漏</strong>：程序中存在直接内存泄漏，导致直接内存不足。</li>
</ul>
</div>
        </div>
        
        <footer class="kratos-entry-footer clearfix">
            
            
            
                <div class="post-actions text-center clearfix" id="post-actions">
                
                    <a class="donate" href="javascript:;" onclick="krOpenDonateModal()"><i class="fa fa-bitcoin"></i> 打赏</a>
                
                
                    <a class="share" href="javascript:;" onclick="krOpenShareModal()"><i class="fa fa-share-alt"></i> 分享</a>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">内存模型</a>
                </div>
                <div class="pull-date">
                    <time datetime="2024-10-05T09:39:02.596Z" itemprop="dateModified">最后编辑：2024-10-05</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Spring Cloud" href="/2024/09/30/Spring-SpringCloud/"><i class="fa fa-angle-left"></i> 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" JVM-类初始化与类加载" href="/2024/10/05/Java-JVM类初始化与类加载/">下一篇 <i class="fa fa-angle-right"></i></a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

            
                

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/user.jpg" alt="xiaoyan" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">是一只时时翻垃圾吃的宅子。</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                42
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                14
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                62
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">了解JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">元空间（Metaspace）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stacks%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stacks%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈（Native Method Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">堆内存（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">直接内存（Direct Memory）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9AJVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">1.7.</span> <span class="toc-text">扩展：JVM参数配置与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">栈中存放的是指针还是对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">栈中存储的是对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%86%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">为什么区分引用和对象很重要？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">堆的划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 新生代（Young Generation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Eden-Space"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1.1 Eden Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Survivor-Space"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">1.2 Survivor Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 老年代（Old Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 元空间（Metaspace）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%8C%BA%EF%BC%88Humongous-Region%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 大对象区（Humongous Region）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">JVM 堆和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">堆和栈的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">方法区中方法执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.</span> <span class="toc-text">方法区中的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">String保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String-abc-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">6.2.</span> <span class="toc-text">String s &#x3D; new String(&quot;abc&quot;) 执行过程中涉及的内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 堆内存（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88String-Pool%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 字符串常量池（String Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">3. 栈内存（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.2.4.</span> <span class="toc-text">执行过程详细步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">引用类型及其区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. 强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. 软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. 弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">4. 虚引用（Phantom Reference）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.</span> <span class="toc-text">弱引用应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.5.</span> <span class="toc-text">内存泄漏与内存溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">内存泄漏（Memory Leak）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88Out-of-Memory-OOM%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">内存溢出（Out of Memory, OOM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">内存溢出的常见原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="toc-number">6.6.</span> <span class="toc-text">JVM 内存溢出情况</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类列表</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/JVM/">JVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/%E5%9F%BA%E7%A1%80/">基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/%E9%9B%86%E5%90%88/">集合</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><span class="category-list-count">5</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/AOP/" style="font-size: 0.6em;">AOP</a> <a href="/tags/BASE/" style="font-size: 0.6em;">BASE</a> <a href="/tags/Bean/" style="font-size: 0.6em;">Bean</a> <a href="/tags/CAP/" style="font-size: 0.6em;">CAP</a> <a href="/tags/Cookie/" style="font-size: 0.6em;">Cookie</a> <a href="/tags/DDD/" style="font-size: 0.6em;">DDD</a> <a href="/tags/DNS/" style="font-size: 0.6em;">DNS</a> <a href="/tags/HTTP/" style="font-size: 0.6em;">HTTP</a> <a href="/tags/I-O/" style="font-size: 0.6em;">I/O</a> <a href="/tags/IoC/" style="font-size: 0.6em;">IoC</a> <a href="/tags/JWT/" style="font-size: 0.6em;">JWT</a> <a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.6em;">Java8新特性</a> <a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.6em;">Java基本概念</a> <a href="/tags/List/" style="font-size: 0.6em;">List</a> <a href="/tags/Map/" style="font-size: 0.8em;">Map</a> <a href="/tags/MyBatis/" style="font-size: 0.6em;">MyBatis</a> <a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.6em;">MySQL基础</a> <a href="/tags/Nginx/" style="font-size: 0.6em;">Nginx</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><i class="fa fa-book"></i> 操作系统-进程管理</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><i class="fa fa-book"></i> 分布式-分布式事务</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/"><i class="fa fa-book"></i> 分布式-服务治理（下）</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/"><i class="fa fa-book"></i> 分布式-服务治理（上）</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"><i class="fa fa-book"></i> 分布式-基础理论&算法</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
            

        

                </div>
    </div>
</div>

<footer>
    <div id="footer">
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 XIAOYAN 版权所有.</li>
                            <li>本站已运行<span id="kr-since">Loading...</span></li>
                        </div>
                        <div>
                            <li>自豪地使用 <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a> 主题</li>
                            <li>站点由 xiaoyan 用 <i class="fa fa-heart" style="color:#d43f57"></i> 搭建</li>
                        </div>
                        <!-- 额外的追加注入项 -->
                        
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                <div class="box theme-box" id="theme-toggle">
                    <span class="fa fa-adjust"></span>
                </div>
            </div>
            <div id="gotop-box" class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>


    <div id="kr-donate-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseDonateModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-bitcoin"></i>
            </div>
            <div class="kr-modal-title">打赏</div>
            <button class="kr-modal-close" onclick="krCloseDonateModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-donate-message">请我喝一杯冰阔咯~</div>
            <div class="kr-donate-qr" id="kr-donate-qr">
                
            </div>
            <div class="kr-donate-platforms">
                
                    
                        <button class="kr-donate-platform-button" style="color: #1677ff;" title="支付宝" onclick="krDonateModalShowPlatformQR('https://qr.alipay.com/fkx15009k7u0fqrj8auepdf', '#1677ff')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-alipay">
  <path stroke="none" d="M0 0h24v24H0z" fill="none" />
  <path d="M19 3h-14a2 2 0 0 0 -2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2 -2v-14a2 2 0 0 0 -2 -2z" />
  <path d="M7 7h10" />
  <path d="M12 3v7" />
  <path d="M21 17.314c-2.971 -1.923 -15 -8.779 -15 -1.864c0 1.716 1.52 2.55 2.985 2.55c3.512 0 6.814 -5.425 6.814 -8h-6.604" />
</svg>

                        </button>
                    
                
                    
                        <button class="kr-donate-platform-button" style="color: #38ad5a;" title="微信支付" onclick="krDonateModalShowPlatformQR('wxp://f2f0hR4eF9Ypa3tpzjWme9fQDyWW3PIGe3WG5oiIakWLmDs', '#38ad5a')">
                            <i class="fa fa-wechat"></i>
                        </button>
                    
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/donate.min.js"></script>




    <div id="kr-share-modal" class="kr-modal">
    <div class="kr-modal-bg" onclick="krCloseShareModal()"></div>
    <div class="kr-modal-content">
        <div class="kr-modal-header">
            <div class="kr-modal-icon">
                <i class="fa fa-share-alt"></i>
            </div>
            <div class="kr-modal-title">分享</div>
            <button class="kr-modal-close" onclick="krCloseShareModal()">
                <i class="fa fa-times-circle"></i>
            </button>
        </div>
        <div class="kr-modal-body">
            <div class="kr-share-message">让兄弟萌也来瞅一瞅！</div>
            <div class="kr-share-qr" id="kr-share-qr"></div>
            <div class="kr-share-platforms">
                
                    <button class="kr-share-platform-button" style="color: #e6162d;" title="QQ" onclick="krShareModalOpenPlatform('')">
                        <i class="fa fa-qq"></i>
                    </button>
                
                    <button class="kr-share-platform-button" style="color: #25d366;" title="微信" onclick="krShareModalOpenPlatform('')">
                        <i class="fa fa-weixin"></i>
                    </button>
                
            </div>
        </div>
    </div>
</div>
<script defer src="/js/kr-modal/share.min.js"></script>



<!-- 额外的追加注入项 -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<meting-js
  server="netease"
  type="playlist"
  fixed="true"
  order="random"
  id="12613265870">
</meting-js>



        <script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


  <script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>



  <script defer src="/vendors/viewerjs@1.11.6/dist/viewer.min.js"></script>


<script defer src="/js/kr-core.min.js"></script>


  <script defer src="/js/kr-pjax.min.js"></script>


<!-- 额外的追加注入项 -->

  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>



    </body>
</html>