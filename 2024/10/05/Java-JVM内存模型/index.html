<!DOCTYPE html><html lang="zn-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM-内存模型 | XIAOYAN</title><meta name="keywords" content="内存模型"><meta name="author" content="xiaoyan"><meta name="copyright" content="xiaoyan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM-内存模型"><meta name="application-name" content="JVM-内存模型"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JVM-内存模型"><meta property="og:url" content="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.html"><meta property="og:site_name" content="XIAOYAN"><meta property="og:description" content="了解JVM内存模型根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Regist"><meta property="og:locale" content="zn-CN"><meta property="og:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png"><meta property="article:author" content="xiaoyan"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png"><meta name="description" content="了解JVM内存模型根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Regist"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: xiaoyan","link":"链接: ","source":"来源: XIAOYAN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'XIAOYAN',
  title: 'JVM-内存模型',
  postAI: '',
  pageFillDescription: '了解JVM内存模型, 元空间（Metaspace）, Java虚拟机栈（Java Virtual Machine Stacks）, 本地方法栈（Native Method Stacks）, 程序计数器（Program Counter Register）, 堆内存（Heap）, 直接内存（Direct Memory）, 扩展：JVM参数配置与分区, 注意事项：, 虚拟机栈, 栈中存放的是指针还是对象？, 栈中存储的是对象引用, 为什么区分引用和对象很重要？, 堆, 堆的划分, 1. 新生代（Young Generation）, 1.1 Eden Space, 1.2 Survivor Space, 2. 老年代（Old Generation）, 3. 元空间（Metaspace）, 4. 大对象区（Humongous Region）, JVM 堆和栈, 堆和栈的区别, 方法区, 方法区中方法执行过程, 方法区中的内容, 引用, String保存在哪里？, String s = new String(abc) 执行过程中涉及的内存分区, 1. 堆内存（Heap）, 2. 字符串常量池（String Pool）, 3. 栈内存（Stack）, 执行过程详细步骤, 引用类型及其区别, 1. 强引用（Strong Reference）, 2. 软引用（Soft Reference）, 3. 弱引用（Weak Reference）, 4. 虚引用（Phantom Reference）, 弱引用应用场景, 内存泄漏与内存溢出, 内存泄漏（Memory Leak）, 内存溢出（Out of Memory OOM）, 内存溢出的常见原因, JVM 内存溢出情况了解内存模型根据虚拟机规范第版运行时内存结构主要由以下几个部分组成虚拟机栈堆元空间程序计数器以及本地方法栈此外还可以直接访问操作系统提供的本地内存这部分内存被称为直接内存元空间元空间是规范中方法区的实现其本质与及之前版本中的永久代类似然而元空间与永久代最大的区别在于元空间并不位于管理的内存区域而是直接使用操作系统的本地内存这种设计使得元空间的大小不再受限于的堆内存限制而是可以根据实际需求动态扩展虚拟机栈每个线程在创建时都会分配一个独立的虚拟机栈栈中存储的是栈帧每个方法调用都会生成一个栈帧栈帧中包含了局部变量表操作数栈动态链接方法返回地址等信息局部变量表主要存储基本数据类型如等和对象引用虚拟机栈的大小可以是固定的也可以是动态扩展的本地方法栈本地方法栈与虚拟机栈的功能类似主要区别在于虚拟机栈用于执行方法而本地方法栈用于执行方法即使用等本地语言编写的方法本地方法栈的实现方式与虚拟机栈类似也可以是固定大小或动态扩展的程序计数器程序计数器是一个线程私有的内存区域用于记录当前线程执行的字节码指令的地址在多线程环境下处理器在任意时刻只会执行一个线程的指令为了确保线程切换后能够恢复到正确的执行位置每个线程都需要维护一个独立的程序计数器程序计数器的大小通常为一个字长即位或位具体取决于的实现堆内存堆内存是中所有线程共享的内存区域用于存储对象实例和数组堆内存的大小在启动时就已经确定并且可以通过参数进行调整堆内存的管理主要依赖于垃圾回收器当堆内存不足以分配新的对象实例时会抛出异常在及之后的版本中字符串常量池从永久代中移出并被放置在堆内存中这种设计优化了字符串常量的内存管理避免了永久代内存溢出的问题直接内存直接内存并不属于运行时数据区的一部分也不是规范中定义的内存区域然而在中引入的类库中提供了一种基于通道和缓冲区的新的方式允许通过函数库直接分配堆外内存并通过一个存储在堆内存中的对象来引用和操作这块内存这种设计在某些高性能场景下可以显著提升性能因为它避免了堆和堆之间频繁的数据复制操作扩展参数配置与分区在的虚拟机中配置参数可以影响的内存分配和性能的内存分区主要包括以下几个部分堆内存用于存储对象实例非堆内存包括方法区运行时常量池编译代码等栈内存每个线程都有自己的栈用于存储局部变量方法调用等本地方法栈用于执行本地方法非代码寄存器每个线程都有自己的寄存器用于存储当前执行指令的地址以下是一些常见的参数及其与内存分区的关系参数描述影响的内存分区设置启动时的初始堆内存大小堆内存设置允许的最大堆内存大小堆内存设置年轻代的大小堆内存设置年轻代与老年代的比例堆内存设置区与区的比例堆内存设置方法区的最大大小在及更高版本中方法区被称为非堆内存设置方法区的初始大小非堆内存设置每个线程的栈大小栈内存设置直接内存的最大大小非堆内存设置启动时的初始堆内存大小等同于堆内存设置允许的最大堆内存大小等同于堆内存设置永久代的初始大小在之前有效非堆内存设置永久代的最大大小在之前有效非堆内存注意事项堆内存主要用于存储对象实例是内存中最大的一部分通过和可以控制堆内存的初始大小和最大大小非堆内存包括方法区运行时常量池等主要用于存储类的元数据常量静态变量等在及更高版本中方法区被称为通过和进行配置栈内存每个线程都有自己的栈用于存储局部变量方法调用等通过可以设置每个线程的栈大小直接内存通过可以设置直接内存的最大大小直接内存通常用于操作通过合理配置这些参数可以优化的内存使用避免内存溢出等问题提升应用程序的性能虚拟机栈栈中存放的是指针还是对象在虚拟机内存模型中栈用于存储线程的局部变量和方法调用的上下文而堆则是用于存储所有类的实例对象和数组栈中存储的是对象引用当我们在栈中讨论存储时指的是存储基本类型的数据和对象的引用而不是对象本身具体来说基本类型数据如等这些数据直接存储在栈中对象引用当我们在方法中声明一个对象时比如这里的实际上是存储在栈中的引用而不是对象本身这个引用是一个固定大小的数据例如在位系统中是字节它指向堆中分配给对象的内存空间考虑以下代码片段基本类型数据直接存储在栈中对象引用存储在栈中对象实例存储在堆中在这个例子中是一个基本类型变量其值直接存储在栈中是一个对象引用它存储在栈中指向堆中类的实例对象关键点总结栈中存储的是对象引用栈中存储的不是对象本身而是指向堆中对象实例的引用堆中存储对象实例所有类的实例对象和数组都存储在堆中引用的固定大小对象引用的大小是固定的通常在位系统中是字节为什么区分引用和对象很重要理解栈中存储的是对象引用而不是对象本身对于以下几个方面非常重要内存管理栈中的引用是轻量级的而堆中的对象实例可能占用较大的内存空间区分引用和对象有助于更好地理解内存分配和垃圾回收机制性能优化栈的操作速度通常比堆快因为栈遵循先进后出原则操作简单且快速通过引用访问堆中的对象实例可以减少内存访问的开销并发和线程安全栈中的数据是线程私有的而堆中的数据是共享的理解这一点有助于设计线程安全的代码避免数据竞争和并发问题堆堆的划分堆是内存管理中一个重要的区域主要用于存放对象实例和数组随着的发展和不同垃圾回收器的实现堆的划分可能会有所不同然而通常可以将堆分为以下几个部分新生代新生代是堆内存中用于存放新创建对象的区域新生代通常分为以下几个子区域是新生代中最大的一个区域大多数新创建的对象首先存储在这里由于分区较小当分区满了的时候会触发一次新生代垃圾回收的主要目的是回收那些不再被引用的对象并将存活的对象移动到通常分为两个相等大小的区域称为和在每次回收完成之后存活下来的对象会被移动到其中的一个空间这两个区域轮流充当对象的中转站帮助区分短暂存活的对象和长期存活的对象老年代老年代是堆内存中用于存放生命周期较长的对象的区域经历一次或多次回收后仍然存活的对象会被移动到老年代分区老年代中的对象生命周期较长因此也称涉及老年代的回收发生的频率较低但其执行时间通常会比时间要长老年代的空间通常要比新生代要大以存储更多长期存活的对象元空间从开始永久代被元空间替代用于存储类元数据信息比如类的结构信息方法信息常量池等元空间并不在堆中而是使用本地内存这解决了永久代容易造成内存溢出的问题元空间的大小可以根据实际需求动态扩展不再受限于的堆内存限制大对象区在某些实现如垃圾收集器中为大对象分配了专门的区域称为大对象区域大对象指需要大量连续内存空间的对象如大数组这类对象直接分配在老年代以避免频繁的新生代晋升而产生内存碎片化大对象区域的设计有助于优化大对象的内存分配和回收减少内存碎片堆和栈堆和栈的区别在虚拟机中堆和栈是两个关键的内存区域它们各自承担着不同的职责并且在性能生命周期存储空间和可见性等方面有着显著的差异用途栈主要用于存储线程在调用方法时产生的栈帧每个栈帧包含了方法的局部变量操作数栈动态链接方法返回地址等信息栈帧的生命周期与方法调用的生命周期一致当方法调用结束时对应的栈帧即刻被销毁栈的操作遵循先进后出的原则因此操作简单且快速堆是中所有线程共享的内存区域用于存储对象实例和数组堆内存的管理主要依赖于垃圾回收器当堆内存不足以分配新的对象实例时会抛出异常堆内存的大小在启动时就已经确定并且可以通过参数进行调整生命周期栈中的数据具有明确的生命周期当一个方法调用结束时对应的栈帧即刻销毁栈帧中的局部变量和操作数栈等数据也随之消失因此栈中的数据生命周期是短暂的仅在方法调用期间存在堆中的数据生命周期一般是不确定的交由进行管理对象实例和数组在堆中创建后其生命周期取决于是否存在对该对象的引用当一个对象不再被引用时会在适当的时机回收该对象占用的内存存取速度栈中的数据存储和访问速度通常要比堆快这是因为栈遵循先进后出原则操作简单且快速栈帧的创建和销毁都是在固定的内存位置进行因此访问速度较快堆的结构相对复杂其存储和访问速率也就相对较慢堆中的数据需要通过指针进行间接访问且堆内存的管理涉及垃圾回收这会消耗相应的性能垃圾回收器需要扫描堆中的对象判断哪些对象可以被回收这个过程可能会导致一定的性能开销存储空间栈的空间相对较小且固定由操作系统进行管理每个线程在创建时都会分配一个独立的栈空间栈的大小可以通过参数进行配置如果栈空间不足例如递归层次过深或局部变量过大会抛出异常堆的空间较大由进行管理并且可以动态扩展堆内存的大小在启动时就已经确定并且可以通过参数进行调整堆溢出通常是由于对象实例过多超出了堆内存的大小导致抛出异常可见性栈的数据是线程私有的每个线程都有自己独立的栈空间栈中的数据仅对当前线程可见其他线程无法访问这种设计确保了线程之间的数据隔离避免了数据竞争和并发问题堆是所有线程共享的内存区域堆中的数据对所有线程可见对象实例和数组在堆中创建后可以被多个线程共享和访问这种设计使得堆成为多线程环境下数据共享的主要场所方法区方法区中方法执行过程在虚拟机中方法的执行过程涉及多个步骤包括方法调用的解析栈帧的创建方法的执行以及返回处理以下是对这些步骤的详细解析解析方法调用当程序通过对象或类直接调用某个方法时首先需要解析方法调用这个过程主要包括以下几个步骤符号引用解析会通过方法符号的引用找到实际方法的地址符号引用存储在常量池中包含了方法的名称描述符和所属类的信息动态链接在运行时会将符号引用解析为直接引用即方法在内存中的实际地址这个过程称为动态链接栈帧创建在调用方法之前会为该方法创建一个栈帧栈帧是方法调用和执行的基本单位包含了以下几个关键部分局部变量表用于存储方法的局部变量包括基本数据类型和对象引用局部变量表的大小在编译时就已经确定操作数栈用于存储方法执行过程中的中间结果和操作数操作数栈的大小也在编译时确定动态链接指向运行时常量池中该方法的符号引用用于支持方法调用过程中的动态链接方法返回地址存储方法调用完成后的返回地址用于恢复调用者的执行环境执行方法方法的执行过程涉及以下几个关键操作字节码指令执行会逐条执行方法内的字节码指令这些指令可能涉及局部变量的读写操作数栈的操作跳转控制对象的创建方法调用等局部变量操作局部变量表中的数据可以通过字节码指令进行读取和写入例如指令用于将局部变量表中的类型数据加载到操作数栈指令用于将操作数栈中的类型数据存储到局部变量表操作数栈操作操作数栈用于存储方法执行过程中的中间结果和操作数例如指令用于将操作数栈顶的两个类型数据相加并将结果压入操作数栈跳转控制支持条件和无条件跳转指令用于实现循环条件判断等控制结构例如指令用于比较操作数栈顶的两个类型数据如果第一个数据大于或等于第二个数据则跳转到指定的字节码指令对象创建和方法调用支持对象创建和方法调用指令例如指令用于创建一个新的对象实例并将其引用压入操作数栈指令用于调用对象的实例方法返回处理方法执行完毕后会进行返回处理主要包括以下几个步骤返回值处理如果方法有返回值会将返回值压入调用者的操作数栈例如指令用于将操作数栈顶的类型数据作为返回值返回给调用者栈帧销毁方法执行完毕后会销毁当前方法的栈帧恢复调用者的执行环境栈帧的销毁包括释放局部变量表和操作数栈的内存空间恢复调用者环境会根据方法返回地址恢复调用者的执行环境继续执行调用者方法的下一条指令方法区中的内容在虚拟机中方法区是一个重要的内存区域用于存储类的元数据信息方法区在及之后的版本中被元空间替代但它们的功能和内容基本一致以下是方法区中存储的主要内容类型信息类型信息包括类的结构信息如类的名称父类接口修饰符如等字段信息方法信息等这些信息在类加载过程中被解析并存储在方法区中常量池常量池是一个包含类中所有常量如字符串常量整数常量类和接口的符号引用等的表常量池在编译时生成并在类加载过程中被解析和存储在方法区中常量池中的常量可以被类中的字段方法和代码引用静态变量静态变量是类级别的变量它们在类加载时被初始化并在整个类的生命周期内保持不变静态变量存储在方法区中可以被类的所有实例共享方法字节码方法字节码是类中方法的实现代码以字节码的形式存储在方法区中字节码是能够理解和执行的指令集它包含了方法的逻辑和操作方法字节码在类加载过程中被加载到方法区并在方法调用时被解释执行符号引用符号引用是常量池中的一种常量类型用于表示类方法字段等的引用符号引用在编译时生成并在类加载过程中被解析为直接引用即内存中的实际地址符号引用在方法调用字段访问等操作中起到关键作用运行时常量池运行时常量池是常量池在运行时的表示形式包含了类加载过程中解析后的常量和符号引用运行时常量池存储在方法区中用于支持方法调用字段访问等操作常量池缓存常量池缓存是运行时常量池的一个优化机制用于缓存频繁使用的常量和符号引用常量池缓存可以减少常量池的访问开销提高方法调用和字段访问的性能引用保存在哪里保存在字符串常量池中不同于其他对象它的值是不可变的且可以被多个引用共享点击的源码可以看到类被关键字修饰其他代码执行过程中涉及的内存分区在中这行代码的执行过程涉及多个内存分区包括堆内存字符串常量池和栈内存以下是对这个过程的详细解析堆内存中的关键字用于创建一个新的对象实例这个对象实例在运行时被创建并存储在堆内存中堆内存是中用于存储对象实例和数组的区域字符串常量池是一个字符串常量它在编译时就已经确定会在字符串常量池中查找是否已经存在值为的字符串对象字符串常量池是中用于存储字符串常量的特殊区域它有助于减少字符串对象的重复创建从而节省内存如果字符串常量池中已经存在值为的字符串对象则直接返回该对象的引用如果字符串常量池中不存在值为的字符串对象则在堆内存中创建一个新的对象并将其引用存储到字符串常量池中栈内存是一个局部变量它在栈内存中存储栈内存用于存储方法的局部变量操作数栈方法调用等信息在这个例子中是一个指向堆内存中对象的引用执行过程详细步骤字符串常量池查找首先在字符串常量池中查找是否已经存在值为的字符串对象如果存在则直接返回该对象的引用如果不存在则在堆内存中创建一个新的对象并将其引用存储到字符串常量池中创建对象使用关键字在堆内存中创建一个新的对象并将字符串常量池中的对象的引用传递给该对象栈内存中的引用在栈内存中创建一个局部变量并将其指向堆内存中新创建的对象引用类型及其区别在中引用类型主要有四种强引用软引用弱引用和虚引用这些引用类型在垃圾回收过程中的行为有所不同适用于不同的应用场景强引用强引用是中最常见的引用类型通常通过赋值操作创建例如特点强引用指向的对象永远不会被垃圾回收器回收只有当强引用被显式地置为或超出作用域时垃圾回收器才会回收该对象应用场景适用于大多数对象引用场景确保对象在不再需要时能够被显式地释放软引用软引用使用类来描述适用于那些有用但不是必要的对象例如特点软引用指向的对象在系统内存不足时会被垃圾回收器回收垃圾回收器会在发生内存溢出之前尝试回收软引用对象以释放内存应用场景适用于缓存场景允许在内存紧张时自动释放缓存对象避免内存溢出弱引用弱引用使用类来描述强度比软引用更低例如特点弱引用指向的对象在下一次垃圾回收时会被回收无论内存是否充足垃圾回收器会在下一次时回收弱引用对象应用场景适用于需要临时持有对象引用但允许对象在不再使用时被回收的场景如缓存监听器等虚引用虚引用使用类来描述是最弱的引用关系虚引用必须与一起使用例如特点虚引用指向的对象在垃圾回收器准备回收对象时会被放入中但对象本身并不会被立即回收虚引用主要用于跟踪对象的垃圾回收状态应用场景适用于需要跟踪对象的垃圾回收状态并在对象被回收时执行某些操作的场景如管理堆外内存资源清理等弱引用应用场景弱引用是一种引用类型它不会阻止其引用的对象被垃圾回收器回收在中弱引用通过类来实现弱引用的主要用途是创建非强制性的对象引用这些引用可以在内存压力时被清理避免内存泄漏缓存系统弱引用可以用于缓存系统当系统内存压力较大时垃圾回收器会自动清理弱引用对象从而释放内存资源这种方式可以避免缓存对象占用过多的内存导致内存溢出对象池弱引用可以用于对象池管理暂时不使用的对象当对象不再被强引用时可以被垃圾回收器回收从而避免对象池占用过多的内存在这个示例中类使用弱引用实现了一个简单的对象池当对象不再被强引用时可以被垃圾回收器回收从而避免对象池占用过多的内存避免缓存泄露弱引用可以用于避免缓存泄露在某些情况下缓存对象可能会长时间占用内存导致内存泄漏使用弱引用可以确保缓存对象在不再使用时能够被垃圾回收器回收在这个示例中类使用弱引用实现了一个避免缓存泄露的缓存系统当缓存对象不再被强引用时可以被垃圾回收器回收从而避免内存泄漏内存泄漏与内存溢出在应用程序中内存泄漏和内存溢出是两个常见的内存管理问题理解这两个概念及其产生的原因对于优化应用程序的性能和稳定性至关重要内存泄漏内存泄漏是指程序在运行过程中已不再需要某个对象却因为持有该对象的强引用而导致其无法被垃圾回收从而导致可用内存逐渐减小随着时间的推移内存泄漏会导致应用程序的性能下降甚至崩溃内存泄漏的常见原因静态集合使用静态数据结构如存储对象且未及时清理静态集合的生命周期与应用程序的生命周期相同如果集合中存储了大量不再使用的对象会导致这些对象无法被回收事件监听未取消对事件源的监听导致对对象的持续引用事件监听器通常会持有对监听对象的引用如果未及时取消监听会导致对象无法被回收线程未关闭的线程可能持有对对象的引用导致无法回收线程的生命周期通常较长如果线程中持有对对象的引用会导致这些对象无法被回收内存溢出内存溢出是指在申请内存时无法找到足够的内存而抛出通常是由于堆内存不足无法存放新创建的对象内存溢出会导致应用程序立即崩溃影响系统的稳定性和可用性内存溢出的常见原因大量对象创建程序中创建了大量对象且这些对象的生命周期较长导致堆内存不足持久引用对象被持久引用如静态变量缓存等导致这些对象无法被回收最终导致堆内存不足递归调用递归调用可能导致栈内存溢出尤其是在递归深度较大的情况下内存溢出情况在虚拟机中内存溢出是指在申请内存时无法找到足够的内存而抛出内存溢出会导致应用程序立即崩溃影响系统的稳定性和可用性以下是中常见的内存溢出情况及其原因堆内存溢出堆内存溢出是指在堆内存中无法分配足够的空间来存储新创建的对象导致抛出大量对象创建程序中创建了大量对象且这些对象的生命周期较长导致堆内存不足持久引用对象被持久引用如静态变量缓存等导致这些对象无法被回收最终导致堆内存不足内存泄漏程序中存在内存泄漏导致不再使用的对象无法被回收最终导致堆内存不足栈溢出栈溢出是指线程的栈空间不足导致抛出栈溢出通常发生在递归调用深度过大或方法调用层次过深的情况下递归调用递归调用深度过大导致栈空间不足方法调用层次过深方法调用层次过深导致栈空间不足局部变量过多方法中局部变量过多导致栈空间不足元空间溢出元空间溢出是指在元空间中无法分配足够的空间来存储类的元数据信息导致抛出元空间在及之后的版本中替代了永久代类加载过多程序中加载了大量类导致元空间不足动态生成类使用动态代理字节码生成等技术动态生成大量类导致元空间不足元空间配置不足元空间的大小配置不足无法满足程序的需求直接内存溢出直接内存溢出是指在直接内存中无法分配足够的空间导致抛出直接内存是通过函数库直接分配的内存不受堆内存的限制操作使用类库进行大量直接内存分配导致直接内存不足直接内存配置不足直接内存的大小配置不足无法满足程序的需求内存泄漏程序中存在直接内存泄漏导致直接内存不足',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-04 11:40:02',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/images/star.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">XIAOYAN</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 1.05rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 1.05rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 1.05rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 1.05rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 1.05rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 1.05rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 1.05rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 1.05rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 1.05rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 1.05rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 1.05rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 1.05rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 1.05rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 1.05rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 1.05rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 1.05rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 1.05rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.05rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 1.05rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">November 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">September 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">July 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/JVM/" itemprop="url">JVM</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>内存模型</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM-内存模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-10-05T00:28:49.000Z" title="发表于 2024-10-05 08:28:49">2024-10-05</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.417Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为桂林"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>桂林</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><header><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url">编程语言</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" itemprop="url">Java</a><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/JVM/" itemprop="url">JVM</a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url">内存模型</a><h1 id="CrawlerTitle" itemprop="name headline">JVM-内存模型</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">xiaoyan</span><time itemprop="dateCreated datePublished" datetime="2024-10-05T00:28:49.000Z" title="发表于 2024-10-05 08:28:49">2024-10-05</time><time itemprop="dateCreated datePublished" datetime="2024-11-04T03:40:02.417Z" title="更新于 2024-11-04 11:40:02">2024-11-04</time></header><h1 id="了解JVM内存模型"><a href="#了解JVM内存模型" class="headerlink" title="了解JVM内存模型"></a>了解JVM内存模型</h1><p>根据Java虚拟机规范（JVM Specification）第8版，JVM运行时内存结构主要由以下几个部分组成：虚拟机栈（Java Virtual Machine Stacks）、堆（Heap）、元空间（Metaspace）、程序计数器（Program Counter Register）以及本地方法栈（Native Method Stacks）。此外，JVM还可以直接访问操作系统提供的本地内存，这部分内存被称为直接内存（Direct Memory）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png" alt="JVM运行时内存结构"></p>
<h2 id="元空间（Metaspace）"><a href="#元空间（Metaspace）" class="headerlink" title="元空间（Metaspace）"></a>元空间（Metaspace）</h2><p>元空间是JVM规范中方法区（Method Area）的实现，其本质与Java 7及之前版本中的永久代（Permanent Generation）类似。然而，元空间与永久代最大的区别在于，元空间并不位于JVM管理的内存区域，而是直接使用操作系统的本地内存。这种设计使得元空间的大小不再受限于JVM的堆内存限制，而是可以根据实际需求动态扩展。</p>
<h2 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h2><p>每个Java线程在创建时都会分配一个独立的虚拟机栈。栈中存储的是栈帧（Stack Frame），每个方法调用都会生成一个栈帧。栈帧中包含了局部变量表（Local Variable Table）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、方法返回地址（Return Address）等信息。局部变量表主要存储基本数据类型（如int、float等）和对象引用（Reference）。虚拟机栈的大小可以是固定的，也可以是动态扩展的。</p>
<h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈与虚拟机栈的功能类似，主要区别在于虚拟机栈用于执行Java方法，而本地方法栈用于执行Native方法（即使用C&#x2F;C++等本地语言编写的方法）。本地方法栈的实现方式与虚拟机栈类似，也可以是固定大小或动态扩展的。</p>
<h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器是一个线程私有的内存区域，用于记录当前线程执行的字节码指令的地址。在多线程环境下，处理器在任意时刻只会执行一个线程的指令。为了确保线程切换后能够恢复到正确的执行位置，每个线程都需要维护一个独立的程序计数器。程序计数器的大小通常为一个字长（Word），即32位或64位，具体取决于JVM的实现。</p>
<h2 id="堆内存（Heap）"><a href="#堆内存（Heap）" class="headerlink" title="堆内存（Heap）"></a>堆内存（Heap）</h2><p>堆内存是JVM中所有线程共享的内存区域，用于存储对象实例和数组。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。堆内存的管理主要依赖于垃圾回收器（Garbage Collector, GC），当堆内存不足以分配新的对象实例时，JVM会抛出<code>OutOfMemoryError</code>异常。</p>
<p>在JDK 1.8及之后的版本中，字符串常量池（String Constant Pool）从永久代中移出，并被放置在堆内存中。这种设计优化了字符串常量的内存管理，避免了永久代内存溢出的问题。</p>
<h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>直接内存并不属于JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域。然而，在JDK 1.4中引入的NIO（New I&#x2F;O）类库中，提供了一种基于通道（Channel）和缓冲区（Buffer）的新的I&#x2F;O方式。NIO允许通过Native函数库直接分配堆外内存，并通过一个存储在堆内存中的<code>DirectByteBuffer</code>对象来引用和操作这块内存。这种设计在某些高性能场景下可以显著提升性能，因为它避免了Java堆和Native堆之间频繁的数据复制操作。</p>
<h2 id="扩展：JVM参数配置与分区"><a href="#扩展：JVM参数配置与分区" class="headerlink" title="扩展：JVM参数配置与分区"></a>扩展：JVM参数配置与分区</h2><p>在Java的JVM（Java虚拟机）中，配置JVM参数可以影响JVM的内存分配和性能。JVM的内存分区主要包括以下几个部分：</p>
<ol>
<li><strong>堆内存（Heap Memory）</strong>：用于存储对象实例。</li>
<li><strong>非堆内存（Non-Heap Memory）</strong>：包括方法区（Method Area）、运行时常量池（Runtime Constant Pool）、JIT编译代码等。</li>
<li><strong>栈内存（Stack Memory）</strong>：每个线程都有自己的栈，用于存储局部变量、方法调用等。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：用于执行本地方法（非Java代码）。</li>
<li><strong>PC寄存器（Program Counter Register）</strong>：每个线程都有自己的PC寄存器，用于存储当前执行指令的地址。</li>
</ol>
<p>以下是一些常见的JVM参数及其与内存分区的关系：</p>
<table>
<thead>
<tr>
<th>JVM参数</th>
<th>描述</th>
<th>影响的内存分区</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms&lt;size&gt;</code></td>
<td>设置JVM启动时的初始堆内存大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-Xmx&lt;size&gt;</code></td>
<td>设置JVM允许的最大堆内存大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-Xmn&lt;size&gt;</code></td>
<td>设置年轻代（Young Generation）的大小。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:NewRatio=&lt;ratio&gt;</code></td>
<td>设置年轻代与老年代的比例。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio=&lt;ratio&gt;</code></td>
<td>设置Eden区与Survivor区的比例。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code></td>
<td>设置方法区的最大大小（在Java 8及更高版本中，方法区被称为Metaspace）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize=&lt;size&gt;</code></td>
<td>设置方法区的初始大小。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-Xss&lt;size&gt;</code></td>
<td>设置每个线程的栈大小。</td>
<td>栈内存（Stack Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxDirectMemorySize=&lt;size&gt;</code></td>
<td>设置直接内存（Direct Memory）的最大大小。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:InitialHeapSize=&lt;size&gt;</code></td>
<td>设置JVM启动时的初始堆内存大小（等同于<code>-Xms</code>）。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxHeapSize=&lt;size&gt;</code></td>
<td>设置JVM允许的最大堆内存大小（等同于<code>-Xmx</code>）。</td>
<td>堆内存（Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:PermSize=&lt;size&gt;</code></td>
<td>设置永久代（PermGen）的初始大小（在Java 8之前有效）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
<tr>
<td><code>-XX:MaxPermSize=&lt;size&gt;</code></td>
<td>设置永久代的最大大小（在Java 8之前有效）。</td>
<td>非堆内存（Non-Heap Memory）</td>
</tr>
</tbody></table>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><strong>堆内存</strong>：主要用于存储对象实例，是JVM内存中最大的一部分。通过<code>-Xms</code>和<code>-Xmx</code>可以控制堆内存的初始大小和最大大小。</li>
<li><strong>非堆内存</strong>：包括方法区、运行时常量池等，主要用于存储类的元数据、常量、静态变量等。在Java 8及更高版本中，方法区被称为Metaspace，通过<code>-XX:MaxMetaspaceSize</code>和<code>-XX:MetaspaceSize</code>进行配置。</li>
<li><strong>栈内存</strong>：每个线程都有自己的栈，用于存储局部变量、方法调用等。通过<code>-Xss</code>可以设置每个线程的栈大小。</li>
<li><strong>直接内存</strong>：通过<code>-XX:MaxDirectMemorySize</code>可以设置直接内存的最大大小，直接内存通常用于NIO操作。</li>
</ul>
<p>通过合理配置这些JVM参数，可以优化JVM的内存使用，避免内存溢出等问题，提升应用程序的性能。</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="栈中存放的是指针还是对象？"><a href="#栈中存放的是指针还是对象？" class="headerlink" title="栈中存放的是指针还是对象？"></a>栈中存放的是指针还是对象？</h2><p>在Java虚拟机（JVM）内存模型中，栈（Stack）用于存储线程的局部变量和方法调用的上下文，而堆（Heap）则是用于存储所有类的实例对象和数组。</p>
<h3 id="栈中存储的是对象引用"><a href="#栈中存储的是对象引用" class="headerlink" title="栈中存储的是对象引用"></a>栈中存储的是对象引用</h3><p>当我们在栈中讨论“存储”时，指的是存储基本类型的数据和对象的引用，而不是对象本身。具体来说：</p>
<ul>
<li><strong>基本类型数据</strong>：如<code>int</code>、<code>float</code>、<code>boolean</code>等，这些数据直接存储在栈中。</li>
<li><strong>对象引用</strong>：当我们在方法中声明一个对象时，比如<code>MyObject o = new MyObject();</code>，这里的<code>o</code>实际上是存储在栈中的引用（Reference），而不是对象本身。这个引用是一个固定大小的数据（例如在64位系统中是8字节），它指向堆中分配给对象的内存空间。</li>
</ul>
<p>考虑以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">primitive</span> <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// 基本类型数据，直接存储在栈中</span></span><br><span class="line">    <span class="type">MyObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(); <span class="comment">// 对象引用存储在栈中，对象实例存储在堆中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ol>
<li><code>primitive</code>是一个基本类型变量，其值<code>42</code>直接存储在栈中。</li>
<li><code>obj</code>是一个对象引用，它存储在栈中，指向堆中<code>MyObject</code>类的实例对象。</li>
</ol>
<p><strong>关键点总结</strong></p>
<ul>
<li><strong>栈中存储的是对象引用</strong>：栈中存储的不是对象本身，而是指向堆中对象实例的引用。</li>
<li><strong>堆中存储对象实例</strong>：所有类的实例对象和数组都存储在堆中。</li>
<li><strong>引用的固定大小</strong>：对象引用的大小是固定的，通常在64位系统中是8字节。</li>
</ul>
<h3 id="为什么区分引用和对象很重要？"><a href="#为什么区分引用和对象很重要？" class="headerlink" title="为什么区分引用和对象很重要？"></a>为什么区分引用和对象很重要？</h3><p>理解栈中存储的是对象引用而不是对象本身，对于以下几个方面非常重要：</p>
<ol>
<li><strong>内存管理</strong>：栈中的引用是轻量级的，而堆中的对象实例可能占用较大的内存空间。区分引用和对象有助于更好地理解内存分配和垃圾回收机制。</li>
<li><strong>性能优化</strong>：栈的操作速度通常比堆快，因为栈遵循先进后出原则，操作简单且快速。通过引用访问堆中的对象实例，可以减少内存访问的开销。</li>
<li><strong>并发和线程安全</strong>：栈中的数据是线程私有的，而堆中的数据是共享的。理解这一点有助于设计线程安全的代码，避免数据竞争和并发问题。</li>
</ol>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h2><p>Java堆（Heap）是JVM内存管理中一个重要的区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾回收器（Garbage Collector, GC）的实现，堆的划分可能会有所不同。然而，通常可以将堆分为以下几个部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410051050412.png" alt="堆内存结构"></p>
<h3 id="1-新生代（Young-Generation）"><a href="#1-新生代（Young-Generation）" class="headerlink" title="1. 新生代（Young Generation）"></a>1. 新生代（Young Generation）</h3><p>新生代是堆内存中用于存放新创建对象的区域。新生代通常分为以下几个子区域：</p>
<h4 id="1-1-Eden-Space"><a href="#1-1-Eden-Space" class="headerlink" title="1.1 Eden Space"></a>1.1 Eden Space</h4><p>Eden Space是新生代中最大的一个区域，大多数新创建的对象首先存储在这里。由于Eden分区较小，当Eden分区满了的时候，会触发一次Minor GC（新生代垃圾回收）。Minor GC的主要目的是回收那些不再被引用的对象，并将存活的对象移动到Survivor Space。</p>
<h4 id="1-2-Survivor-Space"><a href="#1-2-Survivor-Space" class="headerlink" title="1.2 Survivor Space"></a>1.2 Survivor Space</h4><p>Survivor Space通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC回收完成之后，存活下来的对象会被移动到其中的一个Survivor空间。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</p>
<h3 id="2-老年代（Old-Generation）"><a href="#2-老年代（Old-Generation）" class="headerlink" title="2. 老年代（Old Generation）"></a>2. 老年代（Old Generation）</h3><p>老年代是堆内存中用于存放生命周期较长的对象的区域。经历一次或多次Minor GC回收后仍然存活的对象会被移动到老年代分区。老年代中的对象生命周期较长，因此Major GC（也称Full GC，涉及老年代的GC回收）发生的频率较低，但其执行时间通常会比Minor GC时间要长。老年代的空间通常要比新生代要大，以存储更多长期存活的对象。</p>
<h3 id="3-元空间（Metaspace）"><a href="#3-元空间（Metaspace）" class="headerlink" title="3. 元空间（Metaspace）"></a>3. 元空间（Metaspace）</h3><p>从Java 8开始，永久代（Permanent Generation）被元空间（Metaspace）替代，用于存储类元数据信息，比如类的结构信息、方法信息、常量池等。元空间并不在堆中，而是使用本地内存（Native Memory），这解决了永久代容易造成内存溢出的问题。元空间的大小可以根据实际需求动态扩展，不再受限于JVM的堆内存限制。</p>
<h3 id="4-大对象区（Humongous-Region）"><a href="#4-大对象区（Humongous-Region）" class="headerlink" title="4. 大对象区（Humongous Region）"></a>4. 大对象区（Humongous Region）</h3><p>在某些JVM实现（如G1垃圾收集器）中，为大对象分配了专门的区域，称为大对象区域（Humongous Region）。大对象指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免频繁的新生代晋升而产生内存碎片化。大对象区域的设计有助于优化大对象的内存分配和回收，减少内存碎片。</p>
<h1 id="JVM-堆和栈"><a href="#JVM-堆和栈" class="headerlink" title="JVM 堆和栈"></a>JVM 堆和栈</h1><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>在Java虚拟机（JVM）中，堆（Heap）和栈（Stack）是两个关键的内存区域，它们各自承担着不同的职责，并且在性能、生命周期、存储空间和可见性等方面有着显著的差异。</p>
<ol>
<li><strong>用途</strong></li>
</ol>
<p>栈主要用于存储线程在调用方法时产生的栈帧（Stack Frame）。每个栈帧包含了方法的局部变量、操作数栈、动态链接、方法返回地址等信息。栈帧的生命周期与方法调用的生命周期一致，当方法调用结束时，对应的栈帧即刻被销毁。栈的操作遵循先进后出（LIFO）的原则，因此操作简单且快速。</p>
<p>堆是JVM中所有线程共享的内存区域，用于存储对象实例和数组。堆内存的管理主要依赖于垃圾回收器（Garbage Collector, GC），当堆内存不足以分配新的对象实例时，JVM会抛出<code>OutOfMemoryError</code>异常。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。</p>
<p><strong>2. 生命周期</strong></p>
<p>栈中的数据具有明确的生命周期，当一个方法调用结束时，对应的栈帧即刻销毁。栈帧中的局部变量和操作数栈等数据也随之消失。因此，栈中的数据生命周期是短暂的，仅在方法调用期间存在。</p>
<p>堆中的数据生命周期一般是不确定的，交由GC进行管理。对象实例和数组在堆中创建后，其生命周期取决于是否存在对该对象的引用。当一个对象不再被引用时，GC会在适当的时机回收该对象占用的内存。</p>
<p><strong>3. 存取速度</strong></p>
<p>栈中的数据存储和访问速度通常要比堆快。这是因为栈遵循先进后出原则，操作简单且快速。栈帧的创建和销毁都是在固定的内存位置进行，因此访问速度较快。</p>
<p>堆的结构相对复杂，其存储和访问速率也就相对较慢。堆中的数据需要通过指针进行间接访问，且堆内存的管理涉及垃圾回收，这会消耗相应的性能。垃圾回收器需要扫描堆中的对象，判断哪些对象可以被回收，这个过程可能会导致一定的性能开销。</p>
<p><strong>4. 存储空间</strong></p>
<p>栈的空间相对较小且固定，由操作系统进行管理。每个线程在创建时都会分配一个独立的栈空间，栈的大小可以通过JVM参数进行配置。如果栈空间不足（例如递归层次过深或局部变量过大），JVM会抛出<code>StackOverflowError</code>异常。</p>
<p>堆的空间较大，由JVM进行管理，并且可以动态扩展。堆内存的大小在JVM启动时就已经确定，并且可以通过JVM参数进行调整。堆溢出通常是由于对象实例过多，超出了堆内存的大小，导致JVM抛出<code>OutOfMemoryError</code>异常。</p>
<p><strong>5. 可见性</strong></p>
<p>栈的数据是“线程私有”的，每个线程都有自己独立的栈空间。栈中的数据仅对当前线程可见，其他线程无法访问。这种设计确保了线程之间的数据隔离，避免了数据竞争和并发问题。</p>
<p>堆是所有线程共享的内存区域，堆中的数据对所有线程可见。对象实例和数组在堆中创建后，可以被多个线程共享和访问。这种设计使得堆成为多线程环境下数据共享的主要场所。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="方法区中方法执行过程"><a href="#方法区中方法执行过程" class="headerlink" title="方法区中方法执行过程"></a>方法区中方法执行过程</h2><p>在Java虚拟机（JVM）中，方法的执行过程涉及多个步骤，包括方法调用的解析、栈帧的创建、方法的执行以及返回处理。以下是对这些步骤的详细解析：</p>
<ol>
<li><strong>解析方法调用</strong></li>
</ol>
<p>当程序通过对象或类直接调用某个方法时，JVM首先需要解析方法调用。这个过程主要包括以下几个步骤：</p>
<ul>
<li><strong>符号引用解析</strong>：JVM会通过方法符号的引用（Symbolic Reference），找到实际方法的地址。符号引用存储在常量池中，包含了方法的名称、描述符（Descriptor）和所属类的信息。</li>
<li><strong>动态链接</strong>：在运行时，JVM会将符号引用解析为直接引用（Direct Reference），即方法在内存中的实际地址。这个过程称为动态链接（Dynamic Linking）。</li>
</ul>
<ol start="2">
<li><strong>栈帧创建</strong></li>
</ol>
<p>在调用方法之前，JVM会为该方法创建一个栈帧（Stack Frame）。栈帧是方法调用和执行的基本单位，包含了以下几个关键部分：</p>
<ul>
<li><strong>局部变量表（Local Variable Table）</strong>：用于存储方法的局部变量，包括基本数据类型和对象引用。局部变量表的大小在编译时就已经确定。</li>
<li><strong>操作数栈（Operand Stack）</strong>：用于存储方法执行过程中的中间结果和操作数。操作数栈的大小也在编译时确定。</li>
<li><strong>动态链接（Dynamic Linking）</strong>：指向运行时常量池中该方法的符号引用，用于支持方法调用过程中的动态链接。</li>
<li><strong>方法返回地址（Return Address）</strong>：存储方法调用完成后的返回地址，用于恢复调用者的执行环境。</li>
</ul>
<ol start="3">
<li><strong>执行方法</strong></li>
</ol>
<p>方法的执行过程涉及以下几个关键操作：</p>
<ul>
<li><strong>字节码指令执行</strong>：JVM会逐条执行方法内的字节码指令。这些指令可能涉及局部变量的读写、操作数栈的操作、跳转控制、对象的创建、方法调用等。</li>
<li><strong>局部变量操作</strong>：局部变量表中的数据可以通过字节码指令进行读取和写入。例如，<code>iload</code>指令用于将局部变量表中的int类型数据加载到操作数栈，<code>istore</code>指令用于将操作数栈中的int类型数据存储到局部变量表。</li>
<li><strong>操作数栈操作</strong>：操作数栈用于存储方法执行过程中的中间结果和操作数。例如，<code>iadd</code>指令用于将操作数栈顶的两个int类型数据相加，并将结果压入操作数栈。</li>
<li><strong>跳转控制</strong>：JVM支持条件和无条件跳转指令，用于实现循环、条件判断等控制结构。例如，<code>if_icmpge</code>指令用于比较操作数栈顶的两个int类型数据，如果第一个数据大于或等于第二个数据，则跳转到指定的字节码指令。</li>
<li><strong>对象创建和方法调用</strong>：JVM支持对象创建和方法调用指令。例如，<code>new</code>指令用于创建一个新的对象实例，并将其引用压入操作数栈；<code>invokevirtual</code>指令用于调用对象的实例方法。</li>
</ul>
<ol start="4">
<li><strong>返回处理</strong></li>
</ol>
<p>方法执行完毕后，JVM会进行返回处理，主要包括以下几个步骤：</p>
<ul>
<li><strong>返回值处理</strong>：如果方法有返回值，JVM会将返回值压入调用者的操作数栈。例如，<code>ireturn</code>指令用于将操作数栈顶的int类型数据作为返回值返回给调用者。</li>
<li><strong>栈帧销毁</strong>：方法执行完毕后，JVM会销毁当前方法的栈帧，恢复调用者的执行环境。栈帧的销毁包括释放局部变量表和操作数栈的内存空间。</li>
<li><strong>恢复调用者环境</strong>：JVM会根据方法返回地址，恢复调用者的执行环境，继续执行调用者方法的下一条指令。</li>
</ul>
<h2 id="方法区中的内容"><a href="#方法区中的内容" class="headerlink" title="方法区中的内容"></a>方法区中的内容</h2><p>在Java虚拟机（JVM）中，方法区（Method Area）是一个重要的内存区域，用于存储类的元数据信息。方法区在Java 8及之后的版本中被元空间（Metaspace）替代，但它们的功能和内容基本一致。以下是方法区中存储的主要内容：</p>
<ol>
<li><strong>类型信息（Type Information）</strong></li>
</ol>
<p>类型信息包括类的结构信息，如类的名称、父类、接口、修饰符（如public、final等）、字段信息、方法信息等。这些信息在类加载过程中被解析并存储在方法区中。</p>
<ol start="2">
<li><strong>常量池（Constant Pool）</strong></li>
</ol>
<p>常量池是一个包含类中所有常量（如字符串常量、整数常量、类和接口的符号引用等）的表。常量池在编译时生成，并在类加载过程中被解析和存储在方法区中。常量池中的常量可以被类中的字段、方法和代码引用。</p>
<ol start="3">
<li><strong>静态变量（Static Variables）</strong></li>
</ol>
<p>静态变量是类级别的变量，它们在类加载时被初始化，并在整个类的生命周期内保持不变。静态变量存储在方法区中，可以被类的所有实例共享。</p>
<ol start="4">
<li><strong>方法字节码（Method Bytecode）</strong></li>
</ol>
<p>方法字节码是类中方法的实现代码，以字节码的形式存储在方法区中。字节码是JVM能够理解和执行的指令集，它包含了方法的逻辑和操作。方法字节码在类加载过程中被加载到方法区，并在方法调用时被JVM解释执行。</p>
<ol start="5">
<li><strong>符号引用（Symbolic References）</strong></li>
</ol>
<p>符号引用是常量池中的一种常量类型，用于表示类、方法、字段等的引用。符号引用在编译时生成，并在类加载过程中被解析为直接引用（Direct Reference），即内存中的实际地址。符号引用在方法调用、字段访问等操作中起到关键作用。</p>
<ol start="6">
<li><strong>运行时常量池（Runtime Constant Pool）</strong></li>
</ol>
<p>运行时常量池是常量池在运行时的表示形式，包含了类加载过程中解析后的常量和符号引用。运行时常量池存储在方法区中，用于支持方法调用、字段访问等操作。</p>
<ol start="7">
<li><strong>常量池缓存（Constant Pool Cache）</strong></li>
</ol>
<p>常量池缓存是运行时常量池的一个优化机制，用于缓存频繁使用的常量和符号引用。常量池缓存可以减少常量池的访问开销，提高方法调用和字段访问的性能。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="String保存在哪里？"><a href="#String保存在哪里？" class="headerlink" title="String保存在哪里？"></a>String保存在哪里？</h2><p>String保存在字符串常量池中，不同于其他对象，它的值是不可变的，且可以被多个引用共享。</p>
<p>点击String的源码，可以看到String类被<code>final</code>关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    ...<span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-s-new-String-abc-执行过程中涉及的内存分区"><a href="#String-s-new-String-abc-执行过程中涉及的内存分区" class="headerlink" title="String s = new String(&quot;abc&quot;) 执行过程中涉及的内存分区"></a><code>String s = new String(&quot;abc&quot;)</code> 执行过程中涉及的内存分区</h2><p>在Java中，<code>String s = new String(&quot;abc&quot;)</code> 这行代码的执行过程涉及多个内存分区，包括堆内存（Heap）、字符串常量池（String Pool）和栈内存（Stack）。以下是对这个过程的详细解析：</p>
<h3 id="1-堆内存（Heap）"><a href="#1-堆内存（Heap）" class="headerlink" title="1. 堆内存（Heap）"></a>1. 堆内存（Heap）</h3><p><code>new String(&quot;abc&quot;)</code> 中的 <code>new</code> 关键字用于创建一个新的 <code>String</code> 对象实例。这个对象实例在运行时被创建，并存储在堆内存中。堆内存是JVM中用于存储对象实例和数组的区域。</p>
<h3 id="2-字符串常量池（String-Pool）"><a href="#2-字符串常量池（String-Pool）" class="headerlink" title="2. 字符串常量池（String Pool）"></a>2. 字符串常量池（String Pool）</h3><p><code>&quot;abc&quot;</code> 是一个字符串常量，它在编译时就已经确定。JVM会在字符串常量池中查找是否已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象。字符串常量池是JVM中用于存储字符串常量的特殊区域，它有助于减少字符串对象的重复创建，从而节省内存。</p>
<ul>
<li><strong>如果字符串常量池中已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象</strong>，则直接返回该对象的引用。</li>
<li><strong>如果字符串常量池中不存在值为 <code>&quot;abc&quot;</code> 的字符串对象</strong>，则在堆内存中创建一个新的 <code>String</code> 对象，并将其引用存储到字符串常量池中。</li>
</ul>
<h3 id="3-栈内存（Stack）"><a href="#3-栈内存（Stack）" class="headerlink" title="3. 栈内存（Stack）"></a>3. 栈内存（Stack）</h3><p><code>String s</code> 是一个局部变量，它在栈内存中存储。栈内存用于存储方法的局部变量、操作数栈、方法调用等信息。在这个例子中，<code>s</code> 是一个指向堆内存中 <code>String</code> 对象的引用。</p>
<h3 id="执行过程详细步骤"><a href="#执行过程详细步骤" class="headerlink" title="执行过程详细步骤"></a>执行过程详细步骤</h3><ol>
<li><p><strong>字符串常量池查找</strong>：</p>
<ul>
<li>JVM首先在字符串常量池中查找是否已经存在值为 <code>&quot;abc&quot;</code> 的字符串对象。</li>
<li>如果存在，则直接返回该对象的引用。</li>
<li>如果不存在，则在堆内存中创建一个新的 <code>String</code> 对象，并将其引用存储到字符串常量池中。</li>
</ul>
</li>
<li><p><strong>创建 <code>String</code> 对象</strong>：使用 <code>new</code> 关键字在堆内存中创建一个新的 <code>String</code> 对象，并将字符串常量池中的 <code>&quot;abc&quot;</code> 对象的引用传递给该对象。</p>
</li>
<li><p><strong>栈内存中的引用</strong>：在栈内存中创建一个局部变量 <code>s</code>，并将其指向堆内存中新创建的 <code>String</code> 对象。</p>
</li>
</ol>
<h2 id="引用类型及其区别"><a href="#引用类型及其区别" class="headerlink" title="引用类型及其区别"></a>引用类型及其区别</h2><p>在Java中，引用类型主要有四种：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些引用类型在垃圾回收（Garbage Collection, GC）过程中的行为有所不同，适用于不同的应用场景。</p>
<h3 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h3><p>强引用是Java中最常见的引用类型，通常通过赋值操作创建。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：强引用指向的对象永远不会被垃圾回收器回收。只有当强引用被显式地置为 <code>null</code> 或超出作用域时，垃圾回收器才会回收该对象。</li>
<li><strong>应用场景</strong>：适用于大多数对象引用场景，确保对象在不再需要时能够被显式地释放。</li>
</ul>
<h3 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h3><p>软引用使用 <code>SoftReference</code> 类来描述，适用于那些有用但不是必要的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;A&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：软引用指向的对象在系统内存不足时会被垃圾回收器回收。垃圾回收器会在发生内存溢出之前尝试回收软引用对象，以释放内存。</li>
<li><strong>应用场景</strong>：适用于缓存场景，允许在内存紧张时自动释放缓存对象，避免内存溢出。</li>
</ul>
<h3 id="3-弱引用（Weak-Reference）"><a href="#3-弱引用（Weak-Reference）" class="headerlink" title="3. 弱引用（Weak Reference）"></a>3. 弱引用（Weak Reference）</h3><p>弱引用使用 <code>WeakReference</code> 类来描述，强度比软引用更低。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;A&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：弱引用指向的对象在下一次垃圾回收时会被回收，无论内存是否充足。垃圾回收器会在下一次GC时回收弱引用对象。</li>
<li><strong>应用场景</strong>：适用于需要临时持有对象引用，但允许对象在不再使用时被回收的场景，如缓存、监听器等。</li>
</ul>
<h3 id="4-虚引用（Phantom-Reference）"><a href="#4-虚引用（Phantom-Reference）" class="headerlink" title="4. 虚引用（Phantom Reference）"></a>4. 虚引用（Phantom Reference）</h3><p>虚引用使用 <code>PhantomReference</code> 类来描述，是最弱的引用关系。虚引用必须与 <code>ReferenceQueue</code> 一起使用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;A&gt; refQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;A&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>(), refQueue);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：虚引用指向的对象在垃圾回收器准备回收对象时会被放入 <code>ReferenceQueue</code> 中，但对象本身并不会被立即回收。虚引用主要用于跟踪对象的垃圾回收状态。</li>
<li><strong>应用场景</strong>：适用于需要跟踪对象的垃圾回收状态，并在对象被回收时执行某些操作的场景，如管理堆外内存、资源清理等。</li>
</ul>
<h2 id="弱引用应用场景"><a href="#弱引用应用场景" class="headerlink" title="弱引用应用场景"></a>弱引用应用场景</h2><p>弱引用（Weak Reference）是一种引用类型，它不会阻止其引用的对象被垃圾回收器回收。在Java中，弱引用通过 <code>java.lang.ref.WeakReference</code> 类来实现。弱引用的主要用途是创建非强制性的对象引用，这些引用可以在内存压力时被清理，避免内存泄漏。</p>
<p><strong>1. 缓存系统</strong></p>
<p>弱引用可以用于缓存系统，当系统内存压力较大时，垃圾回收器会自动清理弱引用对象，从而释放内存资源。这种方式可以避免缓存对象占用过多的内存，导致内存溢出。</p>
<p><strong>2. 对象池</strong></p>
<p>弱引用可以用于对象池（Object Pool），管理暂时不使用的对象。当对象不再被强引用时，可以被垃圾回收器回收，从而避免对象池占用过多的内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceObjectPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WeakReference&lt;Object&gt;&gt; pool = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        pool.add(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!pool.isEmpty()) &#123;</span><br><span class="line">            WeakReference&lt;Object&gt; weakRef = pool.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> weakRef.get();</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeakReferenceObjectPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReferenceObjectPool</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        pool.release(obj1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> pool.acquire();</span><br><span class="line">        System.out.println(<span class="string">&quot;Acquired Object: &quot;</span> + obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>WeakReferenceObjectPool</code> 类使用弱引用实现了一个简单的对象池。当对象不再被强引用时，可以被垃圾回收器回收，从而避免对象池占用过多的内存。</p>
<p><strong>3. 避免缓存泄露</strong></p>
<p>弱引用可以用于避免缓存泄露（Cache Leak）。在某些情况下，缓存对象可能会长时间占用内存，导致内存泄漏。使用弱引用可以确保缓存对象在不再使用时能够被垃圾回收器回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceCacheLeakAvoidance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, WeakReference&lt;Object&gt;&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        cache.put(key, <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; weakRef = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (weakRef != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> weakRef.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeakReferenceCacheLeakAvoidance</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReferenceCacheLeakAvoidance</span>();</span><br><span class="line">        cache.put(<span class="string">&quot;key1&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Object: &quot;</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>WeakReferenceCacheLeakAvoidance</code> 类使用弱引用实现了一个避免缓存泄露的缓存系统。当缓存对象不再被强引用时，可以被垃圾回收器回收，从而避免内存泄漏。</p>
<h2 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="headerlink" title="内存泄漏与内存溢出"></a>内存泄漏与内存溢出</h2><p>在Java应用程序中，内存泄漏（Memory Leak）和内存溢出（Out of Memory, OOM）是两个常见的内存管理问题。理解这两个概念及其产生的原因，对于优化Java应用程序的性能和稳定性至关重要。</p>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><p>内存泄漏是指程序在运行过程中已不再需要某个对象，却因为持有该对象的强引用而导致其无法被垃圾回收（Garbage Collection, GC），从而导致可用内存逐渐减小。随着时间的推移，内存泄漏会导致应用程序的性能下降，甚至崩溃。</p>
<p>内存泄漏的常见原因</p>
<ol>
<li><p><strong>静态集合</strong>：</p>
<p>使用静态数据结构（如 <code>HashMap</code>、<code>ArrayList</code>）存储对象，且未及时清理。静态集合的生命周期与应用程序的生命周期相同，如果集合中存储了大量不再使用的对象，会导致这些对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCollectionLeak</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件监听</strong>：</p>
<p>未取消对事件源的监听，导致对对象的持续引用。事件监听器通常会持有对监听对象的引用，如果未及时取消监听，会导致对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventListenerLeak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventSource</span>();</span><br><span class="line">        source.addListener(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">                <span class="comment">// Handle event</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Forgot to remove listener</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>线程</strong>：</p>
<p>未关闭的线程可能持有对对象的引用，导致无法回收。线程的生命周期通常较长，如果线程中持有对对象的引用，会导致这些对象无法被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLeak</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">                <span class="comment">// Do something with obj</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="内存溢出（Out-of-Memory-OOM）"><a href="#内存溢出（Out-of-Memory-OOM）" class="headerlink" title="内存溢出（Out of Memory, OOM）"></a>内存溢出（Out of Memory, OOM）</h3><p>内存溢出是指JVM在申请内存时，无法找到足够的内存而抛出 <code>OutOfMemoryError</code>。通常是由于堆内存不足，无法存放新创建的对象。内存溢出会导致应用程序立即崩溃，影响系统的稳定性和可用性。</p>
<h4 id="内存溢出的常见原因"><a href="#内存溢出的常见原因" class="headerlink" title="内存溢出的常见原因"></a>内存溢出的常见原因</h4><ol>
<li><p><strong>大量对象创建</strong>：</p>
<p>程序中创建了大量对象，且这些对象的生命周期较长，导致堆内存不足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectCreationOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 1MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>持久引用</strong>：</p>
<p>对象被持久引用（如静态变量、缓存等），导致这些对象无法被回收，最终导致堆内存不足。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentReferenceOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; cache = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            cache.add(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]); <span class="comment">// 1MB</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>递归调用</strong>：</p>
<p>递归调用可能导致栈内存溢出（StackOverflowError），尤其是在递归深度较大的情况下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveCallOOM</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        recursiveMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="JVM-内存溢出情况"><a href="#JVM-内存溢出情况" class="headerlink" title="JVM 内存溢出情况"></a>JVM 内存溢出情况</h2><p>在Java虚拟机（JVM）中，内存溢出（Out of Memory, OOM）是指JVM在申请内存时，无法找到足够的内存而抛出 <code>OutOfMemoryError</code>。内存溢出会导致应用程序立即崩溃，影响系统的稳定性和可用性。以下是JVM中常见的内存溢出情况及其原因：</p>
<ol>
<li><strong>堆内存溢出（Heap OutOfMemoryError）</strong></li>
</ol>
<p>堆内存溢出是指JVM在堆内存中无法分配足够的空间来存储新创建的对象，导致抛出 <code>OutOfMemoryError</code>。</p>
<ul>
<li><strong>大量对象创建</strong>：程序中创建了大量对象，且这些对象的生命周期较长，导致堆内存不足。</li>
<li><strong>持久引用</strong>：对象被持久引用（如静态变量、缓存等），导致这些对象无法被回收，最终导致堆内存不足。</li>
<li><strong>内存泄漏</strong>：程序中存在内存泄漏，导致不再使用的对象无法被回收，最终导致堆内存不足。</li>
</ul>
<ol start="2">
<li><strong>栈溢出（StackOverflowError）</strong></li>
</ol>
<p>栈溢出是指线程的栈空间不足，导致抛出 <code>StackOverflowError</code>。栈溢出通常发生在递归调用深度过大或方法调用层次过深的情况下。</p>
<ul>
<li><strong>递归调用</strong>：递归调用深度过大，导致栈空间不足。</li>
<li><strong>方法调用层次过深</strong>：方法调用层次过深，导致栈空间不足。</li>
<li><strong>局部变量过多</strong>：方法中局部变量过多，导致栈空间不足。</li>
</ul>
<ol start="3">
<li><strong>元空间溢出（Metaspace OutOfMemoryError）</strong></li>
</ol>
<p>元空间溢出是指JVM在元空间（Metaspace）中无法分配足够的空间来存储类的元数据信息，导致抛出 <code>OutOfMemoryError</code>。元空间在Java 8及之后的版本中替代了永久代（PermGen）。</p>
<ul>
<li><strong>类加载过多</strong>：程序中加载了大量类，导致元空间不足。</li>
<li><strong>动态生成类</strong>：使用动态代理、字节码生成等技术动态生成大量类，导致元空间不足。</li>
<li><strong>元空间配置不足</strong>：元空间的大小配置不足，无法满足程序的需求。</li>
</ul>
<ol start="4">
<li><strong>直接内存溢出（Direct Memory OutOfMemoryError）</strong></li>
</ol>
<p>直接内存溢出是指JVM在直接内存（Direct Memory）中无法分配足够的空间，导致抛出 <code>OutOfMemoryError</code>。直接内存是JVM通过Native函数库直接分配的内存，不受JVM堆内存的限制。</p>
<ul>
<li><strong>NIO操作</strong>：使用NIO（New I&#x2F;O）类库进行大量直接内存分配，导致直接内存不足。</li>
<li><strong>直接内存配置不足</strong>：直接内存的大小配置不足，无法满足程序的需求。</li>
<li><strong>内存泄漏</strong>：程序中存在直接内存泄漏，导致直接内存不足。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">xiaoyan</div><div class="post-copyright__author_desc">无限进步。</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/')">JVM-内存模型</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM-内存模型&amp;url=http://example.com/2024/10/05/Java-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/&amp;pic=https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410050927260.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">XIAOYAN</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>编程语言<span class="categoryesPageCount">21</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>Java<span class="categoryesPageCount">20</span></a><a class="post-meta__box__categoryes" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/JVM/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>JVM<span class="categoryesPageCount">3</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>内存模型<span class="tagsPageCount">1</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/30/Spring-SpringCloud/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://spring.io/img/extra/cloud-3.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Cloud</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/05/Java-JVM%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410051712703.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM-类初始化与类加载</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/user.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">是一只时时翻垃圾吃的宅子。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">xiaoyan</h1><div class="author-info__desc">无限进步。</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/xiaoyanfufu" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/483597064" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">了解JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">元空间（Metaspace）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stacks%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stacks%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈（Native Method Stacks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">堆内存（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">直接内存（Direct Memory）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9AJVM%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">1.7.</span> <span class="toc-text">扩展：JVM参数配置与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">虚拟机栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E6%8C%87%E9%92%88%E8%BF%98%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">栈中存放的是指针还是对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">栈中存储的是对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%86%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">为什么区分引用和对象很重要？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.</span> <span class="toc-text">堆的划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 新生代（Young Generation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Eden-Space"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1.1 Eden Space</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Survivor-Space"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">1.2 Survivor Space</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 老年代（Old Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 元空间（Metaspace）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%8C%BA%EF%BC%88Humongous-Region%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 大对象区（Humongous Region）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">JVM 堆和栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">堆和栈的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">方法区中方法执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.</span> <span class="toc-text">方法区中的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">String保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String-abc-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-number">6.2.</span> <span class="toc-text">String s &#x3D; new String(&quot;abc&quot;) 执行过程中涉及的内存分区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">1. 堆内存（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88String-Pool%EF%BC%89"><span class="toc-number">6.2.2.</span> <span class="toc-text">2. 字符串常量池（String Pool）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack%EF%BC%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">3. 栈内存（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.2.4.</span> <span class="toc-text">执行过程详细步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">引用类型及其区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. 强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. 软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. 弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">4. 虚引用（Phantom Reference）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.</span> <span class="toc-text">弱引用应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.5.</span> <span class="toc-text">内存泄漏与内存溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">内存泄漏（Memory Leak）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88Out-of-Memory-OOM%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">内存溢出（Out of Memory, OOM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">内存溢出的常见原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E6%83%85%E5%86%B5"><span class="toc-number">6.6.</span> <span class="toc-text">JVM 内存溢出情况</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-b76d79b11c3e8dd25f3c6abae8889a88_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-分库分表"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" title="数据库优化-分库分表">数据库优化-分库分表</a><time datetime="2024-11-03T08:20:54.000Z" title="发表于 2024-11-03 16:20:54">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202411041125092.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库优化-读写分离与冷热分离"/></a><div class="content"><a class="title" href="/2024/11/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%8E%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB/" title="数据库优化-读写分离与冷热分离">数据库优化-读写分离与冷热分离</a><time datetime="2024-11-03T08:18:25.000Z" title="发表于 2024-11-03 16:18:25">2024-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410282316960.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-进程管理"/></a><div class="content"><a class="title" href="/2024/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" title="操作系统-进程管理">操作系统-进程管理</a><time datetime="2024-10-28T14:52:35.000Z" title="发表于 2024-10-28 22:52:35">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410281041645.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-分布式事务"/></a><div class="content"><a class="title" href="/2024/10/27/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="分布式-分布式事务">分布式-分布式事务</a><time datetime="2024-10-27T13:08:20.000Z" title="发表于 2024-10-27 21:08:20">2024-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaoyanfufu-io.oss-cn-guangzhou.aliyuncs.com/blog/202410272103963.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式-服务治理（下）"/></a><div class="content"><a class="title" href="/2024/10/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="分布式-服务治理（下）">分布式-服务治理（下）</a><time datetime="2024-10-21T07:24:49.000Z" title="发表于 2024-10-21 15:24:49">2024-10-21</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 By <a class="footer-bar-link" href="/" title="xiaoyan" target="_blank">xiaoyan</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">65</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">17</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=12613265870&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Bean/" style="font-size: 0.88rem;">Bean<sup>1</sup></a><a href="/tags/DDD/" style="font-size: 0.88rem;">DDD<sup>1</sup></a><a href="/tags/IoC/" style="font-size: 0.88rem;">IoC<sup>1</sup></a><a href="/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" style="font-size: 0.88rem;">Java8新特性<sup>1</sup></a><a href="/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" style="font-size: 0.88rem;">Java基本概念<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Map/" style="font-size: 0.88rem;">Map<sup>2</sup></a><a href="/tags/MyBatis/" style="font-size: 0.88rem;">MyBatis<sup>1</sup></a><a href="/tags/MySQL%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">MySQL基础<sup>1</sup></a><a href="/tags/Object/" style="font-size: 0.88rem;">Object<sup>1</sup></a><a href="/tags/SQL%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">SQL调优<sup>1</sup></a><a href="/tags/Set/" style="font-size: 0.88rem;">Set<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 0.88rem;">事务<sup>2</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">内存模型<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="font-size: 0.88rem;">垃圾回收<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">对象<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">并发安全<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%8B%B7%E8%B4%9D/" style="font-size: 0.88rem;">拷贝<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 0.88rem;">数据类型<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 0.88rem;">日志<sup>2</sup></a><a href="/tags/%E6%9F%A5%E8%AF%A2/" style="font-size: 0.88rem;">查询<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%AD%96%E7%95%A5/" style="font-size: 0.88rem;">策略<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" style="font-size: 0.88rem;">类初始化<sup>1</sup></a><a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 0.88rem;">类加载<sup>1</sup></a><a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 0.88rem;">索引<sup>2</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">线程模型<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 0.88rem;">线程池<sup>1</sup></a><a href="/tags/%E9%94%81/" style="font-size: 0.88rem;">锁<sup>2</sup></a><a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 0.88rem;">集群<sup>1</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>