[{"title":"MySQL日志可以用来干啥？","date":"2024-09-17T06:21:45.000Z","url":"/2024/09/17/MySQL%E6%97%A5%E5%BF%97%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%95%A5%EF%BC%9F/","categories":[["MySQL","/categories/MySQL/"],["日志","/categories/MySQL/%E6%97%A5%E5%BF%97/"]],"content":"了解MySQL的童靴们都知道，MySQL有好几种日志——undo log（回滚日志）、redo log（重做日志）还有binlog（归档日志），为啥需要这么多日志？这些日志分别都是干啥用的？在进一步探讨这么些问题之前，我们需要先了解一下一条SQL语句的执行过程。 笔者作为一名初学小白，时常感到好奇：当执行了 SQL 语句对数据记录进行修改时，如果突然遭遇系统关机、服务器卡死等故障，这段记录修改该如何是好？ 小伙伴们可能会不假思索地回答：“通过事务回滚恢复到执行增删改之前的状态！” 没错，这确实是 MySQL 保障数据安全的重要机制之一。即使我们没有显式地开启事务和提交事务，MySQL 也会隐式地启动事务执行“增删改”语句，并在执行完后自动提交事务（MySQL 默认开启了 autocommit 参数）。 但你是否想过，MySQL 是如何实现这种“时光倒流”般的神奇操作的呢？这就要归功于 MySQL 的“时光机”—— undolog、redolog 和 binlog。它们就像数据库的“守护天使”，默默地记录着数据的每一次变化，在关键时刻挺身而出，保障数据的安全性和一致性。 undolog、redolog 和 binlog 是 MySQL 保障数据安全的三大利器，它们各司其职，共同构建了 MySQL 强大的数据保护机制： undolog ：负责事务的原子性和 MVCC，确保数据的一致性。 redolog ：负责事务的持久性，确保数据不会因故障而丢失。 binlog ：负责数据的备份和主从复制，确保数据的可靠性和高可用性。 接下来，我们来进一步探讨这三种日志如何实现数据库神操作。 Undo Log 是干啥的在前言我们提到，MySQL 会隐式开启事务执行“增删改”语句，当操作过程中发生崩溃时，事务会进行回滚。那么，回滚操作中旧的数据要从哪里来呢？ 想象一下，如果在执行“增删改”操作之前，我们将要操作的数据记录做一个备份，那么当我们想恢复到执行操作之前的状态时，只要对照备份的信息就可以了。 当然，每次执行操作都要进行备份会很麻烦，但我们可以根据需求进行相应的操作记录。例如： 执行删除操作之前，记录要删除的记录信息，若想恢复，我们再把记录插回去； 执行新增操作之前，记下新增记录的ID，撤销新增只需要把对应ID记录删除即可； 执行修改操作之前，记录修改前的数据，撤销修改时只需将数据恢复到修改前的状态。 这种记录操作前数据的方式，正是 MySQL 中 Undo Log （回滚日志）的核心思想。Undo Log 记录了事务执行过程中对数据的修改操作，用于在事务回滚时撤销这些修改，将数据恢复到事务开始前的状态，它保证了事务的ACID特性中的原子性。 undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图: 每当 InnoD8 引擎对一条记录进行操作(修改、删除、新增)时，要把回滚时需要的信息都记录到 undo log 里，发生回滚时，就读取undo log日志记录的数据，执行相反的操作来完成数据恢复。 需要注意的是，不同的操作，因需求不同，其undo log格式也不同，此处仅以更新操作的日志为例。每条记录的每一次更新操作产生的 Undo Log 格式中，都包含一个 roll_pointer 指针和一个 trx_id 事务 ID： trx_id 事务 ID：用于标识该记录是被哪个事务修改的，帮助系统追踪事务的执行顺序。 roll_pointer 指针：将这些 Undo Log 串成一个链表，这个链表就被称为版本链。版本链记录了该记录的所有历史版本，使得系统可以在需要时回滚到任意一个历史状态。 版本链的结构如下图所示： 另外，Undo Log 通过 ReadView + Undo Log 实现 MVCC（多版本并发控制）。 对于「读提交」和「可重复读」隔离级别的事务： 「读提交」：每次 SELECT 生成新的 Read View，可能导致同一事务中多次读取同一条数据时结果不一致。 「可重复读」：事务启动时生成 Read View，并在整个事务期间使用，确保读取的数据一致。 这两个隔离级别通过「事务的 Read View 里的字段」和「记录中的隐藏列（trx_id 和 roll_pointer）」进行比对，如果不满足可见性条件，就会顺着 Undo Log 版本链找到满足其可见性的记录，实现 MVCC。 因此，Undo Log 的两大作用是： 实现事务回滚，保障事务的原子性：在事务处理过程中，如果出现错误或用户执行 ROLLBACK 语句，MySQL 可以利用 Undo Log 中的历史数据将数据恢复到事务开始之前的状态。 实现 MVCC（多版本并发控制）的关键因素之一：MVCC 通过 ReadView + Undo Log 实现。Undo Log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 SELECT 语句）时，会根据事务的 Read View 里的信息，顺着 Undo Log 的版本链找到满足其可见性的记录。 Buffer Poll是干啥的【更新中。。。】"},{"title":"Java集合（Set篇）","date":"2024-09-09T05:14:03.000Z","url":"/2024/09/09/Java%E9%9B%86%E5%90%88%EF%BC%88Set%E7%AF%87%EF%BC%89/","tags":[["Set","/tags/Set/"]],"categories":[["Java","/categories/Java/"],["集合","/categories/Java/%E9%9B%86%E5%90%88/"]],"content":"主要收集了集合的一些Set知识。 Set集合特点Set集合是一种不包含重复元素的集合，它具有以下特点： 唯一性：Set集合中的元素是唯一的，不允许有重复的元素。 无序性：Set集合中的元素没有特定的顺序，即元素的存储顺序与插入顺序无关。 不可变性：Set集合中的元素一旦插入，通常不能被修改（除非删除后重新插入）。 Set集合key无重复原理Set集合通过内部的数据结构来实现元素的唯一性。常见的实现方式包括使用哈希表（HashMap）或红黑树（TreeMap）等数据结构。以下是Set集合实现key无重复的基本原理： 哈希表（HashMap）实现在Java中，HashSet是基于HashMap实现的。HashSet内部维护了一个HashMap，其中元素作为HashMap的key，而HashMap的value是一个固定的虚拟对象（通常是一个常量对象）。 插入元素的过程： 计算哈希值：当向HashSet中插入一个元素时，首先会计算该元素的哈希值（通过hashCode()方法）。 确定存储位置：根据哈希值确定元素在哈希表中的存储位置。 检查重复：在存储位置上，通过equals()方法检查是否已经存在相同的元素。如果存在相同的元素，则不插入；否则，将元素插入到哈希表中。 红黑树（TreeMap）实现在Java中，TreeSet是基于TreeMap实现的。TreeSet内部维护了一个TreeMap，其中元素作为TreeMap的key，而TreeMap的value是一个固定的虚拟对象。 插入元素的过程： 比较元素：当向TreeSet中插入一个元素时，首先会通过元素的compareTo()方法（或Comparator）进行比较。 检查重复：如果比较结果表明元素已经存在（即compareTo()返回0），则不插入；否则，将元素插入到红黑树中。 总结 无论是基于哈希表还是红黑树，Set集合实现key无重复的核心原理都是通过比较元素的哈希值或直接比较元素本身来确保集合中的元素唯一。具体步骤如下： 计算哈希值或比较元素：根据元素的哈希值或直接比较元素。 检查重复：通过equals()方法或compareTo()方法检查是否已经存在相同的元素。 插入或拒绝：如果元素不存在，则插入；否则，拒绝插入。 有序的Set集合在Java中，TreeSet和LinkedHashSet是两种常见的Set集合实现，它们分别提供了有序性和记录插入顺序的功能。 TreeSetTreeSet是基于红黑树（Red-Black Tree）实现的，它保证了元素的自然顺序。红黑树是一种自平衡的二叉查找树，能够在插入和删除操作后自动调整树的结构，以保持树的平衡。 特点： 有序性：TreeSet中的元素按照自然顺序（或通过自定义的Comparator）进行排序。 唯一性：TreeSet中的元素是唯一的，不允许重复。 性能：插入、删除和查找操作的时间复杂度为O(log n)。 LinkedHashSetLinkedHashSet是基于哈希表和双向链表实现的，它保证了元素的插入顺序。哈希表用于快速查找元素，而双向链表用于维护元素的插入顺序。 特点： 插入顺序：LinkedHashSet中的元素按照插入顺序进行存储和遍历。 唯一性：LinkedHashSet中的元素是唯一的，不允许重复。 性能：插入、删除和查找操作的时间复杂度为O(1)。 记录插入顺序的集合通常指的是LinkedHashSet。LinkedHashSet通过维护一个双向链表来记录元素的插入顺序，因此它能够保证元素按照插入顺序进行存储和遍历。 以下是一个使用LinkedHashSet来记录插入顺序的代码示例： 由于LinkedHashSet不允许重复元素，因此插入重复元素不会改变集合的内容，插入顺序保持不变。 运行上述代码后，输出结果如下： 可以看到，LinkedHashSet成功地记录了元素的插入顺序，并且重复元素不会被插入。"},{"title":"Java集合（Map篇-上）","date":"2024-09-09T05:14:02.000Z","url":"/2024/09/09/Java%E9%9B%86%E5%90%88%EF%BC%88Map%E7%AF%87-%E4%B8%8A%EF%BC%89/","tags":[["Map","/tags/Map/"]],"categories":[["Java","/categories/Java/"],["集合","/categories/Java/%E9%9B%86%E5%90%88/"]],"content":"主要收集了集合的一些Map知识。 HashMap 原理HashMap 是 Java 中常用的键值对存储结构，其底层实现经历了多次优化。在 Java 1.7 之前，HashMap 的存储结构为数组 + 链表，而在 Java 1.8 中引入了红黑树来优化链表过长导致的性能问题。 Java 1.7 及之前的 HashMap在Java 1.7 及之前的HashMap存储结构为数组 + 链表，通过哈希算法将元素的键值映射到数组中的槽位（bucket），如果多个键映射到同一个槽位上，它们就会使用链表连接在一起。 由此也就引发了一个问题：当哈希冲突严重时，链表会变得非常长，查询性能会下降到 O(n)，导致性能变差。 Java 1.8 的优化在Java 1.8 之后，对HashMap进行了优化，采用数组 + 链表 + 红黑树的数据结构：当链表长度大于 8 时，链表会转化为红黑树，查询性能提升到 O(log n)；当链表长度小于 6 时，红黑树会退化为链表。 关键点 哈希算法：HashMap 使用哈希算法将键值映射到数组的槽位，哈希算法的设计直接影响哈希冲突的概率和性能。 链表与红黑树的转换： 链表转红黑树： 当链表长度大于 8 时，链表会转化为红黑树。 红黑树转链表： 当红黑树节点数小于 6 时，红黑树会退化为链表。 红黑树的特性： 自平衡： 红黑树是一种自平衡的二叉查找树，能够在插入和删除操作后自动调整树的结构，保持树的高度平衡。 查询性能： 红黑树的查询、插入和删除操作的平均时间复杂度为 O(log n)。 以下是 Java 1.8 中 HashMap 的部分源码： Java 1.7 及之前： HashMap 使用数组 + 链表的结构，链表查询复杂度为 O(n)。 Java 1.8 及之后： 引入了红黑树，当链表长度大于 8 时转化为红黑树，查询复杂度提升到 O(log n)，当链表长度小于 6 时退化为链表。 这种优化显著提高了 HashMap 在哈希冲突严重时的查询性能，使其在实际应用中更加高效。 哈希冲突解决办法哈希冲突是指不同的键值通过哈希函数计算后，映射到同一个哈希桶（bucket）中。为了解决哈希冲突，常见的解决方法有以下几种： 1.链表法（Separate Chaining） 使用链表等数据结构存储冲突的键值，将它们连接在同一个桶里。 每个桶（bucket）维护一个链表，当发生哈希冲突时，将新元素插入到链表的尾部。 2. 开放寻址法（Open Addressing） 在哈希表中找一个可用的位置来存放冲突的键值，而不使用同一个链表进行存储。 常见的开放寻址法有线性探测、二次探测和双重哈希。 3. 再哈希法（Rehashing） 当哈希冲突时，使用另一个哈希函数进行二次哈希，直到找到一个可用的空槽。 再哈希函数的选择需要避免再次冲突。 4. 哈希桶扩容（Resize） 动态增加哈希桶的容量，重新分配键值对，即可减少哈希冲突。 当哈希表的负载因子（load factor）达到一定阈值时，进行扩容操作。 HashMap 线程安全吗？HashMap 是线程不安全的，在多线程情况下会出现以下问题： Java 1.7 及之前的问题在 Java 1.7 及之前，HashMap 的数据结构为数组 + 链表。在多线程环境下，多个线程同时进行扩容操作时，可能会导致链表形成环状结构（由于此前版本在扩容复制新链表时，采用的是头插法，在新的链表中指针的顺序会进行翻转），从而引发Entry 链死循环；当多个线程同时进行插入操作时，可能会导致数据丢失。 Java 1.8 及之后的问题在 Java 1.8 及之后，HashMap 采用了数组 + 链表 + 红黑树的数据结构，优化了之前版本的问题（采用了尾插的形式，不会导致环形链表进入死循环）。但在多线程背景下，put 方法仍然存在数据丢失的问题（例如，两个线程同时检测到某个索引位置为空，并同时插入新节点，导致其中一个线程插入的数据被覆盖。）。 线程安全的解决方案如果想要保证 HashMap 的线程安全，可以使用以下方式： 使用 Collections.synchronizedMap 方法进行加锁 底层实现： Collections.synchronizedMap 方法会返回一个包装了原始 HashMap 的同步视图。 其底层实现原理是为每个方法调用添加一个同步块（synchronized block），确保同一时刻只有一个线程可以访问该 Map。 缺点： 性能开销较大，因为每次方法调用都需要获取和释放锁。 迭代时需要手动同步，否则可能会抛出 ConcurrentModificationException。 ###使用 Hashtable 底层实现： Hashtable 是线程安全的 Map 实现，其所有方法都使用 synchronized 关键字进行同步。 使用 ConcurrentHashMap 底层实现： ConcurrentHashMap 是 java.util.concurrent 包中的一个线程安全 Map 实现。 采用分段锁（Segment）机制，将 Map 分成多个段（Segment），每个段独立加锁，从而提高并发性能。 总结 HashMap： 线程不安全，多线程环境下可能会出现死循环和数据丢失问题。 Collections.synchronizedMap： 简单易用，但性能开销较大。 Hashtable： 线程安全，但性能较差。 ConcurrentHashMap： 线程安全，性能较高，适用于高并发场景。 HashMap的“put”过程在多线程背景下，HashMap 的 put 方法可能会出现数据丢失或覆盖等问题。为了深入理解这些问题，我们来看看 put 方法的具体流程。 1.根据键计算哈希码获得索引： 使用键的哈希码计算出在数组中的索引位置。 计算公式：index = hash(key) &amp; (table.length - 1) 2.检查该索引位置是否为空：如果该索引位置为空，直接将新节点插入到该位置。 3.如果索引已存在，则对比键值是否相同：遍历该索引位置的链表或红黑树，查找是否存在相同的键，如果找到相同的键，则直接覆盖该位置的值，完成更新。 4.如果键值不同，则插入新节点：如果链表长度小于 8，将新节点插入到链表的尾部。如果链表长度大于等于 8，将链表转化为红黑树，并将新节点插入到红黑树中。 put(K key, V val)和get(K key)HashMap 是 Java 中常用的键值对存储结构，其核心操作包括 put(K key, V val) 和 get(K key) 方法。这两个方法分别用于存储对象和读取对象，其底层实现依赖于哈希算法和数组结构。 put(K key, V val) 方法： 计算哈希值： 使用传入的 key 计算哈希值。 计算公式：hash = hash(key) 计算数组索引： 使用哈希值计算出在数组中的索引位置。 计算公式：index = hash &amp; (table.length - 1) 检查索引位置： 如果该索引位置为空，直接将新节点插入到该位置。 如果该索引位置已存在节点，则遍历链表或红黑树，查找是否存在相同的键。 处理冲突： 如果找到相同的键，则直接覆盖该位置的值，完成更新。 如果键值不同，则插入新节点： 如果链表长度小于 8，将新节点插入到链表的尾部。 如果链表长度大于等于 8，将链表转化为红黑树，并将新节点插入到红黑树中。 检查负载因子： 如果插入后达到了 HashMap 设置的负载阈值（默认为 0.75），则需要扩容 100%。 扩容操作会创建一个新的数组，并将原数组中的元素重新分配到新数组中。 代码： get(K key) 方法 计算哈希值： 使用传入的 key 计算哈希值。 计算公式：hash = hash(key) 计算数组索引： 使用哈希值计算出在数组中的索引位置。 计算公式：index = hash &amp; (table.length - 1) 检查索引位置： 如果该索引位置为空，返回 null。 如果该索引位置已存在节点，则遍历链表或红黑树，查找是否存在相同的键。 处理哈希冲突： 如果节点是链表结构，遍历链表查找键值。 如果节点是红黑树结构，调用红黑树的查找方法。 返回值： 如果找到相同的键，返回对应的值。 如果未找到相同的键，返回 null。 代码： 为什么 HashMap 使用的是红黑树而不是其他？选择红黑树的主要原因是为了优化查询性能，因此选用了查询性能优秀的平衡树一类。 为什么不是平衡二叉树？平衡二叉树（如 AVL 树）追求一种“完美平衡”，即任何节点的子树高度差都不超过 1。这种严格的平衡性确保了查询操作的时间复杂度为 O(log n)，但在插入或删除数据时，很容易破坏这种平衡。为了保持平衡，树会进行频繁的旋转操作，从而消耗大量性能。 红黑树的优势红黑树是一种自平衡的二叉查找树，它通过引入颜色标记和一些规则来保持树的平衡。红黑树的平衡性要求相对较弱，不需要频繁维护树的平衡，从而减少了开销。 红黑树的特性 自平衡： 红黑树通过颜色标记和旋转操作来保持树的平衡，插入和删除操作的时间复杂度为 O(log n)。 弱平衡： 红黑树的平衡性要求相对较弱（整个树的最长路径不会超过最短路径的2倍），不需要频繁进行旋转操作，减少了维护平衡的开销。 查询性能： 红黑树的查询性能略逊于平衡二叉树，但仍然为 O(log n)，与平衡二叉树相差不大。 红黑树与平衡二叉树的对比 特性 红黑树 平衡二叉树（如 AVL 树） 平衡性要求 弱平衡 严格平衡 旋转操作 较少 频繁 插入&#x2F;删除性能 较好 较差 查询性能 O(log n) O(log n) 实现复杂度 中等 较高 为什么选择红黑树？综合考虑以下因素，选择红黑树更为合适： 查询性能： 红黑树的查询性能为 O(log n)，与平衡二叉树相差不大。 插入&#x2F;删除性能： 红黑树的插入和删除操作性能较好，因为不需要频繁进行旋转操作。 实现复杂度： 红黑树的实现复杂度适中，易于理解和实现。 总结 红黑树： 自平衡、弱平衡、查询性能为 O(log n)、插入&#x2F;删除性能较好、实现复杂度适中。 平衡二叉树： 严格平衡、查询性能为 O(log n)、插入&#x2F;删除性能较差、实现复杂度较高。 在 HashMap 中，选择红黑树是为了在保证查询性能的同时，减少插入和删除操作的开销，从而提高整体性能。 HashMap的key可以为null吗？答案是可以的。 hashMap中使用hash()方法来计算key的哈希值，当key为空时，直接令key的哈希值为0，不走key.hashcode()方法; HashMap虽然支持key和value为null，但是null作为key只能有一个，null作为value可以有多个。因为HashMap中，如果key值一样，那么会覆盖相同key值的value为最新，所以key为nul只能有一个。 HashCode.equals和hashMap.hashCode在 HashMap 中比较元素时，首先会通过 hashCode 进行比较，如果 hashCode 相同，再通过 equals 方法进行比较。因此，如果两个对象通过 equals 方法比较是相等的，那么它们的 hashCode 必须相等。然而，hashCode 相等的两个对象，equals 方法的比较结果不一定相等（例如，在发生哈希冲突的情况下）。 如果这些方法没有被正确地实现，可能会导致两个不同的 Key 产生相同的哈希码和 equals() 输出，从而导致 HashMap 认为它们是相同的，进而覆盖它们，而不是将它们存储到不同的地方。 如果在重写 equals 方法时没有同时重写 hashCode 方法，可能会导致 equals 方法返回 true，而 hashCode 方法返回不同的值。这种情况的后果是，在 HashMap 等类中可能会存储多个实际上相同的对象，从而导致数据覆盖的问题。这与 HashMap 中每个键必须是唯一的规范不符。 重写equals和hashCode方法应该保持以下原则： 如果 o1.equals(o2)，那么 o1.hashCode() == o2.hashCode() 总是为 true。 如果 o1.hashCode() == o2.hashCode()，并不意味着 o1.equals(o2) 会为 true。 "},{"title":"Java集合（Map篇-下）","date":"2024-09-09T05:14:02.000Z","url":"/2024/09/09/Java%E9%9B%86%E5%90%88%EF%BC%88Map%E7%AF%87-%E4%B8%8B%EF%BC%89/","tags":[["Map","/tags/Map/"]],"categories":[["Java","/categories/Java/"],["集合","/categories/Java/%E9%9B%86%E5%90%88/"]],"content":"主要收集了集合的一些Map知识。 HashMap的扩容机制简述HashMap默认的负载因子（load factor）是0.75。负载因子定义了HashMap在触发扩容之前，允许的元素数量与容量的比例。具体来说，当HashMap中的元素个数超过当前容量的75%时，就会触发扩容操作。 扩容操作分为两个主要步骤： 扩展哈希表的长度：HashMap会将当前的容量扩展为原来的两倍。例如，如果当前容量是16，扩容后容量将变为32。 重新分配数据：扩容后，HashMap需要将旧哈希表中的数据重新分配到新的哈希表中。由于新的容量是原来的两倍，元素在新哈希表中的位置可能会发生变化。 负载因子为何选择0.75？负载因子的选择是一个权衡性能和空间利用率的过程。负载因子为0.75是一个经验值，它在以下两个方面取得了平衡： 减少哈希冲突：当负载因子较大时（例如0.8或0.9），数组中的元素密度增加，导致哈希冲突的概率上升，从而降低查询和插入操作的效率。 避免频繁扩容：当负载因子较小时（例如0.5或0.6），虽然哈希冲突减少，但扩容的频率增加，导致空间利用率降低，且频繁的扩容操作也会带来额外的性能开销。 为什么是扩容2倍？扩容2倍，其实是一个非常巧妙的设计。在扩容过程中，HashMap并不需要重新计算每个元素的哈希值。这是因为HashMap的容量总是2的幂次（例如16、32、64等），这使得扩容后的新索引可以通过简单的位运算来确定。 具体来说，当容量从n扩展到2n时，新的索引位置可以通过以下方式计算： 如果元素的哈希值在高位新增的bit为0，则元素在新哈希表中的位置与原位置相同。 如果元素的哈希值在高位新增的bit为1，则元素在新哈希表中的位置为原位置加上旧容量（即原索引 + oldCap）。 如下图示，元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index遵循上述规则计算： 扩展：为什么Hash计算时有一个右移16位操作？在Java的HashMap中，哈希值的计算并不仅仅依赖于对象的hashCode()方法，而是通过一个额外的位运算来进一步优化哈希值的分布。具体来说，HashMap在计算哈希值时，会进行一个右移16位的操作，然后将结果与原哈希值进行异或运算。这个操作的目的是为了减少哈希碰撞，提高HashMap的性能。 源码分析 我们来看一下HashMap中计算哈希值的源码： 在这段代码中，h是对象的原始哈希值，h &gt;&gt;&gt; 16表示将h右移16位。然后，将右移后的结果与原哈希值进行异或运算（^），得到最终的哈希值。 为什么需要右移16位？ 哈希值h是一个32位的整数。如果不进行任何处理，直接使用h作为哈希值，可能会导致哈希碰撞的概率增加。这是因为hashCode()方法返回的哈希值在低位可能会有较多的重复，尤其是在处理较小的数据集时。 通过将h右移16位，相当于将哈希值的高16位与低16位进行混合。这种混合操作可以有效地将高位信息引入到低位，从而减少哈希碰撞的可能性。具体来说： 右移16位：将哈希值的高16位移到低16位，这样低16位就包含了高16位的信息。 异或运算：通过异或运算，将高16位和低16位的信息进行混合，使得最终的哈希值在低位也包含了高位的信息。 通过右移16位并进行异或运算，HashMap能够更有效地利用哈希值的高位信息，减少哈希碰撞的概率。这种设计使得HashMap在处理大量数据时仍能保持较高的性能，确保键值对的快速查找和插入。 HashTable原理HashTable是一种基于哈希表的数据结构，用于存储键值对。其内部实现主要依赖于数组和链表的结合，以解决哈希冲突问题。 数据结构 数组：HashTable的主体是一个数组，数组的每个元素称为“桶”（bucket）。数组的大小通常是固定的，或者可以根据需要进行动态调整。 链表：当不同的键值对通过哈希函数计算得到的哈希值相同，即发生哈希冲突时，HashTable使用链表来存储这些键值对。每个桶中可以存储一个链表，链表中的每个节点包含一个键值对。 线程安全 HashTable的所有公共方法都使用了synchronized关键字进行修饰，这意味着每个方法在执行时都会获取对象级别的锁。这种设计确保了HashTable在多线程环境下的线程安全性，但同时也带来了性能上的开销，因为每次方法调用都会导致线程阻塞。 HashMap和HashTable的区别HashMap和HashTable都是Java中用于存储键值对的数据结构，但它们在实现和使用上有一些关键的区别。以下是它们的主要区别： 1. 线程安全性 HashMap：HashMap是线程不安全的。这意味着在多线程环境下，如果多个线程同时对同一个HashMap进行操作，可能会导致数据不一致或其他并发问题。 HashTable：HashTable是线程安全的。HashTable的所有公共方法都使用了synchronized关键字进行修饰，确保在多线程环境下操作的安全性。例如： 这意味着在同一时刻，只有一个线程可以执行HashTable的某个方法，从而避免了并发问题。 2. 性能 HashMap：由于HashMap不是线程安全的，因此在单线程环境下，HashMap的性能通常优于HashTable。HashMap不需要额外的同步开销，因此在读写操作上更快。 HashTable：由于HashTable的方法都使用了synchronized关键字，因此在多线程环境下，HashTable的性能可能会受到影响。每次方法调用都需要获取锁，这会增加额外的开销。 3. 允许null值 HashMap：HashMap允许键和值为null。也就是说，你可以将null作为键或值存储在HashMap中。 HashTable：HashTable不允许键或值为null。如果尝试将null作为键或值存储在HashTable中，会抛出NullPointerException。 4. 迭代器 HashMap：HashMap的迭代器是快速失败的（fail-fast）。如果在迭代过程中，HashMap的结构发生了变化（例如添加或删除元素），迭代器会抛出ConcurrentModificationException。 HashTable：HashTable的迭代器也是快速失败的，但它的迭代器实现方式与HashMap略有不同。 总结 HashMap和HashTable在实现和使用上有显著的区别。HashMap适用于单线程环境，性能更好，允许null键和值；而HashTable适用于多线程环境，线程安全，但不允许null键和值，性能相对较差。在现代Java编程中，推荐使用ConcurrentHashMap来替代HashTable，以获得更好的性能和扩展性。 ConcurrentHashMap原理ConcurrentHashMap是Java中用于并发环境下的高效键值对存储数据结构。它在Java 1.7及之前版本和Java 1.8及之后版本有不同的实现方式。以下是ConcurrentHashMap在不同版本中的实现原理及其优化的详细介绍。 Java 1.7及之前版本的实现在Java 1.7及之前版本中，ConcurrentHashMap采用了分段锁（Segment）技术来实现线程安全。其核心结构是数组+链表，具体分为以下几个部分： Segment数组：ConcurrentHashMap内部包含一个Segment数组，每个Segment相当于一个小的HashMap，并且是一个可重入锁（ReentrantLock）。 HashEntry数组：每个Segment内部包含一个HashEntry数组，HashEntry用于存储键值对数据。每个HashEntry是一个链表结构的元素。 分段锁技术： ConcurrentHashMap将数据分成多个段（Segment），每个段相当于一个小的HashMap，并且有自己的锁。 当一个线程访问某个段的数据时，只需要锁住该段，而不影响其他段的数据访问。这样就实现了并发访问，提高了并发性能。 缺点： 虽然分段锁技术提高了并发性能，但由于使用了链表结构，当链表过长时，访问速度会变慢，因为需要遍历链表。 Java 1.8及之后版本的实现在Java 1.8及之后版本中，ConcurrentHashMap进行了优化，采用了数组+链表&#x2F;红黑树的数据结构，并使用volatile+CAS或synchronized来实现线程安全。具体实现如下： 数组+链表&#x2F;红黑树：ConcurrentHashMap内部使用一个数组来存储数据，每个数组元素（桶）可以是一个链表或红黑树。当链表长度超过一定阈值时，链表会转换为红黑树，以提高查找效率。 volatile+CAS：用于实现无锁的并发操作，例如初始化容器或设置节点。 synchronized：用于在发生冲突时对桶的头节点加锁，确保线程安全。 添加元素的过程： 初始化容器：如果容器为空，使用volatile+CAS来初始化容器。 计算桶位置：根据存储的元素计算桶的位置。 CAS设置节点：如果计算结果为空，则利用CAS设置该节点。 synchronized加锁：如果桶不为空，则使用synchronized对桶的头节点加锁，然后遍历桶中的元素，并替换或新增节点到桶中。 转换为红黑树：最后判断是否需要将链表转换为红黑树，以提高查找效率。 优点： 锁粒度更小：通过只对桶的头节点加锁，锁的粒度相比分段锁更小，减少了锁的竞争，提高了并发性能。 红黑树优化：当链表过长时，转换为红黑树，提高了查找效率。 总结 ConcurrentHashMap在Java 1.8及之后版本中通过数组+链表&#x2F;红黑树的数据结构和volatile+CAS或synchronized的并发控制机制，实现了高效的并发访问。相比Java 1.7及之前版本的分段锁技术，Java 1.8及之后版本的ConcurrentHashMap在锁粒度和查找效率上都有显著提升，更适合高并发的场景。 一句话归纳：Java 1.8及之后版本的ConcurrentHashMap通过对桶的头节点加锁，锁的粒度更小，减少了锁的竞争，同时通过红黑树优化提高了查找效率，从而实现了更高的并发性能。 分段锁怎么加锁的？在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。 在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment,然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。 什么是可重入锁？可重入锁（Reentrant Lock）是一种同步机制，允许同一个线程多次获取同一个锁，而不会导致死锁。它是 Java 中 java.util.concurrent.locks.ReentrantLock 类的实现。 同一个线程可以多次获取同一个锁，而不会被自己阻塞。每次获取锁时，锁的计数器会递增；每次释放锁时，计数器会递减。只有当计数器归零时，锁才会完全释放。 JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。 为什么使用了synchronized还要使用CAS？CAS是一种无锁的并发控制机制，它通过硬件级别的原子操作来实现线程安全。CAS操作包括三个参数：内存位置、预期值和更新值。CAS操作会先比较内存位置的当前值是否等于预期值，如果相等，则将内存位置的值更新为新值，并返回成功；否则，返回失败。CAS的主要作用是： 无锁操作：CAS操作不需要加锁，因此不会阻塞线程，减少了线程切换的开销。 原子性：CAS操作是原子的，可以确保在多线程环境下对共享变量的修改是安全的。 在ConcurrentHashMap中，CAS主要用于一些不需要加锁的简单操作，例如初始化容器、设置节点等。 综合原因 在ConcurrentHashMap中，synchronized和CAS结合使用的原因如下： 减少锁竞争：CAS操作是无锁的，可以在不加锁的情况下完成一些简单的操作，减少了锁的竞争，提高了并发性能。 优化初始化：在初始化ConcurrentHashMap时，使用CAS操作可以确保只有一个线程能够成功初始化容器，避免了多个线程同时初始化容器的问题。 提高并发性能：对于一些不需要遍历链表或红黑树的操作，使用CAS可以避免加锁，从而提高并发性能。例如，在添加元素时，如果桶为空，可以直接使用CAS操作设置节点，而不需要加锁。 细粒度锁控制：synchronized用于在发生哈希冲突时对桶的头节点加锁，确保线程安全地操作链表或红黑树。通过只对头节点加锁，锁的粒度更小，减少了锁的竞争，提高了并发性能。 ConcurrentHashMap使用了乐观锁还是悲观锁？ConcurrentHashMap在实现并发控制时，综合运用了乐观锁和悲观锁的机制。 容器初始化： ​ 当容器为空时，ConcurrentHashMap使用volatile关键字和CAS（Compare-And-Swap）操作进行初始化。volatile确保了变量的可见性，而CAS则是一种乐观锁机制，通过原子操作来确保初始化的线程安全性。 元素添加： 如果容器不为空，ConcurrentHashMap会根据元素的哈希值计算其在桶中的位置。 如果计算出的位置为空，则再次使用CAS操作来设置该节点，这是一种乐观锁的实现方式，通过原子操作来避免锁的开销。 如果计算出的位置不为空，ConcurrentHashMap会使用synchronized关键字对桶进行锁定，这是一种悲观锁的实现方式。锁定后，线程会遍历桶中的数据，并根据需要替换或新增节点。如果桶中的元素数量达到一定阈值，还会将链表结构转换为红黑树，以优化查找性能。 总结 ConcurrentHashMap在并发控制中灵活运用了乐观锁和悲观锁： 乐观锁：主要用于初始化和空桶位置的设置，通过CAS操作实现，减少了锁的开销。 悲观锁：用于非空桶的访问和修改，通过synchronized关键字实现，确保了操作的原子性和线程安全。 "},{"title":"Java集合（List篇）","date":"2024-09-09T05:14:01.000Z","url":"/2024/09/09/Java%E9%9B%86%E5%90%88%EF%BC%88List%E7%AF%87%EF%BC%89/","tags":[["List","/tags/List/"]],"categories":[["Java","/categories/Java/"],["集合","/categories/Java/%E9%9B%86%E5%90%88/"]],"content":"主要收集了集合的一些关于集合List的概念。 List的实现List接口是Java中常用的集合接口之一，提供了多种实现类，以满足不同的需求。以下是List接口的三个主要实现类及其特点和适用场景。 1. VectorVector是一个线程安全的动态数组，实现了List接口。Vector的所有方法都是同步的，因此适用于多线程环境。 特点 线程安全：所有方法都使用synchronized关键字进行同步。 动态调整大小：可以根据需要动态调整大小。 存储结构：存储的是对象数组，当空间不足时会创建一个新的数组，并将原来的数组拷贝过去。 性能较低：由于同步机制，Vector的性能通常低于非线程安全的ArrayList。 适用场景 需要线程安全的场景。 对性能要求不高的场景。 2. ArrayListArrayList是一个线程不安全的动态数组，实现了List接口。ArrayList在性能上比Vector快很多，适用于单线程环境。 特点 线程不安全：没有同步机制，性能较高。 动态调整大小：可以根据需要动态调整大小。 存储结构：存储的是对象数组，当空间不足时会创建一个新的数组，并将原来的数组拷贝过去。 扩容机制：扩容时增加50%的容量。 适用场景 单线程环境。 对性能要求较高的场景。 3. LinkedListLinkedList是一个双向链表，实现了List接口。LinkedList也是线程不安全的，适用于需要频繁插入和删除元素的场景。 特点 线程不安全：没有同步机制，性能较高。 存储结构：使用链表结构，插入和删除元素效率高。 随机访问较慢：由于不是顺序存储，访问元素时需要遍历链表，效率较低。 适用场景 需要频繁插入和删除元素的场景。 对随机访问性能要求不高的场景。 示例代码 概括 Vector：线程安全，适用于多线程环境，但性能较低。 ArrayList：线程不安全，适用于单线程环境，性能较高，适合随机访问。 LinkedList：线程不安全，适用于频繁插入和删除元素的场景，但随机访问性能较低。 了解ArrayList为什么 ArrayList 不是线程安全的？在高并发添加数据的情况下，ArrayList 会暴露以下三个问题： 部分值为 null（此前我们没有插入过 null 值） 索引越界 数组的 size 大小与插入 add 情况不一致 原因分析ArrayList 的 add 方法源码如下： 可以看到，插入一个元素的操作分为三步： step1：判断当前数组空间是否足够插入一个元素，不够则调用 grow 方法扩容。 step2：在 size 索引位置设置值为新插入的元素。 step3：维护 size 值加 1。 问题根源1. 部分值为 null： 在高并发情况下，多个线程可能同时执行 elementData[size] = e;，导致某些线程覆盖了其他线程插入的值，也就是在同一个索引位置设置值，但最后不同的线程都会给size++，最终导致部分值为 null。 2. 索引越界： 线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界(数组的下标索引从0开始): 3. 数组的 size 大小与插入 add 情况不一致： 由于 size++ 操作不是原子的，多个线程同时执行 size++ ，可能取得size值都是同一个(比如size为10，线程1将把size赋值为11，在线程1未完成赋值时线程二也在执行，此时获取到的size值还是10，最后执行了两次size++，实际上只有效一次size++)，会导致 size 值与实际插入的元素数量不一致。 如何将ArrayList变成线程安全的？ArrayList 是 Java 中常用的动态数组实现，但它并非线程安全。这意味着在多线程环境下，多个线程同时访问和修改 ArrayList 可能会导致数据不一致或其他并发问题。 使用 Collections.synchronizedList() 底层实现： Collections.synchronizedList() 方法会返回一个包装了原始 ArrayList 的同步视图。其底层实现原理是为每个方法调用添加一个同步块（synchronized block），确保同一时刻只有一个线程可以访问该列表。 使用 CopyOnWriteArrayList 底层实现： CopyOnWriteArrayList 是 java.util.concurrent 包中的一个线程安全列表实现。其核心思想是**写时复制 (Copy-On-Write)**：当列表发生修改时，会创建一个列表的副本，并在副本上进行修改，而原始列表保持不变。 手动同步 底层实现： 手动同步需要开发者显式地使用 synchronized 关键字来控制对 ArrayList 的访问。 ArrayList 的扩容机制当向 ArrayList 中新增元素时，如果下一个索引位置超出了当前数组的容量，则会触发扩容机制。扩容机制的具体步骤如下： 扩容步骤 计算新的容量：一般情况下，新的容量为原来容量的 1.5 倍。 计算公式：newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) 创建新的数组：根据计算出的新容量，创建一个新的数组。 复制原有数组元素：将原有数组中的元素逐个复制到新的数组中。 更新引用：将 ArrayList 内部的数组引用更新为新的数组。 完成扩容：扩容完成后，可以继续插入新的元素。 代码示例 以下是 ArrayList 扩容机制的部分源码： 关键点 扩容因子： 通常为 1.5 倍，但具体实现可能会根据需求调整。 数组复制： 使用 Arrays.copyOf() 方法进行数组复制，效率较高。 内存开销： 扩容会导致内存占用增加，因此在初始化 ArrayList 时，合理设置初始容量可以减少扩容次数，提高性能。 线程安全的 List 如何实现线程安全的？以 CopyOnWriteArrayList 为例，其底层也是使用数组保存数据。CopyOnWriteArrayList 通过以下方式实现线程安全： 1. 使用 volatile 关键字修饰数组CopyOnWriteArrayList 使用 volatile 关键字修饰数组，确保线程对数组对象重新赋值后，其他线程可以感知到。 2. 写时复制 (Copy-On-Write) 机制CopyOnWriteArrayList 的核心思想是**写时复制 (Copy-On-Write)**：当列表发生修改时，会创建一个列表的副本，并在副本上进行修改，而原始列表保持不变。 关键方法： add 方法： setArray 方法： 3. 读操作无需加锁由于写操作是在副本上进行的，读操作可以直接访问原始数组，无需加锁，从而提高了读操作的性能。 4. 使用 ReentrantLock 保证写操作的线程安全在写操作（如 add、remove 等）时，CopyOnWriteArrayList 使用 ReentrantLock 保证同一时刻只有一个线程可以进行写操作，从而确保线程安全。 总结 CopyOnWriteArrayList 通过以下方式实现线程安全： 使用 volatile 关键字修饰数组，确保线程对数组对象重新赋值后，其他线程可以感知到。 采用写时复制 (Copy-On-Write) 机制，写操作在副本上进行，读操作无需加锁。 使用 ReentrantLock 保证写操作的线程安全。 这种设计使得 CopyOnWriteArrayList 在读多写少的场景下具有较高的性能，但在写操作频繁的场景下，由于需要频繁复制数组，性能会受到影响。 "},{"title":"Java集合（概念篇）","date":"2024-09-09T05:14:00.000Z","url":"/2024/09/09/Java%E9%9B%86%E5%90%88%EF%BC%88%E6%A6%82%E5%BF%B5%E7%AF%87%EF%BC%89/","categories":[["Java","/categories/Java/"],["集合","/categories/Java/%E9%9B%86%E5%90%88/"]],"content":"主要收集了集合的一些简单概念。 什么是集合？在计算机科学中，集合（Collection）是一种用于存储和操作一组对象的数据结构。集合框架提供了一系列接口和类，用于处理不同类型的集合。Java的集合框架（Java Collections Framework, JCF）是Java标准库的一部分，提供了丰富的集合类型，以满足不同的编程需求。 集合的分类1. List：List是一种有序集合，允许存储重复元素。List接口提供了精确控制每个元素插入位置的能力，并且可以通过索引访问指定元素。 实现类： ArrayList：基于动态数组实现，支持高效的随机访问，但在插入和删除元素时可能需要移动大量元素。 Vector：类似于ArrayList，但线程安全，适用于多线程环境。 Stack：继承自Vector，实现后进先出（LIFO）的数据结构。 2.Set：Set是一种不允许存储重复元素的集合，每个元素都是唯一的。Set接口不保证元素的顺序。 实现类： HashSet：基于哈希表实现，提供了平均时间复杂度为O(1)的插入、删除和查找操作。 TreeSet：基于红黑树实现，元素按自然顺序或自定义顺序排序。 LinkedHashSet：结合了HashSet和LinkedList的特性，既保证了元素的唯一性，又维护了插入顺序。 3. Map：Map是一种键值对（Key-Value）的集合，存储键和值之间的映射关系。Map中的键是无序且唯一的，而值则可以重复。Map接口没有继承Collection接口，但它是集合框架的一部分。 实现类： HashMap：基于哈希表实现，提供了平均时间复杂度为O(1)的插入、删除和查找操作。 TreeMap：基于红黑树实现，键按自然顺序或自定义顺序排序。 Hashtable：类似于HashMap，但线程安全，适用于多线程环境。 特点 动态大小：集合的大小是动态的，可以根据需要添加或删除元素，而数组的大小是固定的。 类型安全：集合通常只能存储对象，而不能直接存储基本数据类型。然而，Java提供了自动装箱（Autoboxing）机制，使得基本数据类型可以自动转换为对应的包装类，从而存储在集合中。 丰富的操作：集合框架提供了丰富的操作方法，如添加、删除、查找、排序等，使得开发者可以方便地对集合进行操作。 集合是Java中用于存储和操作一组对象的重要数据结构。通过使用集合框架，开发者可以灵活地处理不同类型的数据，提高代码的效率和可维护性。理解不同集合类型的特点和适用场景，有助于在实际编程中做出更合理的选择。 数组与集合的对比分析概述在计算机科学中，数组（Array）和集合（Collection）是两种常见的数据结构，它们在存储和操作数据方面有着显著的区别。理解这些区别对于编写高效、可维护的代码至关重要。 主要区别 长度特性：数组的长度在初始化时是固定的，无法动态调整。这意味着一旦数组被创建，其大小就无法改变。集合的长度是动态的，可以根据需要添加或删除元素。集合的实现通常基于动态数据结构，如链表或动态数组，允许在运行时调整大小。 数据类型：数组可以存储基本数据类型（如int、char、float等）以及对象（如String、Object等）。数组中的所有元素必须是相同的数据类型。集合通常只能存储对象，而不能直接存储基本数据类型。然而，Java等语言提供了自动装箱（Autoboxing）机制，使得基本数据类型可以自动转换为对应的包装类（如Integer、Character等），从而存储在集合中。 访问机制：数组中的元素通过索引直接访问，时间复杂度为O(1)。这意味着访问数组中的任意元素都非常高效。集合中的元素通常需要通过迭代器（Iterator）或其他访问方法来获取。访问集合中的元素的时间复杂度可能因集合的实现方式而异，通常为O(n)或O(log n)。 常见集合类型 ArrayList：基于动态数组实现的集合，支持随机访问，但在插入和删除元素时可能需要移动大量元素，导致性能下降。适用于需要频繁随机访问元素的场景。 Map：键值对（Key-Value）的集合，每个键唯一对应一个值。常见的实现包括HashMap和TreeMap。适用于需要通过键快速查找值的场景。 HashMap：基于哈希表实现的Map，提供了平均时间复杂度为O(1)的插入、删除和查找操作。适用于需要高效查找和插入操作的场景。 TreeMap：基于红黑树（Red-Black Tree）实现的Map，元素按自然顺序或自定义顺序排序。适用于需要有序访问键值对的场景。 PriorityQueue：基于堆（Heap）实现的优先队列，元素按优先级排序，支持高效的插入和删除操作。适用于需要按优先级处理元素的场景，如任务调度、事件处理等。 总结 数组和集合各有优缺点，选择合适的数据结构取决于具体的应用场景和需求。数组适用于需要固定大小且高效随机访问的场景，而集合则适用于需要动态调整大小和灵活操作的场景。理解这些区别有助于开发者在实际编程中做出更合理的选择，从而提高代码的性能和可维护性。 Java中线程安全的集合在多线程编程中，确保数据的一致性和线程安全是至关重要的。Java的java.util包中只有少数几个类是线程安全的，而大多数集合类是非线程安全的。为了满足高并发环境下的需求，Java提供了java.util.concurrent包，其中包含多种线程安全的集合类。 java.util包中的线程安全集合1. VectorVector是一个线程安全的动态数组，实现了List接口。Vector的所有方法都是同步的，因此适用于多线程环境。 线程安全：所有方法都使用synchronized关键字进行同步。 性能较低：由于同步机制，Vector的性能通常低于非线程安全的ArrayList。 2. HashtableHashtable是一个线程安全的哈希表，实现了Map接口。Hashtable的所有方法都是同步的，因此适用于多线程环境。 线程安全：所有方法都使用synchronized关键字进行同步。 性能较低：由于同步机制，Hashtable的性能通常低于非线程安全的HashMap。 java.util.concurrent包中的线程安全集合1. 并发Set并发Set是一种线程安全的集合，不允许存储重复元素。 ConcurrentSkipListSet：基于跳表（Skip List）实现的有序集合，适用于高并发环境下的插入、删除和查找操作。 CopyOnWriteArraySet：基于CopyOnWriteArrayList实现，适用于读多写少的场景，写操作会创建一个新的副本，读操作则直接访问当前副本。 2. 并发Map并发Map是一种线程安全的键值对集合，存储键和值之间的映射关系。 ConcurrentHashMap：它与HashTable的区别在于二者加锁的粒度不同。ConcurrentHashMap基于分段锁（Segmented Locking）实现的哈希表，提供了高效的并发访问能力，适用于高并发环境下的插入、删除和查找操作。 ConcurrentSkipListMap：基于跳表实现的有序映射，适用于高并发环境下的插入、删除和查找操作。 3. 并发Queue并发Queue是一种线程安全的队列，支持先进先出（FIFO）的数据结构。 ConcurrentLinkedQueue：基于链表实现的无界队列，适用于高并发环境下的插入和删除操作。 ArrayBlockingQueue：基于数组实现的有界阻塞队列，适用于生产者-消费者模型。 LinkedBlockingQueue：基于链表实现的有界阻塞队列，适用于生产者-消费者模型。 PriorityBlockingQueue：基于堆实现的无界阻塞队列，元素按优先级排序。 4. 并发List并发List是一种线程安全的列表，允许存储重复元素。 CopyOnWriteArrayList：基于CopyOnWrite机制实现，适用于读多写少的场景，写操作会创建一个新的副本，读操作则直接访问当前副本。 5. 并发Dequeue并发Dequeue是一种线程安全的双端队列，支持在队列的两端进行插入和删除操作。 ConcurrentLinkedDeque：基于链表实现的无界双端队列，适用于高并发环境下的插入和删除操作。 LinkedBlockingDeque：基于链表实现的有界阻塞双端队列，适用于生产者-消费者模型。 总结Java的java.util.concurrent包提供了多种线程安全的集合类，适用于不同的并发场景。这些集合类通过各种并发控制机制（如分段锁、跳表、CopyOnWrite机制等）确保了在多线程环境下的数据一致性和线程安全。理解这些集合类的特点和适用场景，有助于开发者在实际编程中选择合适的并发集合，从而提高系统的并发性能和可靠性。 Collection与Collections在Java集合框架中，Collections和Collection是两个关键的概念，它们在集合操作中扮演着不同的角色。理解它们的区别和联系对于掌握Java集合框架至关重要。 Collection接口Collection是Java集合框架中的一个基础接口，位于java.util包中。它是所有集合类的基础接口，定义了一系列通用的集合操作方法。 主要功能： 遍历：Collection接口提供了iterator()方法，用于遍历集合中的元素。 插入：Collection接口提供了add()和addAll()方法，用于向集合中插入元素。 删除：Collection接口提供了remove()和removeAll()方法，用于从集合中删除元素。 查询：Collection接口提供了contains()和containsAll()方法，用于查询集合中是否包含指定元素。 大小：Collection接口提供了size()方法，用于获取集合的大小。 Collection接口有许多实现类，如ArrayList、LinkedList、HashSet、TreeSet等，它们分别实现了不同的集合类型和特性。 Collections工具类Collections是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行各种操作，如排序、查找、替换、反转等。 主要功能： 排序：Collections.sort()方法可以对实现了List接口的集合进行排序。 查找：Collections.binarySearch()方法可以在有序集合中进行二分查找。 替换：Collections.replaceAll()方法可以替换集合中的所有指定元素。 反转：Collections.reverse()方法可以反转集合中元素的顺序。 同步：Collections.synchronizedCollection()方法可以将集合包装为线程安全的集合。 不可变集合：Collections.unmodifiableCollection()方法可以创建一个不可变的集合视图。 Collections工具类的方法可以对实现了Collection接口的类进行操作，如List和Set。 区别与联系区别 类型：Collections是一个工具类，而Collection是一个接口。 功能：Collections提供了一系列静态方法，用于对集合进行各种操作；而Collection定义了集合的基本操作方法。 使用方式：Collections的方法通常通过类名直接调用，如Collections.sort(list)；而Collection的方法需要通过集合对象调用，如list.add(element)。 联系 依赖关系：Collections工具类的方法通常作用于实现了Collection接口的集合对象。 共同目标：Collections和Collection都是为了方便开发者对集合进行操作和管理，提高代码的效率和可维护性。 集合遍历在Java中，集合遍历是常见的操作之一。不同的遍历方式适用于不同的场景，选择合适的遍历方式可以提高代码的可读性和性能。以下是几种常见的集合遍历方式及其示例代码片段。 1. 使用foreach循环foreach循环是Java中最简单和常用的遍历方式之一。它适用于遍历任何实现了Iterable接口的集合。 2. 使用Iterator迭代器Iterator是一种传统的遍历方式，适用于需要在遍历过程中修改集合的情况。 3. 使用Stream API（Java 8+）Stream API是Java 8引入的一种函数式编程风格，适用于对集合进行复杂的操作和转换。 "},{"title":"What is Java ?（四）","date":"2024-07-24T05:14:00.000Z","url":"/2024/07/24/What-is-Java-%EF%BC%88%E5%9B%9B%EF%BC%89/","tags":[["序列化","/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"],["I/O","/tags/I-O/"],["其他","/tags/%E5%85%B6%E4%BB%96/"]],"categories":[["Java","/categories/Java/"],["基础","/categories/Java/%E5%9F%BA%E7%A1%80/"]],"content":"内容：序列化、I/O、其他 本篇博客是笔者作为初学者记录自己对Java一些基本概念的理解。内容参考了大量网络资源，篇幅很长，旨在作为个人学习笔记，供自己日后回顾和复习。 序列化怎么把一个对象从一个JVM转移到另一个JVM？ 使用序列化和反序列化：将对象序列化为字节流（objectoutputstream），发送到另一个JVM中再进行字节流反序列化（objectinputstream）。 使用消息传递机制：可以使用消息队列等方式，通过网络传输对象。常见的消息队列系统包括 RabbitMQ、Kafka 等。 远程调用（RPC）：使用远程调用框架（如 RMI、gRPC、Dubbo 等）进行跨 JVM 的对象调用。 使用数据共享：使用数据共享，如将对象所需的数据存入数据库或共享缓存中，能够让其他JVM访问得到。 序列化和反序列化有没有更好的设计？Java默认的序列化虽然方便，但也存在一些问题： 无法跨语言：Java序列化格式是Java特有的，它依赖于Java的内部数据结构和类型系统。因此，生成的序列化数据无法直接被其他编程语言（如Python、C++、JavaScript等）解析和使用。这意味着如果你需要在不同的编程语言之间共享数据，Java序列化机制就无法满足需求。为了实现跨语言的互操作性，通常需要使用更通用的序列化格式，如JSON、XML、Protocol Buffers、Avro等。 容易被攻击：Java序列化机制存在安全漏洞，尤其是在反序列化过程中。攻击者可以通过构造恶意的序列化数据，在反序列化时执行任意代码，从而导致安全问题。这种攻击被称为“反序列化漏洞”或“反序列化攻击”。为了防止这种攻击，开发者需要非常小心地处理反序列化过程，或者使用更安全的序列化机制，如JSON、Protocol Buffers等，这些机制通常不会引入类似的安全风险。 性能差：Java序列化机制在性能方面表现不佳，尤其是在处理大量数据时。主要原因包括： 序列化后的数据体积较大：Java序列化生成的数据通常比其他序列化格式（如Protocol Buffers）更大，这会导致更高的网络传输成本和存储成本。 序列化和反序列化过程较慢：Java序列化机制在处理复杂对象时，性能开销较大。尤其是在需要频繁进行序列化和反序列化操作的场景中，性能问题会更加明显。 更好的设计 为了解决上述问题，可以使用以下几种替代方案： 1. JSON 序列化JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，同时也易于解析和生成。许多编程语言都支持JSON序列化，因此可以实现跨语言的数据交换。 示例代码（使用 Jackson 库） 2. Protocol BuffersProtocol Buffers（ProtoBuf）是Google开发的一种轻量级、高效的序列化格式，支持多种编程语言，并且具有更好的性能和安全性。 示例代码（使用 Protocol Buffers） 首先，定义一个 .proto 文件： 然后，生成Java类并使用： 3. ThriftApache Thrift 是另一种高效的序列化框架，支持多种编程语言，并且具有良好的性能和扩展性。 示例代码（使用 Thrift） 首先，定义一个 .thrift 文件： 然后，生成Java类并使用： 为了解决Java默认序列化机制存在的问题，可以使用JSON、Protocol Buffers和Thrift等替代方案。这些方案具有更好的跨语言支持、更高的安全性和更好的性能，适用于不同的应用场景。 I&#x2F;OBIO、NIO、AIO：Java I&#x2F;O模型的演进在Java编程中，I&#x2F;O操作是不可或缺的一部分。随着技术的发展，Java提供了多种I&#x2F;O模型，以满足不同场景下的需求。本文将简要介绍三种主要的I&#x2F;O模型：BIO（Blocking I&#x2F;O）、NIO（Non-blocking I&#x2F;O）和AIO（Asynchronous I&#x2F;O）。 1. BIO（Blocking I&#x2F;O）BIO是Java传统的I&#x2F;O模型，基于java.io包实现。它通过字节流（Byte Stream）和字符流（Character Stream）来处理数据。BIO的核心特点是同步阻塞，即在进行I&#x2F;O操作时，线程会被阻塞，直到操作完成。这种模型的执行顺序是线性的，代码编写简单直观，但处理效率较低，扩展性有限。 优缺点： 代码简单，易于理解和维护；适用于简单的I&#x2F;O操作场景。 处理效率低，尤其是在高并发环境下，线程阻塞会导致资源浪费；扩展性差，难以应对大规模并发请求。 2. NIO（Non-blocking I&#x2F;O）NIO是Java 1.4引入的一种新型I&#x2F;O模型，旨在解决BIO在高并发环境下的性能瓶颈。NIO的核心思想是同步非阻塞，通过以下三大组件实现： 通道（Channel）：类似于流，但支持双向数据传输。 缓冲区（Buffer）：用于存储数据的容器，支持直接内存操作，提高数据处理效率。 多路复用器（Selector）：用于管理多个通道，实现非阻塞I&#x2F;O操作。 NIO通过Selector机制，允许单个线程管理多个通道，从而避免了线程阻塞，提高了系统的并发处理能力。 优缺点： 非阻塞I&#x2F;O操作，提高了系统的并发处理能力；适用于高并发、低延迟的网络应用。 代码复杂度增加，需要理解Channel、Buffer和Selector等概念；调试和维护相对困难。 3. AIO（Asynchronous I&#x2F;O）AIO是NIO的进一步演进，提供了异步非阻塞的I&#x2F;O操作方式。在AIO模型中，当发起I&#x2F;O操作后，线程不会被阻塞，而是继续执行其他任务，I&#x2F;O操作由后台线程处理完成后，通过回调机制通知主线程。 AIO的核心组件包括： 异步通道（Asynchronous Channel）：支持异步I&#x2F;O操作的通道。 CompletionHandler：用于处理I&#x2F;O操作完成后的回调。 优缺点： 异步非阻塞，进一步提高了系统的并发处理能力；适用于需要高并发、高吞吐量的应用场景。 实现复杂，需要处理回调和异步编程的复杂性；对开发者的技术要求较高。 总结 BIO、NIO和AIO代表了Java I&#x2F;O模型的不同阶段，各自适用于不同的应用场景。BIO简单易用，但处理效率低；NIO通过非阻塞机制提高了并发处理能力，但增加了代码复杂度；AIO则进一步通过异步机制提升了系统的吞吐量，但实现难度较大。选择合适的I&#x2F;O模型，需要根据具体的应用需求和技术栈来决定。 NIO原理详解NIO（Non-blocking I&#x2F;O）是Java 1.4引入的一种新型I&#x2F;O模型，旨在提高I&#x2F;O操作的效率和系统的并发处理能力。NIO的核心思想是同步非阻塞，通过以下三大组件实现： 1. 核心组件 Selector（选择器&#x2F;多路复用器）：Selector是NIO同步机制的核心。它负责轮询多个Channel，检查它们是否准备好进行I&#x2F;O操作（如读、写等）。Selector的引入避免了线程在等待I&#x2F;O操作时的阻塞，从而提高了系统的并发处理能力。 Channel（通道）：Channel类似于传统的流（Stream），但支持双向数据传输。与流不同的是，Channel可以直接与Buffer进行数据交换，无需线程等待。常见的Channel类型包括FileChannel、SocketChannel和ServerSocketChannel。 Buffer（缓冲区）：Buffer是用于存储数据的容器，支持直接内存操作，提高了数据处理的效率。Buffer有多种类型，如ByteBuffer、CharBuffer等，分别用于处理不同类型的数据。 2. 工作原理NIO的工作原理可以概括为以下几个步骤： 注册Channel到Selector：首先，将需要监听的Channel注册到Selector上，并指定感兴趣的事件（如连接、读、写等）。 Selector轮询：Selector会定期轮询所有注册的Channel，检查它们是否准备好进行I&#x2F;O操作。如果某个Channel准备好，Selector会返回一个SelectionKey，表示该Channel可以进行相应的I&#x2F;O操作。 处理I&#x2F;O操作：当Selector检测到某个Channel准备好进行I&#x2F;O操作时，应用程序可以通过SelectionKey获取对应的Channel，并进行读写操作。数据在Channel和Buffer之间进行传输，无需线程等待。 非阻塞机制：由于Selector的轮询机制，线程在等待I&#x2F;O操作时不会被阻塞，可以继续处理其他任务。这种非阻塞机制大大提高了系统的并发处理能力。 3. 事件驱动机制NIO采用了事件驱动机制，当某个I&#x2F;O事件（如连接、读、写等）发生时，Selector会立即触发相应的事件处理逻辑，无需线程不断监视。这种机制减少了线程的空闲等待时间，提高了系统的响应速度。 4. 线程通信在NIO中，线程间通过notify和wait机制进行通信，减少了线程切换的开销。当某个I&#x2F;O操作完成时，线程可以通过notify通知其他线程继续处理，避免了不必要的线程切换。 总结 NIO通过Selector、Channel和Buffer三大组件，实现了同步非阻塞的I&#x2F;O操作。Selector负责轮询Channel，避免了线程在等待I&#x2F;O操作时的阻塞；Channel和Buffer支持高效的数据传输，无需线程等待。NIO的事件驱动机制和线程通信优化，进一步提高了系统的并发处理能力和响应速度。NIO适用于高并发、低延迟的网络应用场景，但需要开发者理解其复杂的工作原理和组件间的协作关系。 其他代理模式和适配器模式有什么区别？代理模式（Proxy Pattern）和适配器模式（Adapter Pattern）是两种常见的设计模式，它们在软件设计中有着不同的用途和实现方式。以下是它们的主要区别： 1. 定义和目的代理模式 定义：代理模式为其他对象提供一个代理或占位符，以控制对这个对象的访问。 目的：主要用于控制对对象的访问，可以在不改变原始对象的情况下，增加额外的功能（如权限控制、延迟初始化、日志记录等）。 适配器模式 定义：适配器模式将一个类的接口转换成客户端所期望的另一个接口。 目的：主要用于解决接口不兼容的问题，使得原本由于接口不匹配而无法一起工作的类可以协同工作。 2. 结构和实现代理模式 结构：代理模式通常包含一个代理类和一个真实主题类。代理类和真实主题类实现相同的接口，代理类内部持有真实主题类的引用。 实现：代理类在调用真实主题类的方法前后，可以执行额外的操作（如权限检查、日志记录等）。 适配器模式 结构：适配器模式通常包含一个适配器类、一个目标接口和一个被适配者类。适配器类实现目标接口，并在内部持有被适配者类的引用。 实现：适配器类将目标接口的方法调用转换为被适配者类的方法调用。 3. 使用场景代理模式 场景：当需要控制对某个对象的访问时，可以使用代理模式。例如： 远程代理：控制对远程对象的访问。 虚拟代理：延迟加载对象，直到真正需要时才创建。 保护代理：控制对敏感对象的访问权限。 日志代理：在方法调用前后记录日志。 适配器模式 场景：当需要将一个类的接口转换为另一个接口，以便与现有代码兼容时，可以使用适配器模式。例如： 旧系统与新系统的接口不兼容。 第三方库的接口与现有代码不匹配。 需要复用已有的类，但其接口不符合需求。 总结 代理模式：主要用于控制对对象的访问，可以在不改变原始对象的情况下，增加额外的功能。 适配器模式：主要用于解决接口不兼容的问题，使得原本由于接口不匹配而无法一起工作的类可以协同工作。 集合多属性排序假如有一个学生数组，想要按照成绩降序、学号升序排序，如何实现？ 在Java中，可以使用Comparator接口来实现集合的多属性排序。以下是一个示例，展示了如何对学生数组按照成绩降序、学号升序进行排序。 示例代码 代码说明 Student类：定义了一个学生类，包含学号（id）、姓名（name）和成绩（score）三个属性。 Main类：包含主方法，用于创建学生数组并进行排序。 排序逻辑： 使用Arrays.sort方法对学生数组进行排序。 通过Comparator接口实现多属性排序： 首先按成绩降序排序（Double.compare(s2.getScore(), s1.getScore())）。 如果成绩相同，按学号升序排序（Integer.compare(s1.getId(), s2.getId())）。 输出结果：排序后的学生数组将按照成绩降序、学号升序的顺序输出。 输出示例 tips 理解Comparator接口的用法，特别是与Collections.sort()方法结合使用时，关键在于理解compare方法的返回值如何影响排序结果。 Comparator接口的compare方法 Comparator接口的compare方法定义如下： 这个方法的返回值决定了o1和o2的相对顺序： 如果返回负值，表示o1应该排在o2之前（即o1小于o2）。 如果返回0，表示o1和o2相等，顺序不变。 如果返回正值，表示o1应该排在o2之后（即o1大于o2）。 升序和降序的实现 为了实现升序或降序排序，你需要根据compare方法的返回值来调整对象的相对顺序。 升序排序 升序排序意味着较小的元素应该排在前面。因此，如果o1小于o2，compare方法应该返回负值。 降序排序 降序排序意味着较大的元素应该排在前面。因此，如果o1小于o2，compare方法应该返回正值。 native方法native方法是Java中的一种特殊方法，它使用native关键字进行声明，表示该方法的实现是由非Java代码（通常是C&#x2F;C++代码）提供的。native方法允许Java程序调用底层操作系统或其他语言编写的库，从而实现Java与本地代码的交互。 volatile 和 synchronized 的区别volatile 和 synchronized 是 Java 中用于处理并发问题的关键字，但它们的作用和使用场景有所不同。 1. volatile作用： 保证可见性： 当一个线程修改了 volatile 变量的值时，其他线程能够立即看到这个修改。 禁止指令重排序： volatile 变量的读写操作不会被 JVM 优化重排序，从而保证有序性。 适用场景： 单个变量的读写： volatile 适用于单个变量的读写操作，特别是当这个变量被多个线程共享时。 状态标志： 例如，用于控制线程是否继续运行的标志变量。 代码示例： 2. synchronized作用： 互斥访问： synchronized 关键字用于实现互斥访问，确保同一时刻只有一个线程可以执行被 synchronized 修饰的代码块或方法。 保证可见性： 进入 synchronized 代码块或方法时，会清空工作内存中的变量副本，从主内存中重新加载；退出时，会将工作内存中的变量值刷新到主内存。 适用场景： 多个变量的读写： synchronized 适用于多个变量的读写操作，特别是当这些变量需要保持一致性时。 复杂的同步逻辑： 例如，需要对多个操作进行同步的场景。 代码示例： 区别总结 特性 volatile synchronized 作用 保证可见性、禁止指令重排序 互斥访问、保证可见性 适用场景 单个变量的读写、状态标志 多个变量的读写、复杂的同步逻辑 性能 相对较高，因为不需要加锁 相对较低，因为需要加锁 使用范围 仅限于变量 可以用于方法、代码块 原子性 不能保证复合操作的原子性 可以保证复合操作的原子性 "},{"title":"What is Java ?（三）","date":"2024-07-23T05:14:00.000Z","url":"/2024/07/23/Java-is-What-%EF%BC%88%E4%B8%89%EF%BC%89/","tags":[["注解","/tags/%E6%B3%A8%E8%A7%A3/"],["异常","/tags/%E5%BC%82%E5%B8%B8/"],["Object","/tags/Object/"],["Java8新特性","/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"]],"categories":[["Java","/categories/Java/"],["基础","/categories/Java/%E5%9F%BA%E7%A1%80/"]],"content":"内容：注解、异常、Object、Java8新特性 本篇博客是笔者作为初学者记录自己对Java一些基本概念的理解。内容参考了大量网络资源，篇幅很长，旨在作为个人学习笔记，供自己日后回顾和复习。 注解在Java中，注解（Annotation）是一种元数据（metadata），它提供了关于程序代码的额外信息，但本身并不直接影响程序的执行。注解可以用于类、方法、字段、参数、局部变量等程序元素上，用于在编译时、运行时或部署时提供额外的信息。 注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationlnvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 注解的原理 定义注解：注解是通过@interface关键字定义的。例如： 这个注解MyAnnotation有两个元素：value和count。value是必需的，而count有一个默认值1。 元注解：元注解是用于注解其他注解的注解。Java提供了几个内置的元注解，用于控制注解的行为： @Retention：指定注解的保留策略，即注解在什么阶段有效（源码、编译时、运行时）。 RetentionPolicy.SOURCE：注解仅在源码中保留，编译时丢弃。 RetentionPolicy.CLASS：注解在编译时保留，但运行时不可见。 RetentionPolicy.RUNTIME：注解在运行时保留，可以通过反射获取。 @Target：指定注解可以应用的目标类型（类、方法、字段等）。 ElementType.TYPE：类、接口、枚举。 ElementType.METHOD：方法。 ElementType.FIELD：字段。 ElementType.PARAMETER：方法参数。 ElementType.CONSTRUCTOR：构造函数。 ElementType.LOCAL_VARIABLE：局部变量。 ElementType.ANNOTATION_TYPE：注解类型。 ElementType.PACKAGE：包。 @Documented：指定注解是否包含在JavaDoc中。 @Inherited：指定注解是否可以被子类继承。 @Repeatable：指定注解是否可以重复应用在同一个元素上。 使用注解：注解可以应用在类、方法、字段等程序元素上。例如： 处理注解：注解本身并不做任何事情，它们需要通过某种方式被处理才能发挥作用。处理注解的方式主要有两种： 编译时处理：使用注解处理器（Annotation Processor）在编译时处理注解。例如，Lombok库使用注解处理器在编译时生成代码。 运行时处理：使用反射（Reflection）在运行时获取注解信息。例如： 这个方法通过反射检查类上是否存在MyAnnotation注解，并获取注解的值。 总结 注解的原理可以概括为以下几点： 定义注解：使用@interface关键字定义注解，并指定注解的元素。 元注解：使用元注解控制注解的行为，如保留策略、目标类型等。 使用注解：将注解应用在程序元素上。 处理注解：通过编译时处理或运行时反射来处理注解，使其发挥作用。 应用作用域在Java中，注解可以应用于多种程序元素，包括类、方法、字段（属性）、参数、局部变量等。注解的作用域（即注解可以应用的目标类型）由@Target元注解指定。以下是一些常见的注解作用域及其对应的ElementType枚举值： 1. 类注解可以应用于类、接口、枚举等类型定义上。对应的ElementType是TYPE。 使用示例： 2. 方法注解可以应用于方法定义上。对应的ElementType是METHOD。 使用示例： 3. 属性（字段）注解可以应用于字段（属性）定义上。对应的ElementType是FIELD。 使用示例： 其他作用域除了上述常见的类、方法和字段，注解还可以应用于其他程序元素： 参数：注解可以应用于方法参数上。对应的ElementType是PARAMETER。 使用示例： 构造函数：注解可以应用于构造函数上。对应的ElementType是CONSTRUCTOR。 使用示例： 局部变量：注解可以应用于局部变量上。对应的ElementType是LOCAL_VARIABLE。 使用示例： 注解类型：注解可以应用于其他注解类型上。对应的ElementType是ANNOTATION_TYPE。 使用示例： 包：注解可以应用于包声明上。对应的ElementType是PACKAGE。 使用示例： 异常啥是异常？Java异常主要基于两大类：Throwable类及其子类。Throwable的子类主要有两个重要的子类：Error和Exception，它们分别代表了不同类型的异常情况。 ErrorError表示运行环境错误，极难恢复，不能指望程序自己处理这些异常。比如系统崩溃、连接错误等。比如OutOfMemoryError内存不足错误、StackOverflowError栈溢出错误。通常程序不应该去捕获这些错误，因为它们表示系统级别的严重问题，程序无法自行恢复。 ExceptionException表示运行程序错误，根据发生时期又可以分为编译时异常和运行时异常。 编译时异常（Checked Exception）在代码编译时出现的异常，必须显式处理（捕获或声明抛出）。这些异常通常是程序外部的异常，比如文件不存在、无法找到类等。对于这些异常必须使用try-catch块捕获异常，或者在方法签名中使用throws关键字声明抛出异常。 运行时异常（Unchecked Exception）程序运行过程中出现的异常，通常由程序逻辑错误引起，不需要显式处理。 常见异常： NullPointerException：空指针异常。 IllegalArgumentException：非法参数异常。 ClassCastException：类转换异常。 IndexOutOfBoundsException：数组越界异常。 虽然运行时异常不需要显式处理，但建议在代码中进行适当的检查和处理，以提高程序的健壮性。 异常处理机制Java提供了异常处理机制，通过try-catch语句块来捕获和处理异常。以下是Java常见的异常处理方式： try块：包含可能抛出异常的代码。 catch块：捕获并处理异常。 throw语句：用于手动抛出异常。 finally块：无论是否发生异常，都会执行的代码块，通常用于资源清理。 示例代码 以下是一个完整的异常处理示例，展示了如何使用try-catch语句块、throw语句和finally块： 抛出异常为什么不用throws？如果说异常是未检查异常（Unchecked Exception）或已经在方法内部处理，就不需要再使用throws声明了。 Unchecked Exception：未检查异常，是继承自RuntimeException类或者Error类的异常，编译器不强制要求进行异常处理。因此对于这些异常，不需要在方法签名中使用throws来声明。 捕获和异常处理：另一种常见情况是已经在方法内部捕获了可能抛出的异常并在方法内部处理它们。 try-catch的执行顺序正常情况下会按顺序执行try块中的代码，当运行过程中出现异常则跳转到相应的catch异常捕获块，最后无论是否出现异常，总会执行finally块。 常见问题 以下这段代码最后会返回什么？ 答案是返回&#39;b&#39;。因为try的return语句先执行，压入返回栈中，而finally中的return方法后执行，也压入栈中，返回结果先弹出栈上方的元素，所以会返回&#39;b&#39;，也就是说finally中的return会覆盖try块的返回语句。 示例代码 以下是一个示例，展示了try-catch-finally块的执行顺序： 输出结果： 在这个示例中，try块中的return &#39;a&#39;语句先执行，但被finally块中的return &#39;b&#39;语句覆盖，因此最终返回值为&#39;b&#39;。 Object“&#x3D;&#x3D;”与“equals”有什么区别？对于字符串变量，==与equals方法是不同的。==判断的是两个对象的引用是否相同，即比较两个对象的内存首地址是否指向同一个对象，而equals则判断的是两个对象的值是否相同。 示例代码片段，对于字符串来说： 对于非字符串来说，若没有对equals方法重写，则==和equals是相同的，都是比较两个对象的内存首地址是否相同，即比较两个对象的引用是否指向同一个变量。 示例代码片段，对于非字符串对象： “equals”与“hashCode”equals方法用于比较两个对象是否相等，而hashCode方法返回对象的哈希码值。在Java中，如果两个对象通过equals方法比较相等，那么它们的hashCode值必须相同。反之，如果两个对象的hashCode值相同，它们不一定相等。 示例代码片段 StringBuilder和StringBuffer由于String类型是不可变的（immutable），每次对String进行修改操作时，都会创建一个新的String对象，这可能会导致性能问题。为了解决这个问题，Java提供了StringBuilder和StringBuffer类，它们是可变的（mutable），允许在原有对象上进行修改操作。 区别 线程安全： StringBuffer是线程安全的，适用于多线程环境。 StringBuilder不是线程安全的，适用于单线程环境，性能更高。 性能： 通常情况下，StringBuilder的性能优于StringBuffer，因为StringBuffer需要维护线程安全，会带来额外的开销。 String的性能通常是最差的，因为每次修改都会创建新的对象。 使用场景： 在单线程环境中，推荐使用StringBuilder以获得最佳性能。 在多线程环境中，如果需要线程安全，使用StringBuffer。 示例代码片段 Java 1.8 新特性Stream APIJava 8 引入了 Stream API，提供了一种更加高效的数据处理方式，特别是对于集合的操作如过滤、排序、映射等。使用 Stream 能够充分利用多核处理器的优势进行并行处理。 示例 以下是一个简单的示例，展示了如何使用 Stream API 对集合进行操作： 解释 创建列表： 使用 Arrays.asList 创建一个包含整数的列表。 使用 Stream API： numbers.stream()：创建一个顺序流。 filter(n -&gt; n % 2 == 0)：过滤出偶数。 map(n -&gt; n * n)：将每个偶数计算平方。 collect(Collectors.toList())：将结果收集到一个列表中。 使用并行流： numbers.parallelStream()：创建一个并行流，充分利用多核处理器的优势。 输出 总结 Stream API 提供了一种简洁、高效的方式来处理集合数据，支持顺序和并行处理，能够显著提高数据处理的性能。通过合理使用 Stream API，可以简化代码并提高程序的可读性和可维护性。 Stream流的并行API即 ParallelStream。并行流其实带着“分而治之”的思想，在处理源数据时，将数据分成多个子流，然后将处理结果汇总为一个流对象。底层逻辑是使用 Fork&#x2F;Join 框架来实现并行处理。 对CPU密集型的任务来说，并行流使用ForkJoinPool线程池，为每个CPU分配一个任务，这是非常有效率的，但是如果任务不是CPU密集的，而是I&#x2F;O密集的，并且任务数相对线程数比较大，那么直接用Parallelstream并不是很好的选择。 CompletableFutureCompletableFuture 是 Java 8 引入的一个类，用于支持异步编程和非阻塞操作。它实现了 Future 接口，并提供了更强大的功能，如组合多个异步任务、处理异常、以及在任务完成时执行回调等。 主要功能 异步执行任务：使用 CompletableFuture.supplyAsync 或 CompletableFuture.runAsync 方法来异步执行任务。 任务组合：使用 thenApply、thenAccept、thenRun 等方法来组合多个异步任务。 异常处理：使用 exceptionally 方法来处理异常。 任务完成时的回调：使用 whenComplete 方法在任务完成时执行回调。 示例 以下是一个简单的示例，展示了如何使用 CompletableFuture 进行异步编程： 解释 异步执行任务：CompletableFuture.supplyAsync(() -&gt; &#123; ... &#125;)：异步执行一个返回值为 String 的任务。 任务完成时的回调：future.thenAccept(result -&gt; &#123; ... &#125;)：在任务完成时执行回调，输出结果。 异常处理：future.exceptionally(ex -&gt; &#123; ... &#125;)：处理任务执行过程中可能抛出的异常。 等待任务完成：future.get()：等待任务完成并获取结果。 输出 再来一个简单的组合示例： "},{"title":"What is Java ?（二）","date":"2024-07-20T05:14:00.000Z","url":"/2024/07/20/What-is-Java-%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["拷贝","/tags/%E6%8B%B7%E8%B4%9D/"],["泛型","/tags/%E6%B3%9B%E5%9E%8B/"],["对象","/tags/%E5%AF%B9%E8%B1%A1/"],["反射","/tags/%E5%8F%8D%E5%B0%84/"]],"categories":[["Java","/categories/Java/"],["基础","/categories/Java/%E5%9F%BA%E7%A1%80/"]],"content":"内容：拷贝、泛型、对象、反射 本篇博客是笔者作为初学者记录自己对Java一些基本概念的理解。内容参考了大量网络资源，篇幅很长，旨在作为个人学习笔记，供自己日后回顾和复习。 拷贝浅拷贝和深拷贝的区别浅拷贝（Shallow Copy）浅拷贝复制了一个对实例对象的引用，因此在内存中这两个对象指向的是同一个对象。换句话说，浅拷贝只复制了对象的引用，而不是对象本身。 示例代码 解释：original 和 copy 指向同一个对象，因此修改 copy 的值也会影响 original。 深拷贝（Deep Copy）深拷贝新建一个一模一样的实例对象，两个对象的引用指向的是不同的地址。换句话说，深拷贝复制了对象本身，而不是对象的引用。 示例代码 解释：original 和 copy 指向不同的对象，因此修改 copy 的值不会影响 original。 图示 实现深拷贝的方法常用的深拷贝方法有三种： 实现 Cloneable 接口的 clone 方法 使用序列化和反序列化 手写递归复制 1. 实现 Cloneable 接口的 clone 方法通过实现 Cloneable 接口并重写 clone 方法，可以实现深拷贝。需要注意的是，clone 方法默认是浅拷贝，因此需要手动处理对象的深拷贝。 示例代码 2. 使用序列化和反序列化通过将对象序列化为字节流，然后再反序列化为新的对象，可以实现深拷贝。这种方法适用于实现了 Serializable 接口的对象。 示例代码 3. 手写递归复制通过手写递归方法，逐层复制对象的每个字段，可以实现深拷贝。这种方法适用于任何对象，但需要手动处理每个字段的复制。 示例代码 总结 实现 Cloneable 接口的 clone 方法：适用于简单的对象，需要手动处理深拷贝。 使用序列化和反序列化：适用于实现了 Serializable 接口的对象，可以自动处理深拷贝。 手写递归复制：适用于任何对象，需要手动处理每个字段的复制。 泛型什么是泛型？泛型是 Java 语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，而这些参数在实际运行时才会指定具体的参数类型。泛型提供了一种在编译时进行类型检查的机制，从而提高代码的类型安全性和可读性。 为什么需要泛型？泛型的主要目的是提高代码的类型安全性和可读性，具体体现在以下几个方面： 适用于多种类型执行相同的代码： 泛型允许在定义类、接口和方法时使用类型参数，从而可以在不同的类型上执行相同的代码。 类型安全： 泛型在编译时进行类型检查，确保类型的一致性，避免运行时类型转换错误。 使用泛型可以减少强制类型转换的需求，提高代码的可读性和安全性。 示例代码 总结 泛型：允许在定义类、接口和方法时使用类型参数，提高代码的类型安全性和可读性。 类型安全：泛型在编译时进行类型检查，避免运行时类型转换错误。 减少强制类型转换：使用泛型可以减少强制类型转换的需求，提高代码的可读性和安全性。 通过这些特性，泛型在 Java 编程中提供了更强大的类型检查和代码复用能力，使得代码更加健壮和易于维护。 对象创建对象的方式 使用new关键字： 这是最常见和最直接的对象创建方式。通过调用类的构造函数来实例化对象。 示例： 使用clone方法： 通过调用对象的clone方法来创建对象的副本。需要注意的是，类必须实现Cloneable接口。 示例： 使用反序列化： 通过将对象序列化为字节流，然后再反序列化来创建对象。这通常用于对象的持久化存储和传输。 示例： 使用Class类的newInstance方法： 通过调用Class类的newInstance方法来创建对象。需要注意的是，该方法要求类具有无参构造函数。 示例： 使用Constructor的newInstance方法： 通过调用Constructor类的newInstance方法来创建对象。这种方式允许使用带参数的构造函数。 示例： new的对象什么时候回收？通过关键字new创建的对象，由Java的垃圾回收器（Garbage Collector, GC）负责回收。垃圾回收器的工作是在程序运行过程中自动进行的，它会周期性地检测不再被引用的对象，并将其回收以释放内存。 回收时机 Java对象的回收时机是由垃圾回收器根据一些算法来决定的，主要有以下几种情况： 引用计数法：当某个对象的引用计数为0时，表示该对象不再被引用，可以被回收。然而，Java并不采用引用计数法，因为它无法解决循环引用的问题。 可达性分析算法：从根对象（如方法区中的类静态属性、方法中的局部变量等）出发，通过对象之间的引用链进行遍历。如果存在一条引用链到达某个对象，则说明该对象是可达的；反之，不可达的对象将被回收。可达性分析算法是Java垃圾回收器主要采用的方法。 终结器（Finalizer）：如果对象重写了finalize()方法，垃圾回收器会在回收该对象之前调用finalize()方法。对象可以在finalize()方法中进行一些清理操作。然而，终结器机制的使用不被推荐，因为它的执行时间是不确定的，可能会导致不可预测的性能问题。 流程如下： 反射什么是反射？Java反射机制是指在运行状态中，任意一个类都能知道这个类中的所有方法和属性，并且任意对象都能调用这个类对象的属性和方法。这种动态获取的信息和调用对象方法的功能称为Java的反射机制。 反射机制如图所示： 动态性： 反射允许在运行时动态地获取类的完整结构信息，包括类名、父类、方法和属性等，并调用其方法（包括私有方法），而不需要在编译时确定。 示例：通过Class.forName()方法动态加载类，并使用getMethods()、getFields()等方法获取类的结构信息。 灵活性： 反射提供了灵活的编程方式，可以在运行时根据需要创建对象、调用方法和访问属性。 示例：使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。 访问私有成员： 反射可以访问类的私有成员（如私有方法和私有属性），这在正常情况下是不允许的。 示例：通过Field类的setAccessible(true)方法绕过访问控制，使用get()和set()方法访问和修改私有字段的值。 反射常见应用场景 框架开发：许多框架（如Spring、Hibernate）使用反射来动态加载和配置类，实现依赖注入和AOP（面向切面编程）等功能。 序列化和反序列化：在对象的序列化和反序列化过程中，反射用于动态地访问和设置对象的属性。 动态代理：反射与动态代理结合使用，可以在运行时创建代理对象，实现方法的拦截和增强。 单元测试：单元测试框架（如JUnit）使用反射来动态地发现和执行测试方法。 插件化系统：反射用于动态加载和执行插件，使得系统具有扩展性和灵活性。 ORM框架：ORM（对象关系映射）框架使用反射来将数据库表映射到Java对象，并动态地生成SQL语句。 反射的优缺点优点 灵活性：反射提供了极大的灵活性，允许在运行时动态地操作类和对象。 扩展性：反射使得系统具有更好的扩展性，可以通过插件或配置文件动态加载和执行代码。 缺点 性能开销：反射操作通常比直接调用方法或访问属性要慢，因为它涉及到动态解析和安全检查。 安全风险：反射可以访问和修改类的私有成员，这可能会导致安全问题。 代码可读性：反射代码通常比直接调用方法或访问属性的代码更复杂，可读性较差。 "},{"title":"What is Java ?（一）","date":"2024-07-15T05:14:00.000Z","url":"/2024/07/15/What-is-Java-%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["Java基本概念","/tags/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"],["数据类型","/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"],["面向对象","/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"]],"categories":[["Java","/categories/Java/"],["基础","/categories/Java/%E5%9F%BA%E7%A1%80/"]],"content":"内容：Java基本概念、数据类型、面向对象 本篇博客是笔者作为初学者记录自己对Java一些基本概念的理解。内容参考了大量网络资源，篇幅很长，旨在作为个人学习笔记，供自己日后回顾和复习。 概念Java的特点Java语言以其三大核心特点著称： 跨平台性：Java的口号“一次编译，处处运行”体现了其强大的跨平台能力。Java源代码经过编译后生成字节码文件（.class文件），这些字节码文件可以在任何安装了Java虚拟机（JVM）的平台上运行。需要注意的是，虽然Java语言本身是跨平台的，但JVM并非跨平台，因此在不同的操作系统上需要安装相应的JDK（Java Development Kit）。 面向对象：Java是一门严格遵循面向对象编程范式的语言。它将现实世界中的业务逻辑抽象为对象，并通过对象的属性和行为来描述这些逻辑，从而使得代码更贴近现实世界的模型，便于理解和维护。 自动内存管理：Java内置了垃圾回收机制，能够自动回收不再使用的内存资源，避免了开发者手动管理内存的繁琐工作。这一特性大大减少了内存泄漏和内存溢出等常见问题，提升了程序的稳定性和开发效率。 Java如何实现跨平台Java之所以能够实现跨平台运行，关键在于其核心组件——Java虚拟机（Java Virtual Machine，简称JVM）。JVM是Java Development Kit（JDK）中的一个重要组成部分，它负责将编译后的字节码文件解释并执行。 具体来说，Java源代码首先被编译成与平台无关的字节码文件（.class文件）。这些字节码文件随后被JVM解释执行。由于JVM在不同的操作系统上都有相应的实现版本，因此相同的字节码文件可以在安装了相应JVM的任何操作系统上运行。 这种机制使得Java具备了“一次编译，处处运行”的特性，极大地提高了代码的可移植性。开发者只需编写一次代码，并将其编译成字节码，就可以在多种平台上运行，而无需针对不同平台进行额外的编译工作。 Java与其他编程语言的区别与人类能够理解的自然语言不同，计算机只能理解由“0”和“1”组成的机器指令集。常见的编程语言如C&#x2F;C++、Java、Python、TypeScript等属于高级语言，这些语言编写的代码机器本身无法直接理解，需要经过特定的处理才能转化为机器指令。根据处理方式的不同，编程语言可以分为两大类： 编译型语言： 代表语言：C&#x2F;C++ 特点：源代码在运行前需要通过编译器编译成机器码，生成可执行文件。这种方式的优点是执行速度快，但缺点是可移植性较差，因为生成的机器码通常是针对特定平台的。 解释型语言： 代表语言：Python 特点：源代码在运行时由解释器逐行解释并执行。这种方式的优点是跨平台性好，但缺点是执行速度相对较慢。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java结合了编译型和解释型语言的特点，采用了编译+解释+即时编译（Just-In-Time Compilation，JIT）的执行方式，JVM解释执行流程图如下： 编译阶段： Java源代码首先被编译成字节码文件（.class文件），这些字节码文件是与平台无关的中间代码。 解释阶段： 字节码文件在运行时由Java虚拟机（JVM）解释执行，JVM将字节码翻译成特定平台的机器指令。 需要注意的是，字节码文件在JVM中并不仅仅被解释执行，同时也会使用即时编译技术进行优化。 即时编译（JIT）： 即时编译技术允许JVM在运行时将频繁执行的字节码直接编译成机器码，从而提高执行效率。 在JVM中，使用程序计数器（Program Counter，PC）来跟踪当前执行的字节码指令。当某个字节码指令被执行到一定次数时，JVM会启用即时编译技术。 JIT编译器会监控字节码的执行频率，当发现某些代码块频繁执行时，会将这些代码块编译成机器码，并缓存起来，以便后续执行时直接使用机器码，从而提高执行速度。 这种混合执行方式使得Java既具备了编译型语言的高效性，又具备了解释型语言的跨平台性。开发者只需编写一次代码，并将其编译成字节码，就可以在安装了JVM的任何平台上运行，从而实现了“一次编译，处处运行”的特性。 总结来说，Java通过其独特的编译+解释执行方式，在保持高效性的同时，实现了高度的跨平台性，这是它与其他编程语言的主要区别之一。 JDK、JRE、JVMJDK、JRE和JVM是Java开发和运行环境中的三个核心组件，它们之间的关系如下： JDK（Java Development Kit）：JDK是Java开发工具包，包含了开发Java应用程序所需的所有工具和库。主要组件包括编译器（javac）、调试工具（jdb）、Java标准库和其他开发工具所需的库。JDK中包含了JRE，因此开发者可以在本地运行和测试他们编写的Java程序。 JRE（Java Runtime Environment）：JRE是Java程序运行时所需的最小环境，包括一组Java库和JVM。主要组件包括Java标准库和JVM，确保Java程序能够在任何安装了JRE的系统上运行。 JVM（Java Virtual Machine）：JVM是Java虚拟机，是Java程序运行的核心环境。主要功能包括字节码解释执行、内存管理（包括垃圾回收）、安全性和跨平台性。JVM使得Java程序能够在不同的操作系统上运行，实现了“一次编译，处处运行”的特性。 三者的关系 JDK包含JRE：JDK是开发工具包，包含了开发Java应用程序所需的所有工具和库，其中就包括JRE。 JRE包含JVM：JRE是运行Java程序所需的最小环境，包含了Java库和JVM。 简而言之，JDK是开发工具包，JRE是运行环境，JVM是执行引擎。JDK包含JRE，JRE包含JVM。 数据类型基本数据类型Java中有8种基本数据类型，主要分为3类： 数值型： 整型：byte、short、int、long 浮点型：float、double 字符型：char 布尔型：boolean 各个数据类型所占字节数和取值范围表示如下（一个字节占8个bit位）： 数据类型 字节数 默认值 取值范围 byte 1 0 -128 到 127（-2^7~2^7-1） short 2 0 -32,768 到 32,767（-2^15~2^15-1） int 4 0 -2,147,483,648 到 2,147,483,647（-2^31~2^31-1） long 8 0L -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（-2^63~2^63-1） float 4 0.0f 大约 ±3.4E+38（有效位数为6-7位） double 8 0.0d 大约 ±1.7E+308（有效位数为15位） char 2 ‘\\u0000’ 0 到 65,535（Unicode字符） boolean 1 false true 或 false 数据类型转换数据类型转换方式在Java中，数据类型转换主要有以下几种方式： 自动类型转换（隐式转换） 当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，无需显式的类型转换。例如： 将 int 转换为 long 将 float 转换为 double 强制类型转换（显式转换） 当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。语法为： 例如： 将 long 转换为 int 将 double 转换为 int 字符串转换 Java提供了将字符串表示的数据转换为其他类型数据的方法。例如： 将字符串转换为整型 int，可以使用 Integer.parseInt() 方法。 将字符串转换为浮点型 double，可以使用 Double.parseDouble() 方法。 数值之间的转换 Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如 Character 类、Integer 类等提供了相应的转换方法。 类型互转可能出现的问题 数据丢失 当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如：将一个 long 类型的值转换为 int 类型时，如果 long 值超出了 int 类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。 数据溢出 与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如：将一个 int 类型的值转换为 long 类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。 精度损失 在进行浮点数类型的转换时，可能会发生精度损失。例如：将一个单精度浮点数（float）转换为双精度浮点数（double）时，精度可能会损失。 类型不匹配导致的错误 在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，可能会导致编译错误或运行时错误。 基本数据类型与包装类为何需要包装类？在Java中，包装类（Wrapper Classes）的存在有以下几个重要原因： 对象封装： 包装类将基本数据类型（如 int、char、boolean 等）封装成对象，使得这些基本数据类型可以像对象一样进行操作。例如，Integer 类不仅封装了 int 类型的数据，还提供了许多处理 int 数据的方法，如 parseInt()、valueOf() 等。 集合类的支持： Java中的集合类（如 ArrayList、HashMap 等）只能存储对象，不能直接存储基本数据类型。因此，如果需要将基本数据类型存储在集合中，必须将其包装成对应的包装类对象。例如，将 int 类型的数据存储在 ArrayList 中时，需要将其转换为 Integer 对象。 方法参数和返回值： 许多Java方法和API要求使用对象作为参数或返回值，而不是基本数据类型。例如，java.util.Collections 类中的许多方法都要求使用 List&lt;Integer&gt; 而不是 List&lt;int&gt;。 提供额外功能： 包装类提供了许多有用的方法来处理基本数据类型，如类型转换、字符串解析、比较等。例如，Integer 类提供了parseInt() 方法将字符串转换为 int，Double 类提供了 parseDouble() 方法将字符串转换为 double。 以下是包装类应用的示例代码： 包装类及其对应的基本数据类型： 包装类 对应的基本数据类型 Byte byte Short short Integer int Long long Float float Double double Character char Boolean boolean 通过使用包装类，Java开发者可以更方便地处理基本数据类型，并充分利用面向对象编程的优势。 基本数据类型与包装类的转换：装箱和拆箱在Java中，装箱（Boxing）和拆箱（Unboxing）是基本数据类型与其对应的包装类之间的自动转换过程。 装箱（Boxing）装箱是指将基本数据类型转换为其对应的包装类对象。Java编译器会自动完成这个过程，称为自动装箱。例如： 在这个例子中，int 类型的 num 被自动转换为 Integer 对象 wrappedNum。 拆箱（Unboxing）拆箱是指将包装类对象转换为其对应的基本数据类型。Java编译器也会自动完成这个过程，称为自动拆箱。例如： 在这个例子中，Integer 对象 wrappedNum 被自动转换为 int 类型的 num。 装箱和拆箱的应用场景 集合类：集合类（如 ArrayList、HashMap 等）只能存储对象，因此需要将基本数据类型装箱后才能存储在集合中。例如： 方法参数和返回值：许多方法要求使用对象作为参数或返回值，因此需要将基本数据类型装箱后传递给这些方法。例如： 通过装箱和拆箱，Java开发者可以更方便地在基本数据类型和包装类之间进行转换，从而充分利用面向对象编程的优势。 自动装拆箱的弊端虽然自动装箱（Autoboxing）和自动拆箱（Auto-unboxing）为Java开发者提供了便利，但它们也存在一些潜在的弊端和需要注意的问题： 性能开销：自动装箱和拆箱涉及到对象的创建和销毁，这会带来一定的性能开销。频繁的装箱和拆箱操作可能会导致性能下降，尤其是在循环或大量数据处理的情况下。 空指针异常：自动拆箱时，如果包装类对象为 null，会抛出 NullPointerException。例如： 代码可读性：过多的自动装箱和拆箱可能会降低代码的可读性，尤其是在复杂的表达式中。例如： 类型转换错误：自动装箱和拆箱可能会导致类型转换错误，尤其是在混合使用不同类型的包装类时。例如： 虽然自动装箱和拆箱为Java开发者提供了便利，但在使用时需要注意其潜在的性能开销、空指针异常、代码可读性和类型转换错误等问题。合理使用自动装箱和拆箱，可以提高代码的简洁性和可读性，但过度依赖可能会带来不必要的麻烦。 有了包装类，还留着基本数据类型干啥？在Java中，保留基本数据类型（Primitive Types）而不全部使用包装类（Wrapper Classes）有以下几个重要原因： 性能优势： 内存占用：基本数据类型直接存储在栈内存中，占用空间小，访问速度快。而包装类对象存储在堆内存中，占用空间较大，访问速度相对较慢。 操作效率：基本数据类型的操作（如算术运算、逻辑运算）直接在硬件层面上进行，效率更高。而包装类对象的操作需要通过方法调用，效率较低。 简化编程： 代码简洁性：基本数据类型的使用使得代码更加简洁明了，减少了不必要的对象创建和销毁。 避免空指针异常：基本数据类型没有 null 值，因此不会出现空指针异常。而包装类对象可能为 null，需要额外的空值检查。 语言设计的一致性： 历史兼容性：Java从一开始就设计了基本数据类型，许多现有的代码库和框架都依赖于基本数据类型。完全移除基本数据类型会破坏大量的现有代码。 语言特性：基本数据类型是Java语言的一部分，提供了语言设计的一致性和完整性。 基本数据类型在内存占用、操作效率和代码简洁性方面具有显著优势，因此在性能敏感的场景中，使用基本数据类型是更好的选择。而包装类则提供了对象封装、集合类支持和额外功能等优势，适用于需要对象操作和面向对象编程的场景。 Java通过保留基本数据类型和提供包装类，兼顾了性能和功能需求，使得开发者可以根据具体场景选择合适的数据类型，从而实现高效、灵活的编程。 面向对象面向对象编程简介面向对象编程（Object-Oriented Programming, OOP）是一种编程范式，通过构建对象（对象具有属性和行为）来表示现实世界中的实体及其行为。这种编程思想使得代码更易于理解和维护。 面向对象编程的核心特性包括： 封装（Encapsulation）：将对象的属性和行为结合在一起，隐藏内部实现细节，仅通过接口与外界交互。封装增强了代码的安全性和独立性，简化了编程复杂度。 继承（Inheritance）：子类可以继承父类的属性和方法，从而实现代码的复用。继承有助于构建层次化的类结构，减少重复代码。 多态（Polymorphism）：多态允许不同的类对象对同一消息做出不同的响应。多态分为两种类型： 编译时多态（静态多态），通过方法重载实现，即同一个方法名在不同参数下有不同的实现。 运行时多态（动态多态），通过方法重写实现，即子类重写父类的方法，在运行时根据对象类型调用相应的方法。（接口的实现也属于运行时多态。） 啥是多态？以上对多态的解释有点点抽象，我们可以进一步讲讲。 多态的体现多态（Polymorphism）是面向对象编程中的一个核心概念，它允许不同的对象对同一消息做出不同的响应。多态性使得代码更加灵活、可扩展和易于维护。多态性主要体现在以下几个方面： 1. 方法重载（Overloading）方法重载是指在同一个类中定义多个同名方法，但这些方法的参数列表不同（参数类型、数量或顺序不同）。编译器在编译时根据调用时提供的参数类型和数量来决定调用哪个方法。 示例： 在这个示例中，Calculator 类中有三个 add 方法，但它们的参数列表不同。编译器根据调用时提供的参数类型和数量来决定调用哪个方法。 2. 方法重写（Overriding）方法重写是指子类重新定义父类中已有的方法，以实现不同的操作逻辑。重写的方法需要加上 @Override 注解。在程序运行时，系统会根据引用对象的实际类型来调用具体版本的方法。 示例： 在这个示例中，Dog 和 Cat 类都重写了 Animal 类的 makeSound 方法。在运行时，根据实际对象类型调用相应的方法。 3. 接口实现（Interface Implementation）接口实现是指多个类可以实现同一个接口，并提供各自的方法实现。接口实现体现了多态性，因为不同的类可以对同一个接口方法提供不同的实现。 示例： 在这个示例中，Circle 和 Rectangle 类都实现了 Shape 接口，并提供了各自的 draw 方法实现。在运行时，根据实际对象类型调用相应的方法。 4. 上转型与下转型（Upcasting and Downcasting） 上转型（Upcasting）：将子类对象赋值给父类引用，称为上转型。上转型是安全的，因为子类对象包含了父类的所有属性和方法。 下转型（Downcasting）：将父类引用强制转换为子类引用，称为下转型。下转型需要谨慎使用，因为如果父类引用指向的对象不是子类类型，会导致运行时错误。 示例： 在这个示例中，myAnimal 是 Animal 类型的引用，但实际上指向 Dog 对象。通过上转型，可以调用 Dog 重写的 makeSound 方法。通过下转型，可以调用 Dog 特有的 fetch 方法。 多态能够用来干啥？多态（Polymorphism）是面向对象编程中的一个核心特性，它允许子类替换父类，并在实际代码运行过程中调用子类的方法实现。多态性需要编程语言提供特殊的语法机制来实现，比如继承、接口类等。多态可以提高代码的扩展性和复用性，是许多设计模式、设计原则和编程技巧的基础。 面向对象设计原则：SOLID原则面向对象设计中有常见的五大设计原则，简称SOLID原则。SOLID原则是一组指导原则，旨在帮助开发者创建更灵活、可维护和可扩展的软件系统。这些原则分别是：单一职责原则（SRP）、开闭原则（OCP）、里氏替换原则（LSP）、接口隔离原则（ISP）和依赖倒置原则（DIP）。 1. 单一职责原则（Single Responsibility Principle, SRP）定义：一个类应该只有一个引起它变化的原因，即一个类应该只负责一个职责。 简单示例： 不好的设计：一个类既负责计算工资，又负责保存员工信息。 好的设计：将计算工资和保存员工信息分别放在两个不同的类中。 2. 开闭原则（Open&#x2F;Closed Principle, OCP）定义：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即在不修改现有代码的情况下，可以通过扩展来增加新功能。 简单示例： 不好的设计：每次增加新图形时，都需要修改计算面积的代码。 好的设计：通过定义一个抽象的图形接口，新增图形时只需实现该接口，而不需要修改现有代码。 3. 里氏替换原则（Liskov Substitution Principle, LSP）定义：子类应该能够替换所有其父类的引用，而不会影响程序的正确性。为了保证数据安全，子类的行为应该与父类一致或更严格。 简单示例： 不好的设计：鸟类可以飞，但企鹅不能飞，子类行为与父类不一致。 好的设计：将飞行的行为抽象出来，只有能飞的鸟类才实现该行为。 4. 接口隔离原则（Interface Segregation Principle, ISP）定义：客户端不应该依赖于它不需要的接口，即接口应该小而精、细粒度。 简单示例： 不好的设计：一个接口包含多个方法，但某些类只需要其中一部分方法。 好的设计：将接口拆分为多个小接口，每个接口只包含相关的方法。 5. 依赖倒置原则（Dependency Inversion Principle, DIP）定义：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 简单示例： 不好的设计：高层模块直接依赖于低层模块的具体实现。例如，一个高层模块直接创建并使用低层模块的对象。 好的设计：通过依赖抽象接口，高层模块不直接依赖于低层模块的具体实现，而是通过接口注入的形式调用实现。例如，高层模块依赖于一个抽象接口，并通过构造函数或setter方法注入具体的实现类。 抽象类和普通类、抽象类和接口的区别抽象类与普通类的区别抽象类和普通类都可以被继承，但它们在功能和使用场景上存在显著差异： 实例化能力： 抽象类：无法被实例化，通常作为基类使用，用于定义子类的通用行为和属性。 普通类：可以被实例化，用于创建具体的对象。 方法实现： 抽象类：可以包含抽象方法（没有具体实现的方法），也可以包含具体实现的方法。抽象类不能使用 final 修饰符，因为 final 修饰符用于禁止该类被继承或方法被子类重写，这与抽象类的设计目的相冲突。 普通类：必须实现所有方法，不能包含抽象方法。 静态方法： 抽象类：允许包含静态方法，但静态方法无法访问抽象类的实例成员，因为抽象类无法实例化。 普通类：允许包含静态方法，静态方法可以访问类的实例成员。 抽象类与接口的区别抽象类和接口在设计目的和使用方式上有所不同： 设计目的： 抽象类：用于定义类的通用行为和属性，提供部分实现，子类可以继承并扩展这些行为。 接口：用于定义一组行为契约，实现类必须遵循这些契约，接口不提供任何实现。 构造方法： 抽象类：可以包含构造方法，用于初始化抽象类的成员变量。 接口：不能包含构造方法，因为接口不涉及实例化。 方法实现： 抽象类：可以包含具体实现的方法，子类可以选择性地覆盖这些方法。 接口：除了定义静态方法外，其他方法默认是抽象的，必须由实现类来实现。但从 Java 8 开始，接口可以包含默认方法（default 方法），这些方法可以有具体实现，并且实现类可以选择性地覆盖这些默认方法。但注意，静态方法不能被实现类覆盖。 继承与实现： 抽象类：一个类只能继承一个抽象类。 接口：一个类可以实现多个接口。 成员变量： 抽象类：可以包含成员变量，这些变量可以是静态的、非静态的、常量等。 接口：只能包含静态常量（默认是 public static final）且必须赋予初始值，不能包含非静态成员变量。 访问修饰符： 抽象类：方法和成员变量可以使用所有访问修饰符（public、protected、private）。 接口：所有方法默认是 public，不能使用其他访问修饰符。成员变量默认是 public static final。 静态了解了面向对象的多态特性，那么Java中的静态也一同了解一下吧~ 静态变量和静态方法在 Java 中，静态变量和静态方法与类本身关联，而不与类的实例化对象关联。它们在内存中独此一份，可以被类的所有实例化对象共享。 静态变量（类变量）静态变量是通过 static 关键字修饰的变量，属于类而不属于实例对象。静态变量在类被加载时初始化，只会分配一次内存。所有的实例对象都能共享该静态变量，也就是说，如果一个实例对象修改了该静态变量，其他实例对象调用该变量时也会看到修改后的值。静态变量可以通过类名访问，也可以通过实例对象访问（但推荐使用类名访问）。 静态方法静态方法也是通过 static 关键字修饰的方法，属于类而不属于实例对象。静态方法在类被加载时初始化，可以被类的所有实例化对象共享。静态方法可以通过类名直接调用，不需要创建类的实例对象。 总结 静态变量：属于类，所有实例对象共享，可以通过类名或实例对象访问（推荐使用类名）。 静态方法：属于类，可以通过类名直接调用，不需要创建实例对象。 静态内部类静态内部类是使用 static 关键字修饰的内部类。与静态变量和静态方法类似，静态内部类属于外部类本身，而不是外部类的实例对象。 静态内部类与非静态内部类的区别 访问方式：静态内部类可以通过外部类名直接访问，不需要创建外部类的实例对象；非静态内部类依赖于外部类的实例，需要通过外部类的实例对象来访问。 访问权限： 静态内部类：只能访问外部类的静态变量和静态方法。不能直接访问外部类的私有成员变量和方法，必须通过外部类的实例来访问（为什么呢？因为private 修饰符表示成员只能在声明它的类内部访问，即使是私有静态成员变量和方法，对于静态内部类来说也是不可见的）。 非静态内部类：可以访问外部类的实例变量和方法，包括私有成员变量和方法。 实例化方式：静态内部类可以独立实例化，不需要依赖外部类的实例；非静态内部类必须等待外部类实例化后，才能实例化自己的对象。 示例代码 编译器如何实现非静态内部类直接访问其外部类方法？非静态内部类可以直接访问外部类的实例变量和方法，包括私有成员。这是通过编译器在内部类中生成一个隐式的外部类引用实现的。 编译器生成的代码 编译器在生成非静态内部类的字节码时，会自动为内部类添加一个指向外部类实例的引用。这个引用通常命名为 this$0，用于访问外部类的实例成员。 编译器生成的字节码大致如下： 通过这种方式，非静态内部类可以直接访问外部类的实例成员，而不需要显式地传递外部类的实例。 在继承关系中，实例化子类时静态加载顺序在继承关系中，当一个父类与子类都存在静态变量、静态方法时，实例化子类时的加载顺序如下： 加载父类的静态代码块：父类的静态代码块（即静态变量、静态方法等）在首次使用到与父类相关的代码时加载，并且仅加载一次。 加载子类的静态代码块：子类的静态代码块（即静态变量、静态方法等）在首次使用到与子类相关的代码时加载，并且仅加载一次。 加载父类的构造函数：父类的构造函数在实例化子类时首先被调用。 加载子类的构造函数：子类的构造函数在父类的构造函数执行完毕后被调用。 示例代码 输出结果 解释 在首次使用到与父类相关的代码时（即实例化子类时），父类的静态代码块首先被加载并执行。接着，子类的静态代码块在首次使用到与子类相关的代码时（即实例化子类时）被加载并执行。然后，父类的构造函数在实例化子类时被调用。最后，子类的构造函数在父类的构造函数执行完毕后被调用。 总结 在继承关系中，实例化子类时的静态加载顺序是： 父类的静态代码块（仅在首次使用时加载） 子类的静态代码块（仅在首次使用时加载） 父类的构造函数 子类的构造函数 "},{"date":"2024-09-19T14:54:30.115Z","url":"/CSS/custom.css","categories":[["undefined",""]],"content":"/* 对所有段落应用缩进，但不包括列表项 */ p:not(li p) { text-indent: 2em; }"}]